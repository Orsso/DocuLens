<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocuLens - √âditeur de Sections</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-main.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-sections.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-images.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-modals.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/image-editor.css') }}" rel="stylesheet">
</head>
<body>
    <div class="container-fluid px-4 py-3">


        <div class="row">
            <!-- Configuration Panel -->
            <div class="col-lg-3">
                <div class="config-panel">
                    <div class="glass-card">
                        <h5 class="mb-3"><i class="fas fa-cog me-2"></i>Configuration</h5>
                        
                        <div class="config-form">
                            <div class="form-group">
                                <label class="form-label">Pr√©fixe</label>
                                <input type="text" id="prefixInput" class="form-control" value="CRL" placeholder="CRL">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Nom du Document</label>
                                <input type="text" id="documentNameInput" class="form-control" value="{{ result.document_name }}" placeholder="Nom du document">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Format</label>
                                <select id="formatSelect" class="form-control">
                                    <option value="jpg">JPEG (.jpg)</option>
                                    <option value="png">PNG (.png)</option>
                                </select>
                            </div>
                        </div>
                        
                        <hr style="border-color: rgba(59, 130, 246, 0.2); margin: 1.5rem 0;">
                        
                        <div class="d-grid gap-2">
                            <button class="btn-glass" onclick="addNewSection()">
                                <i class="fas fa-plus"></i>
                                Ajouter Section
                            </button>
                            
                            <button class="btn-glass" onclick="toggleSelectAll()" id="selectAllBtn">
                                <i class="fas fa-check-square"></i>
                                <span id="selectAllText">Tout s√©lectionner</span>
                            </button>
                            
                            <button class="btn-glass" onclick="exportImages()">
                                <i class="fas fa-download"></i>
                                Exporter ZIP
                            </button>
                            

                            
                            <a href="/" class="btn-glass text-center">
                                <i class="fas fa-arrow-left"></i>
                                Retour
                            </a>
                        </div>
                    </div>
                    
                    <!-- Tips Box - R√©tractable -->
                    <div class="tips-box">
                        <div class="tips-header" onclick="toggleTips()">
                            <div class="tips-title">
                                <i class="fas fa-lightbulb"></i>
                                <span>Conseils d'utilisation</span>
                            </div>
                            <i class="fas fa-chevron-down tips-chevron" id="tipsChevron"></i>
                        </div>
                        <div class="tips-content" id="tipsContent">
                            <div class="tip-item">
                                <i class="fas fa-plus-circle"></i>
                                <span>Utilisez le bouton violet sur une section pour cr√©er une sous-section</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-edit"></i>
                                <span>Cliquez sur la bo√Æte bleue du num√©ro pour modifier la nomenclature (ex: ANNEXE-A)</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-arrows-alt"></i>
                                <span>Glissez-d√©posez les sections par leur bo√Æte bleue pour les r√©organiser</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sections Editor -->
            <div class="col-lg-9">
                <!-- Zone Images Non Attribu√©es -->
                <div id="unassignedImagesContainer" class="unassigned-container" style="display: none;">
                    <div class="glass-card unassigned-card">
                        <div class="unassigned-header">
                            <div class="unassigned-title">
                                <i class="fas fa-inbox"></i>
                                <span>Images non attribu√©es</span>
                                <span id="unassignedBadge" class="unassigned-badge">0</span>
                            </div>
                        </div>
                        <div class="images-grid" id="unassignedGrid" data-section-id="unassigned">
                            <!-- Images non attribu√©es -->
                        </div>
                    </div>
                </div>
                
                <div id="sectionsContainer" class="sections-container">
                    <!-- Les sections seront g√©n√©r√©es par JavaScript -->
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="empty-state" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <h4>Aucune section cr√©√©e</h4>
                    <p>Cliquez sur "Ajouter Section" pour commencer</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <div class="glass-card">
            <div class="stats-grid">
                <div class="stat-item">
                    <span id="sectionsCount" class="stat-number">0</span>
                    <span class="stat-label">Sections</span>
                </div>
                <div class="stat-item">
                    <span id="imagesCount" class="stat-number">{{ result.total_images }}</span>
                    <span class="stat-label">Images</span>
                </div>
                <div class="stat-item">
                    <span id="selectedCount" class="stat-number">0</span>
                    <span class="stat-label">S√©lectionn√©es</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div class="modal fade" id="imageModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title text-white">Aper√ßu de l'image</h5>
                    <div class="modal-navigation-info">
                        <span id="modalImageCounter" class="text-white-50"></span>
                    </div>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body text-center position-relative">
                    <button id="prevImageBtn" class="btn-modal-nav btn-modal-prev" onclick="navigateImage(-1)" title="Image pr√©c√©dente (‚Üê)">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <img id="modalImage" src="" class="img-fluid rounded" style="max-height: 70vh;">
                    <button id="nextImageBtn" class="btn-modal-nav btn-modal-next" onclick="navigateImage(1)" title="Image suivante (‚Üí)">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <div class="modal-image-loading" id="modalImageLoading" style="display: none;">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                </div>
                <div class="modal-footer">
                    <div id="modalImageInfo" class="text-white"></div>
                    <div class="modal-actions">
                        <button id="editFromModalBtn" class="btn btn-purple" onclick="editCurrentModalImage()" title="√âditer cette image">
                            <i class="fas fa-edit"></i> √âditer l'image
                        </button>
                    </div>
                    <div class="modal-keyboard-hint">
                        <small class="text-white-50">
                            <i class="fas fa-keyboard"></i> Utilisez ‚Üê ‚Üí pour naviguer, √âchap pour fermer
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Button -->
    <div class="debug-button" onclick="showDebugModal()" title="Diagnostic du syst√®me">
        <i class="fas fa-bug"></i>
    </div>

    <!-- Debug Modal -->
    <div class="debug-modal" id="debugModal">
        <div class="debug-modal-content">
            <div class="debug-modal-header">
                <div class="debug-modal-title">
                    <i class="fas fa-bug"></i>
                    <span>Diagnostic du Syst√®me</span>
                </div>
                <button class="debug-modal-close" onclick="closeDebugModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="debug-modal-body" id="debugModalBody">
                <!-- Le contenu de debug sera ins√©r√© ici -->
            </div>
        </div>
    </div>



    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <script type="application/json" id="sectionsData">{{ result.sections | tojson | safe }}</script>
    <script type="application/json" id="imagesData">{{ result.extracted_files | tojson | safe }}</script>
    
    <script>
        // √âtat global de l'application
        let appState = {
            sections: [],
            unassignedImages: [],
            prefix: 'CRL',
            documentName: '{{ result.document_name }}',
            format: 'jpg',
            nextSectionId: 1,
            maxSubsectionId: {}  // Stocke le prochain ID de sous-section pour chaque section
        };

        // Images extraites du serveur
        let extractedImages = [];
        
        // Sections d√©tect√©es par le serveur
        let detectedSections = JSON.parse(document.getElementById('sectionsData').textContent);



        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            logInfo('üöÄ Initialisation de DocuLens v2');
            setupEventListeners();
            loadImagesFromServer();
            lockDocumentNameAfterProcessing();
            setupDragStackMouseTracking();
            
            // Nettoyer les tooltips au chargement pour √©viter les r√©sidus
            setTimeout(() => {
                cleanupTooltips();
                logInfo('‚úÖ Initialisation termin√©e');
            }, 1000);
        });

        // Debug info
        function logDebug(message, data = null) {
            if (data) {
                console.log(`üêõ ${message}`, data);
            } else {
                console.log(`üêõ ${message}`);
            }
        }
        
        function initializeApp() {
            // Debug : afficher toutes les images extraites
            console.log('üñºÔ∏è Images extraites du serveur:', extractedImages.length);
            extractedImages.forEach((img, i) => {
                console.log(`  ${i+1}. ${img.filename} - Section: "${img.section}" - Page: ${img.page}`);
            });
            
            // Cr√©er les sections bas√©es sur la d√©tection automatique
            if (detectedSections && detectedSections.length > 0) {
                console.log('üîç Sections d√©tect√©es:', detectedSections.length);
                detectedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. Section "${section.number}" (niveau ${section.level || 1}) - Titre: "${section.title}"`);
                });
                
                // Trier les sections d√©tect√©es par ordre hi√©rarchique
                const sortedSections = [...detectedSections].sort((a, b) => {
                    return compareVersions(a.number, b.number);
                });
                
                console.log('üìã Ordre de cr√©ation des sections:');
                sortedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. ${section.number} (niveau ${section.level || 1})`);
                });
                
                // Cr√©er les sections selon l'ordre hi√©rarchique
                sortedSections.forEach((detectedSection, index) => {
                    const sectionName = detectedSection.title || `Section ${detectedSection.number}`;
                    const level = detectedSection.level || 1;
                    
                    // D√©terminer si c'est une sous-section et trouver le parent
                    let parentSectionId = null;
                    
                    if (level > 1 && detectedSection.number.includes('.')) {
                        const parentNumber = detectedSection.number.split('.')[0];
                        const parentSection = appState.sections.find(s => 
                            s.sectionNumber == parentNumber || s.nomenclatureNumber == parentNumber
                        );
                        if (parentSection) {
                            parentSectionId = parentSection.id;
                            console.log(`  üîó Section ${detectedSection.number} rattach√©e au parent ${parentNumber} (ID: ${parentSectionId})`);
                        } else {
                            console.warn(`  ‚ö†Ô∏è  Parent ${parentNumber} non trouv√© pour section ${detectedSection.number}`);
                        }
                    }
                    
                    const createdSection = addNewSection(sectionName, parentSectionId);
                    
                    if (createdSection) {
                        // Assigner les images de cette section
                        const sectionImages = extractedImages.filter(img => 
                            img.section === detectedSection.number.toString()
                        );
                        
                        createdSection.images = sectionImages;
                        createdSection.sectionNumber = detectedSection.number;
                        createdSection.nomenclatureNumber = detectedSection.number; // Par d√©faut, m√™me que le num√©ro de section
                        createdSection.level = level;
                        createdSection.isCustomNomenclature = false; // D√©tection automatique, pas personnalis√©e
                        console.log(`  üìÅ Section ${detectedSection.number}: ${sectionImages.length} images (niveau ${level})`);
                    }
                });
                
                // Forcer la renum√©ration finale et le rendu
                console.log('üî¢ Renum√©ration finale...');
                renumberSections(false); // Ne pas √©craser les nomenclatures personnalis√©es
                renderSections();
                updateUnassignedImages();
                debugImageAssignment();
            } else {
                // Fallback : cr√©er une section par d√©faut
                console.log('‚ö†Ô∏è  Aucune section d√©tect√©e, cr√©ation d\'une section par d√©faut');
                if (extractedImages.length > 0) {
                    addNewSection('Section 1');
                    appState.sections[0].images = [...extractedImages];
                    renderSections();
                    updateUnassignedImages();
                }
            }
            updateStats();
        }
        
        function debugImageAssignment() {
            console.log('üîç DEBUG - √âtat apr√®s initialisation:');
            console.log(`  Total images extraites: ${extractedImages.length}`);
            
            let debugInfo = {
                totalExtracted: extractedImages.length,
                sections: [],
                totalAssigned: 0,
                unassigned: appState.unassignedImages.length,
                problems: []
            };
            
            // Analyser chaque section
            appState.sections.forEach(section => {
                const sectionInfo = {
                    number: section.sectionNumber,
                    nomenclature: section.nomenclatureNumber,
                    level: section.level,
                    imageCount: section.images.length,
                    images: section.images.map(img => img.filename)
                };
                debugInfo.sections.push(sectionInfo);
                debugInfo.totalAssigned += section.images.length;
                console.log(`  Section ${section.sectionNumber}: ${section.images.length} images`);
            });
            
            console.log(`  Images assign√©es total: ${debugInfo.totalAssigned}`);
            console.log(`  Images non attribu√©es: ${debugInfo.unassigned}`);
            console.log(`  Diff√©rence: ${debugInfo.totalExtracted - debugInfo.totalAssigned - debugInfo.unassigned}`);
            
            // V√©rifier les probl√®mes
            if (debugInfo.totalExtracted !== debugInfo.totalAssigned + debugInfo.unassigned) {
                console.error('‚ùå PROBL√àME: Des images sont perdues!');
                
                // Trouver les images perdues
                const assignedFilenames = new Set();
                appState.sections.forEach(section => {
                    section.images.forEach(img => assignedFilenames.add(img.filename));
                });
                appState.unassignedImages.forEach(img => assignedFilenames.add(img.filename));
                
                const lostImages = extractedImages.filter(img => !assignedFilenames.has(img.filename));
                debugInfo.problems.push({
                    type: 'error',
                    message: 'Images perdues d√©tect√©es',
                    details: lostImages
                });
                console.error('Images perdues:', lostImages);
            }
            
            return debugInfo;
        }
        
        function showDebugModal() {
            const modal = document.getElementById('debugModal');
            const body = document.getElementById('debugModalBody');
            
            let html = '<div class="debug-section">';
            html += '<div class="debug-section-title">√âtat de l\'Application</div>';
            html += `<div class="debug-info">Sections: ${appState.sections.length}</div>`;
            html += `<div class="debug-info">Images totales: ${extractedImages.length}</div>`;
            html += `<div class="debug-info">Images non assign√©es: ${appState.unassignedImages.length}</div>`;
            html += `<div class="debug-info">Images s√©lectionn√©es: ${selectedImages.size}</div>`;
            html += '</div>';
            
            // Diagnostic sp√©cial pour les duplications
            html += '<div class="debug-section">';
            html += '<div class="debug-section-title">Diagnostic Duplication</div>';
            
            // Compter les doublons dans extractedImages
            const filenameCount = {};
            extractedImages.forEach(img => {
                filenameCount[img.filename] = (filenameCount[img.filename] || 0) + 1;
            });
            const duplicatesInExtracted = Object.entries(filenameCount).filter(([filename, count]) => count > 1);
            
            html += `<div class="debug-info ${duplicatesInExtracted.length > 0 ? 'error' : 'success'}">`;
            html += `Doublons dans extractedImages: ${duplicatesInExtracted.length}</div>`;
            if (duplicatesInExtracted.length > 0) {
                duplicatesInExtracted.forEach(([filename, count]) => {
                    html += `<div class="debug-info error">  ‚Ä¢ ${filename}: ${count} occurrences</div>`;
                });
            }
            
            // Compter les doublons dans le DOM
            const domFilenames = {};
            document.querySelectorAll('[data-image-filename]').forEach(card => {
                const filename = card.getAttribute('data-image-filename');
                domFilenames[filename] = (domFilenames[filename] || 0) + 1;
            });
            const duplicatesInDOM = Object.entries(domFilenames).filter(([filename, count]) => count > 1);
            
            html += `<div class="debug-info ${duplicatesInDOM.length > 0 ? 'error' : 'success'}">`;
            html += `Doublons dans le DOM: ${duplicatesInDOM.length}</div>`;
            if (duplicatesInDOM.length > 0) {
                duplicatesInDOM.forEach(([filename, count]) => {
                    html += `<div class="debug-info error">  ‚Ä¢ ${filename}: ${count} cartes</div>`;
                        });
                    }
            
            // Compter les doublons dans les sections
            const sectionFilenames = {};
            appState.sections.forEach(section => {
                section.images.forEach(img => {
                    sectionFilenames[img.filename] = (sectionFilenames[img.filename] || 0) + 1;
                });
            });
            const duplicatesInSections = Object.entries(sectionFilenames).filter(([filename, count]) => count > 1);
            
            html += `<div class="debug-info ${duplicatesInSections.length > 0 ? 'error' : 'success'}">`;
            html += `Doublons dans les sections: ${duplicatesInSections.length}</div>`;
            if (duplicatesInSections.length > 0) {
                duplicatesInSections.forEach(([filename, count]) => {
                    html += `<div class="debug-info error">  ‚Ä¢ ${filename}: ${count} r√©f√©rences</div>`;
                });
            }
            
            html += '</div>';

            // Section Console des logs
            html += '<div class="debug-section">';
            html += '<div class="debug-section-title">Console des Logs</div>';
            html += '<div style="max-height: 300px; overflow-y: auto; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 0.5rem; font-family: monospace; font-size: 0.75rem;">';
            
            if (appLogs && appLogs.length > 0) {
                // Afficher les 20 derniers logs
                const recentLogs = appLogs.slice(0, 20);
                recentLogs.forEach(log => {
                    const typeColor = log.type === 'error' ? '#ff6b6b' : 
                                     log.type === 'info' ? '#4dabf7' : 
                                     log.type === 'debug' ? '#69db7c' : '#ffd43b';
                    
                    html += `<div style="color: ${typeColor}; margin-bottom: 0.25rem; border-bottom: 1px solid #333; padding-bottom: 0.25rem;">`;
                    html += `<span style="color: #888;">[${log.time}]</span> `;
                    html += `<span style="color: ${typeColor}; font-weight: bold;">${log.type.toUpperCase()}:</span> `;
                    html += `<span style="color: #fff;">${log.message}</span>`;
                    if (log.data) {
                        html += `<br/><span style="color: #aaa; margin-left: 2rem;">${JSON.stringify(log.data)}</span>`;
                    }
                    html += '</div>';
                });
                
                html += `<div style="color: #888; text-align: center; margin-top: 0.5rem; font-style: italic;">`;
                html += `Affichage des 20 derniers logs sur ${appLogs.length} total`;
                html += '</div>';
            } else {
                html += '<div style="color: #888; text-align: center; padding: 1rem;">Aucun log disponible</div>';
            }
            
            html += '</div>';
            html += '<div style="margin-top: 0.5rem;">';
            html += '<button class="btn btn-secondary btn-sm" onclick="clearLogs(); showDebugModal();">Vider les logs</button>';
            html += '</div>';
            html += '</div>';

            body.innerHTML = html;
            modal.style.display = 'flex';
        }
        
        function closeDebugModal() {
            document.getElementById('debugModal').style.display = 'none';
        }

        // Style pour les √©l√©ments de debug
        const debugStyles = `
            .debug-info.success { color: #10b981; }
            .debug-info.warning { color: #f59e0b; }
            .debug-info.error { color: #ef4444; font-weight: bold; }
            .debug-section { margin-bottom: 1.5rem; }
            .debug-section-title { 
                font-weight: bold; 
                color: var(--accent-blue); 
                border-bottom: 1px solid var(--accent-blue); 
                padding-bottom: 0.5rem; 
                margin-bottom: 1rem; 
            }
        `;
        
        // Ajouter les styles si pas d√©j√† ajout√©s
        if (!document.getElementById('debugStyles')) {
            const styleSheet = document.createElement('style');
            styleSheet.id = 'debugStyles';
            styleSheet.textContent = debugStyles;
            document.head.appendChild(styleSheet);
        }

        // === FONCTION DE SUPPRESSION SIMPLIFI√âE ===
        
        function deleteImage(filename, event) {
            event.stopPropagation();
            logInfo(`üóëÔ∏è Suppression de l'image: ${filename}`);
            
            // Trouver l'image dans les sections et la remettre dans les non assign√©es
            let imageToMove = null;
            
            // Chercher dans les sections
            for (let section of appState.sections) {
                const imageIndex = section.images.findIndex(img => img.filename === filename);
                if (imageIndex !== -1) {
                    imageToMove = section.images.splice(imageIndex, 1)[0];
                    break;
                }
            }
            
            // Si l'image n'√©tait pas dans une section, elle √©tait d√©j√† dans les non assign√©es
            if (imageToMove) {
                // Remettre dans les images non assign√©es
                appState.unassignedImages.push(imageToMove);
                
                // D√©s√©lectionner l'image si elle √©tait s√©lectionn√©e
                selectedImages.delete(filename);
                
                // Mettre √† jour l'interface
                renderSections();
                updateUnassignedImages();
                updateStats();
                
                logInfo(`‚úÖ Image d√©plac√©e vers les non attribu√©es: ${filename}`);
                showToast(`Image "${filename}" remise dans les non attribu√©es`, 'info');
            }
        }
        
        function showToast(message, type = 'info') {
            // Simple notification toast
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                z-index: 10000;
                font-size: 0.9rem;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(8px);
                transform: translateX(100%);
                transition: transform 0.3s ease;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // Animation d'entr√©e
            setTimeout(() => {
                toast.style.transform = 'translateX(0)';
            }, 100);
            
            // Suppression automatique
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }
        
        function clearLogs() {
            appLogs = [];
            logInfo('Logs vid√©s manuellement');
            // Rafra√Æchir la modal si elle est ouverte
            if (document.getElementById('debugModal').style.display === 'flex') {
                showDebugModal();
            }
        }
        
        function syncSelectionStateWithDOM() {
            logDebug('üîÑ Synchronisation DOM avec √©tat de s√©lection...');
            
            let syncCount = 0;
            const allImageCards = document.querySelectorAll('.image-card');
            
            allImageCards.forEach(card => {
                const filename = card.dataset.imageFilename;
                const shouldBeSelected = selectedImages.has(filename);
                const isCurrentlySelected = card.classList.contains('selected');
                
                if (shouldBeSelected && !isCurrentlySelected) {
                    card.classList.add('selected');
                    syncCount++;
                    logDebug(`‚úÖ Classe 'selected' ajout√©e √† ${filename}`);
                } else if (!shouldBeSelected && isCurrentlySelected) {
                    card.classList.remove('selected');
                    syncCount++;
                    logDebug(`‚ùå Classe 'selected' supprim√©e de ${filename}`);
                }
            });
            
            if (syncCount > 0) {
                logInfo(`üîÑ ${syncCount} images synchronis√©es avec l'√©tat de s√©lection`);
            }
        }
        
        function diagnoseSelectionIssue() {
            logInfo('=== DIAGNOSTIC COMPLET DE LA S√âLECTION ===');
            
            // V√©rifier l'√©tat des s√©lections
            logInfo(`Images s√©lectionn√©es en m√©moire: ${selectedImages.size}`);
            selectedImages.forEach(filename => {
                logInfo(`  - ${filename}`);
            });
            
            // V√©rifier l'√©tat dans le DOM
            const allImageCards = document.querySelectorAll('.image-card');
            logInfo(`Images totales dans le DOM: ${allImageCards.length}`);
            
            let domSelectedCount = 0;
            allImageCards.forEach((card, index) => {
                const filename = card.dataset.imageFilename;
                const hasSelectedClass = card.classList.contains('selected');
                const isInMemory = selectedImages.has(filename);
                
                if (hasSelectedClass) domSelectedCount++;
                
                if (hasSelectedClass !== isInMemory) {
                    logError(`Incoh√©rence d√©tect√©e - ${filename}: DOM=${hasSelectedClass}, M√©moire=${isInMemory}`);
                }
                
                // Log d√©taill√© pour chaque section
                const sectionEl = card.closest('[data-section-id]');
                const sectionId = sectionEl ? sectionEl.dataset.sectionId : 'inconnu';
                
                logDebug(`Image ${index + 1}: ${filename} | Section: ${sectionId} | DOM selected: ${hasSelectedClass} | Memory: ${isInMemory}`);
            });
            
            logInfo(`Images s√©lectionn√©es dans le DOM: ${domSelectedCount}`);
            
            if (domSelectedCount !== selectedImages.size) {
                logError(`PROBL√àME: ${selectedImages.size} en m√©moire vs ${domSelectedCount} dans le DOM`);
            }
            
            logInfo('=== FIN DIAGNOSTIC ===');
        }
        
        // Fermer la modal debug en cliquant en dehors
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('debugModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeDebugModal();
                }
            });
        });

        function setupEventListeners() {
            // Configuration inputs
            document.getElementById('prefixInput').addEventListener('input', (e) => {
                appState.prefix = e.target.value || 'CRL';
                updateAllFilenames();
            });
            
            document.getElementById('documentNameInput').addEventListener('input', (e) => {
                // Ne pas permettre de changer le nom du document apr√®s traitement
                // car cela casserait les URLs des images
                console.warn('Changement du nom de document d√©sactiv√© apr√®s traitement');
            });
            
            document.getElementById('formatSelect').addEventListener('change', (e) => {
                appState.format = e.target.value;
                updateAllFilenames();
            });
        }
        
        function lockDocumentNameAfterProcessing() {
            const documentNameInput = document.getElementById('documentNameInput');
            if (documentNameInput) {
                documentNameInput.disabled = true;
                documentNameInput.style.opacity = '0.6';
                documentNameInput.style.cursor = 'not-allowed';
                documentNameInput.title = 'Le nom du document ne peut pas √™tre modifi√© apr√®s traitement';
                
                // Ajouter une ic√¥ne de cadenas
                const parent = documentNameInput.parentElement;
                const lockIcon = document.createElement('i');
                lockIcon.className = 'fas fa-lock';
                lockIcon.style.position = 'absolute';
                lockIcon.style.right = '10px';
                lockIcon.style.top = '50%';
                lockIcon.style.transform = 'translateY(-50%)';
                lockIcon.style.color = 'var(--text-secondary)';
                lockIcon.style.pointerEvents = 'none';
                parent.style.position = 'relative';
                parent.appendChild(lockIcon);
            }
        }

        function loadImagesFromServer() {
            // Utiliser les images extraites directement du template
            const extractedFiles = JSON.parse(document.getElementById('imagesData').textContent);
            
            // Convertir les donn√©es du serveur au format attendu par le client
            extractedImages = extractedFiles.map(file => ({
                filename: file.filename,
                section: file.section,
                page: file.page,
                image_number: file.image_number
            }));
            
            console.log('üìä Images charg√©es:', extractedImages.length, 'images');
            console.log('üìä Premi√®re image:', extractedImages[0]);
            
            appState.unassignedImages = []; // Laisser vide, sera calcul√© correctement apr√®s l'initialisation
            initializeApp();
            updateStats();
        }

        function addNewSection(name = null, parentSectionId = null, afterSectionId = null) {
            try {
                let sectionNumber, sectionName, level, nomenclatureNumber;
                let insertIndex = appState.sections.length; // Par d√©faut, √† la fin
                
                logInfo(`Ajout nouvelle section - name: "${name}", parent: ${parentSectionId}, after: ${afterSectionId}`);
            
            if (parentSectionId) {
                // Cr√©er une sous-section ou sous-sous-section
                const parentSection = appState.sections.find(s => s.id === parentSectionId);
                if (!parentSection) {
                    console.error(`‚ùå Section parent ${parentSectionId} introuvable`);
                    return;
                }
                
                const parentNumber = parentSection.sectionNumber || parentSection.number;
                
                // Initialiser le compteur de sous-sections pour cette section parent
                if (!appState.maxSubsectionId[parentNumber]) {
                    appState.maxSubsectionId[parentNumber] = 1;
                } else {
                    appState.maxSubsectionId[parentNumber]++;
                }
                
                sectionNumber = `${parentNumber}.${appState.maxSubsectionId[parentNumber]}`;
                level = (parentSection.level || 1) + 1;
                nomenclatureNumber = sectionNumber; // Par d√©faut, m√™me que le num√©ro hi√©rarchique
                
                sectionName = name || `Section ${sectionNumber}`;
                
                // Position pour sous-section : apr√®s le parent et ses sous-sections existantes
                const parentIndex = appState.sections.findIndex(s => s.id === parentSectionId);
                insertIndex = parentIndex + 1;
                
                // Trouver la position apr√®s toutes les sous-sections existantes du parent
                while (insertIndex < appState.sections.length && 
                       appState.sections[insertIndex].parentId === parentSectionId) {
                    insertIndex++;
                }
            } else if (afterSectionId) {
                // Cr√©er une section principale apr√®s une section sp√©cifique
                const afterSection = appState.sections.find(s => s.id === afterSectionId);
                if (afterSection) {
                    const afterIndex = appState.sections.findIndex(s => s.id === afterSectionId);
                    insertIndex = afterIndex + 1;
                    
                    // Si la section apr√®s laquelle on ins√®re a des sous-sections, ins√©rer apr√®s toutes ses sous-sections
                    while (insertIndex < appState.sections.length && 
                           (appState.sections[insertIndex].parentId === afterSectionId ||
                            (appState.sections[insertIndex].level > 1 && 
                             appState.sections[insertIndex].sectionNumber && 
                             appState.sections[insertIndex].sectionNumber.startsWith(afterSection.sectionNumber + '.')))) {
                        insertIndex++;
                    }
                }
                
                // Le num√©ro sera d√©termin√© apr√®s insertion et renum√©ration
                level = 1;
                sectionName = name || `Section temporaire`;
                nomenclatureNumber = "temp";
            } else {
                // Cr√©er une section principale √† la fin ou lors de l'initialisation
                const mainSections = appState.sections.filter(s => (s.level || 1) === 1);
                if (name && name.includes('Section ') && !isNaN(parseInt(name.split(' ')[1]))) {
                    // Si un nom avec num√©ro est fourni, l'utiliser
                    const providedNumber = parseInt(name.split(' ')[1]);
                    sectionNumber = providedNumber;
                } else {
                    sectionNumber = mainSections.length + 1;
                }
                sectionName = name || `Section ${sectionNumber}`;
                nomenclatureNumber = sectionNumber.toString();
                level = 1;
            }
            
            const newSection = {
                id: appState.nextSectionId++,
                name: sectionName,
                number: insertIndex + 1,                    // Position dans la liste (sera mise √† jour)
                sectionNumber: sectionNumber,               // Num√©ro hi√©rarchique (sera mis √† jour si n√©cessaire)
                nomenclatureNumber: nomenclatureNumber,     // Num√©ro utilis√© dans la nomenclature des fichiers
                level: level,
                parentId: parentSectionId,
                images: []
            };
            
            console.log(`  üìù Section cr√©√©e: "${newSection.name}" (n¬∞${newSection.sectionNumber}, niveau ${newSection.level})`);
            
            // Ins√©rer la section √† la position calcul√©e
            appState.sections.splice(insertIndex, 0, newSection);
            
            // Ne pas renumb√©roter automatiquement lors de l'initialisation pour pr√©server les num√©ros d√©tect√©s
            if (!name || !name.includes('Section ')) {
                renumberSections(true);
            }
            
            // Toujours faire le rendu et mettre √† jour les stats apr√®s ajout
            renderSections();
            updateStats();
            updateUnassignedImages();
            
            return newSection;
            } catch (error) {
                logError('Erreur lors de l\'ajout de section:', error);
                return null;
            }
        }
        
                 function renumberSections(isAutomaticRename = true) {
             let mainSectionCount = 1;
             const subsectionCounters = {};
             
             appState.sections.forEach((section, index) => {
                 section.number = index + 1; // Position dans la liste
                 
                 if (section.level === 1) {
                     const oldSectionNumber = section.sectionNumber;
                     section.sectionNumber = mainSectionCount.toString();
                     
                     // Mise √† jour automatique de la nomenclature seulement si c'est un rename automatique
                     if (isAutomaticRename && (!section.nomenclatureNumber || 
                         section.nomenclatureNumber === oldSectionNumber || 
                         section.nomenclatureNumber === (mainSectionCount - 1).toString() || 
                         section.nomenclatureNumber === "temp")) {
                         section.nomenclatureNumber = mainSectionCount.toString();
                         section.isCustomNomenclature = false; // Flag pour indiquer que ce n'est pas personnalis√©
                     } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                         section.isCustomNomenclature = true; // Flag pour indiquer une personnalisation
                     }
                     
                     // Mettre √† jour le nom si c'√©tait temporaire
                     if (section.name === "Section temporaire") {
                         section.name = `Section ${mainSectionCount}`;
                     }
                     subsectionCounters[mainSectionCount] = 1;
                     mainSectionCount++;
                 } else if (section.level === 2 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise √† jour automatique seulement si appropri√©
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                         subsectionCounters[section.sectionNumber] = 1;
                     }
                 } else if (section.level === 3 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise √† jour automatique seulement si appropri√©
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                     }
                 }
             });
         }

        function deleteSection(sectionId) {
            const sectionIndex = appState.sections.findIndex(s => s.id === sectionId);
            if (sectionIndex !== -1) {
                const sectionToDelete = appState.sections[sectionIndex];
                
                if (sectionToDelete.level === 1) {
                    // Section principale : supprimer aussi toutes les sous-sections
                    const subsections = appState.sections.filter(s => s.parentId === sectionId);
                    const sectionsToDelete = [sectionToDelete, ...subsections];
                
                    // Collecter toutes les images √† animer vers unassigned
                    const imagesToAnimate = [];
                sectionsToDelete.forEach(section => {
                        imagesToAnimate.push(...section.images.map(img => img.filename));
                        console.log(`üì§ Images de la section ${section.sectionNumber || section.number} pr√©par√©es pour animation vers non-assign√©es (${section.images.length} images)`);
                    });
                    
                    if (imagesToAnimate.length > 0) {
                        // Animer le d√©placement vers unassigned
                        animateImagesMoveToSection(imagesToAnimate, 'unassigned');
                        
                        // Supprimer les sections apr√®s un d√©lai pour que l'animation d√©marre
                        setTimeout(() => {
                sectionsToDelete.forEach(section => {
                    const index = appState.sections.findIndex(s => s.id === section.id);
                    if (index !== -1) {
                        appState.sections.splice(index, 1);
                    }
                });
                        }, 200);
                    } else {
                        // Pas d'images, suppression directe
                        sectionsToDelete.forEach(section => {
                            const index = appState.sections.findIndex(s => s.id === section.id);
                            if (index !== -1) {
                                appState.sections.splice(index, 1);
                            }
                        });
                        finalizeSectionDeletion();
                    }
                } else {
                    // Sous-section : les images remontent dans la section parente
                    let parentSection = appState.sections.find(s => s.id === sectionToDelete.parentId);
                    
                    // Si pas de parentId, essayer de trouver par hi√©rarchie num√©rique
                    if (!parentSection && sectionToDelete.sectionNumber) {
                        const parentNumber = sectionToDelete.sectionNumber.split('.').slice(0, -1).join('.');
                        if (parentNumber) {
                            parentSection = appState.sections.find(s => 
                                (s.sectionNumber === parentNumber || s.nomenclatureNumber === parentNumber) && 
                                s.level < sectionToDelete.level
                            );
                        }
                    }
                    
                    if (parentSection && sectionToDelete.images.length > 0) {
                        // D'abord transf√©rer les images vers la section parente dans les donn√©es
                        parentSection.images.push(...sectionToDelete.images);
                        
                        // Animer les images vers la section parente
                        const imagesToAnimate = sectionToDelete.images.map(img => img.filename);
                        console.log(`‚¨ÜÔ∏è Images de la sous-section ${sectionToDelete.sectionNumber || sectionToDelete.number} pr√©par√©es pour animation vers section parente ${parentSection.sectionNumber || parentSection.number} (${sectionToDelete.images.length} images)`);
                        
                        // Vider les images de la section √† supprimer (elles sont maintenant dans le parent)
                        sectionToDelete.images = [];
                        
                        // D√©clencher l'animation mais avec un flag sp√©cial pour √©viter double d√©placement
                        animateSubsectionImagesToParent(imagesToAnimate, parentSection.id);
                        
                        // Supprimer la sous-section apr√®s un d√©lai
                        setTimeout(() => {
                            appState.sections.splice(sectionIndex, 1);
                            finalizeSectionDeletion();
                        }, 200);
                    } else if (sectionToDelete.images.length > 0) {
                        // Si pas de parent trouv√©, animer vers unassigned
                        const imagesToAnimate = sectionToDelete.images.map(img => img.filename);
                        console.log(`üì§ Images de la sous-section orpheline ${sectionToDelete.sectionNumber || sectionToDelete.number} pr√©par√©es pour animation vers non-assign√©es (${sectionToDelete.images.length} images)`);
                        
                        animateImagesMoveToSection(imagesToAnimate, 'unassigned');
                        
                        // Supprimer la sous-section apr√®s un d√©lai
                        setTimeout(() => {
                            appState.sections.splice(sectionIndex, 1);
                        }, 200);
                    } else {
                        // Pas d'images, suppression directe
                        appState.sections.splice(sectionIndex, 1);
                        finalizeSectionDeletion();
                    }
                }
            }
        }
        
        function animateSubsectionImagesToParent(imagesToAnimate, parentSectionId) {
            logInfo(`üé¨ Animation sp√©ciale sous-section vers parent pour ${imagesToAnimate.length} images`);
            
            // Animer les images avec un d√©lai √©chelonn√© pour un effet cascade
            imagesToAnimate.forEach((filename, index) => {
                setTimeout(() => {
                    animateImageMove(filename, parentSectionId);
                }, index * 100); // 100ms de d√©lai entre chaque image
            });
            
            // Mettre √† jour l'interface apr√®s l'animation (sans d√©placer les donn√©es qui sont d√©j√† au bon endroit)
            const totalDelay = imagesToAnimate.length * 100 + 700; // 700ms = dur√©e de l'animation
            setTimeout(() => {
                renderSections();
                updateUnassignedImages();
                updateStats();
                logInfo(`‚úÖ Animation sous-section vers parent termin√©e`);
            }, totalDelay);
        }
        
        function finalizeSectionDeletion() {
                // Renumb√©roter les sections (automatique)
                renumberSections(true);
                renderSections();
            updateUnassignedImages();
                updateStats();
                updateAllFilenames();
        }

                function cleanupTooltips() {
            // Supprimer tous les tooltips existants pour √©viter les doublons
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                tooltip.remove();
            });
            
            // Disposer des instances Bootstrap Tooltip existantes
            document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(element => {
                const tooltipInstance = bootstrap.Tooltip.getInstance(element);
                if (tooltipInstance) {
                    tooltipInstance.dispose();
                }
            });
        }

        function renderSections() {
            logInfo('[DIAGNOSTIC] renderSections appel√©e - d√©but du rendu');
            
            const container = document.getElementById('sectionsContainer');
            const emptyState = document.getElementById('emptyState');
            
            if (appState.sections.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                logInfo('[DIAGNOSTIC] Aucune section, affichage de l\'√©tat vide');
                return;
            }
            
            emptyState.style.display = 'none';
            
            // Compter les images avant le rendu
            const imageCountBeforeRender = document.querySelectorAll('[data-image-filename]').length;
            
            // Organiser les sections par hi√©rarchie
            const organizedHTML = buildHierarchicalSections(appState.sections);
            container.innerHTML = organizedHTML;
            
            // Compter les images apr√®s le rendu
            const imageCountAfterRender = document.querySelectorAll('[data-image-filename]').length;
            
            logInfo(`[DIAGNOSTIC] Images dans le DOM - Avant: ${imageCountBeforeRender}, Apr√®s: ${imageCountAfterRender}`);
            
            // Forcer la synchronisation de l'√©tat de s√©lection
            syncSelectionStateWithDOM();
            
            // Initialiser les zones de drop
            setupSortable();
            
            // Nettoyer les anciens tooltips pour √©viter les doublons
            cleanupTooltips();
            
            // Activer les nouveaux tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
            
            logInfo('[DIAGNOSTIC] renderSections termin√©e');
        }
        
        function buildHierarchicalSections(sections) {
            let html = '';
            
            // Filtrer les sections principales (niveau 1)
            const mainSections = sections.filter(s => (s.level || 1) === 1);
            
            mainSections.forEach(mainSection => {
                html += renderMainSection(mainSection, sections);
            });
            
            return html;
        }
        
                function renderMainSection(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            const nomenclatureNumber = mainSection.nomenclatureNumber || sectionNumber;
            
            // Trouver toutes les sous-sections de cette section principale et les organiser hi√©rarchiquement
            const subsections = getOrderedSubsections(mainSection, allSections);
            
            let html = `
            <div class="section-group-wrapper">
                ${renderSectionCard(mainSection, subsections)}
            </div>
            `;
            
            return html;
        }
        
        function getOrderedSubsections(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            
            // R√©cup√©rer toutes les sections qui appartiennent √† cette section principale
            const relatedSections = allSections.filter(s => 
                s.level > 1 && 
                s.sectionNumber && 
                s.sectionNumber.startsWith(sectionNumber + '.')
            );
            
            // Trier par num√©ro de section pour respecter l'ordre hi√©rarchique
            relatedSections.sort((a, b) => {
                return compareVersions(a.sectionNumber, b.sectionNumber);
            });
            
            return relatedSections;
        }
        
        function compareVersions(a, b) {
            const aParts = a.split('.').map(Number);
            const bParts = b.split('.').map(Number);
            
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const aPart = aParts[i] || 0;
                const bPart = bParts[i] || 0;
                
                if (aPart !== bPart) {
                    return aPart - bPart;
                }
            }
            
            return 0;
        }
        
        function renderHierarchicalSubsections(subsections) {
            let html = '';
            let currentLevel2Section = null;
            let level3Sections = [];
            
            for (let i = 0; i < subsections.length; i++) {
                const section = subsections[i];
                
                if (section.level === 2) {
                    // Si on avait une section niveau 2 en cours, on la rend avec ses sous-sections niveau 3
                    if (currentLevel2Section) {
                        html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
                        level3Sections = [];
                    }
                    currentLevel2Section = section;
                } else if (section.level === 3 && currentLevel2Section) {
                    // Ajouter cette sous-sous-section √† la liste de la section niveau 2 courante
                    level3Sections.push(section);
                } else {
                    // Section orpheline, la rendre directement
                    html += renderSectionCard(section);
                }
            }
            
            // Traiter la derni√®re section niveau 2 s'il y en a une
            if (currentLevel2Section) {
                html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
            }
            
            return html;
        }
        
        function renderSectionWithSubsections(level2Section, level3Sections) {
            let html = renderSectionCard(level2Section);
            
            if (level3Sections.length > 0) {
                html += '<div class="sub-sub-sections-container">';
                html += level3Sections.map(sub => renderSectionCard(sub)).join('');
                html += '</div>';
            }
            
            return html;
        }
        
        function renderSectionCard(section, subsections = []) {
            const level = section.level || 1;
            const sectionNumber = section.sectionNumber || section.number;
            const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
            const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
            
            // Classes CSS selon le niveau
            let cardClass = 'section-editor glass-card';
            if (level === 1) {
                cardClass += subsections.length > 0 ? ' main-section-with-subs' : ' main-section';
            } else if (level === 2) {
                cardClass += ' sub-section';
            } else {
                cardClass += ' sub-sub-section';
            }
            
            return `
            <div class="${cardClass}" data-section-id="${section.id}">
                <div class="section-header">
                    <div class="section-title">
                        <div class="section-number" title="Cliquez pour modifier la nomenclature (actuellement: ${nomenclatureNumber})" 
                             onclick="editNomenclature(${section.id}, '${nomenclatureNumber}', this)">
                            ${levelIcon} <span class="section-number-text">${sectionNumber}</span>
                            ${section.isCustomNomenclature && nomenclatureNumber !== sectionNumber ? `<span class="nomenclature-badge">‚Üí ${nomenclatureNumber}</span>` : ''}
                        </div>
                    </div>
                    <div class="section-controls">
                        ${level < 3 ? `
                            <button class="btn-icon btn-add-sub" onclick="addNewSection(null, ${section.id})" 
                                    data-bs-toggle="tooltip" title="Ajouter une ${level === 1 ? 'sous-section' : 'sous-sous-section'}">
                                <i class="fas fa-plus-circle"></i>
                            </button>
                        ` : ''}
                        <button class="btn-icon btn-section-delete" onclick="deleteSection(${section.id})"
                                data-bs-toggle="tooltip" title="Supprimer cette ${level === 1 ? 'section' : level === 2 ? 'sous-section' : 'sous-sous-section'}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="images-grid" data-section-id="${section.id}">
                    ${section.images.map((image, index) => renderImageCard(image, nomenclatureNumber, index + 1)).join('')}
                </div>
                
                ${level === 1 && subsections.length > 0 ? `
                    <div class="subsections-container">
                        ${renderHierarchicalSubsections(subsections)}
                    </div>
                ` : ''}
            </div>
            `;
        }

        function renderImageCard(image, sectionNumber, imageNumber) {
            const filename = generateFilename(sectionNumber, imageNumber);
            const isSelected = selectedImages.has(image.filename);
            
            // Log d√©taill√© pour le diagnostic
            logDebug(`Rendu image: ${image.filename} | G√©n√©r√©: ${filename} | S√©lectionn√©e: ${isSelected}`);
            
            if (isSelected) {
                logDebug(`‚úÖ Image s√©lectionn√©e √† rendre: ${image.filename} dans section ${sectionNumber}`);
            }
            
            return `
                <div class="image-card ${isSelected ? 'selected' : ''}" data-image-filename="${image.filename}" onclick="toggleImageSelectionByClick('${image.filename}')">
                    <img src="/image/${appState.documentName}/${image.filename}" 
                         alt="${image.filename}" class="image-preview" 
                         onerror="this.style.display='none'">
                    <div class="image-overlay">
                        <button class="btn-zoom" onclick="showImagePreview('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Agrandir l'image">
                            <i class="fas fa-search-plus"></i>
                        </button>

                        <button class="btn-assign" onclick="showSectionSelector('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Assigner √† une section">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                        <button class="btn-image-delete" onclick="deleteImage('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Supprimer l'image">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <div class="image-info">
                        <div class="image-filename">${filename}</div>
                        <div class="image-page">Page ${image.page}</div>
                    </div>
                </div>
            `;
        }

        function setupSortable() {
            // Sortable pour les grilles d'images
            document.querySelectorAll('.images-grid').forEach(grid => {
                new Sortable(grid, {
                    group: 'images',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    onStart: function(evt) {
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const totalImages = isSelected ? selectedImages.size : (selectedImages.size > 0 ? selectedImages.size + 1 : 1);
                        
                        // Marquer les images comme √©tant dragg√©es (les masquer)
                        markImagesAsBeingDragged(imageFilename);
                        
                        // Cr√©er le stack visuel si multiple images
                        if (totalImages > 1) {
                            // Position initiale
                            const rect = evt.item.getBoundingClientRect();
                            createDragStack(imageFilename, rect.left + rect.width/2, rect.top + rect.height/2);
                        }
                    },
                    onMove: function(evt) {
                        // Mettre √† jour la position du stack pendant le drag
                        if (isDraggingMultiple && dragStackContainer) {
                            const rect = evt.related.getBoundingClientRect();
                            updateDragStackPosition(rect.left, rect.top);
                        }
                    },
                    onAdd: function(evt) {
                        const sectionId = parseInt(evt.to.dataset.sectionId);
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const dropIndex = evt.newIndex;
                        
                        // Pr√©parer la liste des images √† d√©placer dans le bon ordre d'origine
                        const imagesToMove = [];
                        
                        // Si l'image dragu√©e n'√©tait pas s√©lectionn√©e, elle va en premier
                        if (!isSelected) {
                            imagesToMove.push(imageFilename);
                        }
                        
                        // Ajouter les images s√©lectionn√©es dans l'ordre qu'elles avaient dans leur section d'origine
                        const selectedInOrder = getSelectedImagesInSourceOrder();
                        imagesToMove.push(...selectedInOrder);
                        
                        // D√©placer les images en pr√©servant l'ordre et la position
                        moveImagesToSectionAtPosition(imagesToMove, sectionId, dropIndex);
                        
                        clearSelection();
                        renderSections();
                        updateUnassignedImages();
                    },
                    onUpdate: function(evt) {
                        // R√©organisation dans la m√™me section
                        const sectionId = parseInt(evt.from.dataset.sectionId);
                        if (sectionId && !isNaN(sectionId)) {
                            reorderImagesInSection(sectionId);
                        }
                        updateUnassignedImages();
                    },
                    onEnd: function(evt) {
                        // Nettoyer le stack et les √©tats de drag
                        removeDragStack();
                        unmarkImagesAsBeingDragged();
                    }
                });
            });
            
            // Sortable pour les groupes de sections principales
            const sectionsContainer = document.getElementById('sectionsContainer');
            if (sectionsContainer) {
                new Sortable(sectionsContainer, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '[class*="main-section"] .section-number', // Seules les sections principales peuvent √™tre d√©plac√©es
                    onEnd: function(evt) {
                        // R√©organiser les sections selon le nouvel ordre des groupes
                        rebuildSectionsOrderFromDOM();
                        
                        // Renum√©ration automatique apr√®s d√©placement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            }
            
            // Sortable pour les sous-sections dans leurs containers
            document.querySelectorAll('.subsections-container').forEach(container => {
                new Sortable(container, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '.section-number', // Sous-sections peuvent √™tre r√©organis√©es entre elles
                    onEnd: function(evt) {
                        // R√©organiser les sous-sections
                        rebuildSectionsOrderFromDOM();
                        
                        // Renum√©ration automatique apr√®s d√©placement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            });
        }
        
        function rebuildSectionsOrderFromDOM() {
            const newOrder = [];
            
            // Parcourir chaque wrapper de section
            document.querySelectorAll('.section-group-wrapper').forEach(wrapper => {
                // Ajouter la section principale
                const mainSectionEl = wrapper.querySelector('.main-section, .main-section-with-subs');
                if (mainSectionEl) {
                    const mainSectionId = parseInt(mainSectionEl.dataset.sectionId);
                    const mainSection = appState.sections.find(s => s.id === mainSectionId);
                    if (mainSection) {
                        newOrder.push(mainSection);
                    }
                    
                    // Ajouter les sous-sections dans l'ordre
                    const subsectionsContainer = mainSectionEl.querySelector('.subsections-container');
                    if (subsectionsContainer) {
                        // Parcourir dans l'ordre : sous-sections niveau 2, puis leurs sous-sections niveau 3
                        subsectionsContainer.querySelectorAll('.sub-section').forEach(subEl => {
                            const subSectionId = parseInt(subEl.dataset.sectionId);
                            const subSection = appState.sections.find(s => s.id === subSectionId);
                            if (subSection) {
                                newOrder.push(subSection);
                                
                                // Ajouter les sous-sous-sections de cette sous-section
                                const subSubContainer = subEl.nextElementSibling;
                                if (subSubContainer && subSubContainer.classList.contains('sub-sub-sections-container')) {
                                    subSubContainer.querySelectorAll('.sub-sub-section').forEach(subSubEl => {
                                        const subSubSectionId = parseInt(subSubEl.dataset.sectionId);
                                        const subSubSection = appState.sections.find(s => s.id === subSubSectionId);
                                        if (subSubSection) {
                                            newOrder.push(subSubSection);
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
            });
            
            appState.sections = newOrder;
        }

        function moveImageToSection(imageFilename, targetSectionId) {
            // Trouver l'image
            let image = null;
            let sourceSection = null;
            
            // Chercher dans unassigned
            const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === imageFilename);
            if (unassignedIndex !== -1) {
                image = appState.unassignedImages.splice(unassignedIndex, 1)[0];
            } else {
                // Chercher dans les sections
                for (let section of appState.sections) {
                    const imageIndex = section.images.findIndex(img => img.filename === imageFilename);
                    if (imageIndex !== -1) {
                        image = section.images.splice(imageIndex, 1)[0];
                        sourceSection = section;
                        break;
                    }
                }
            }
            
            if (image) {
                if (targetSectionId === 'unassigned') {
                    // Remettre dans les non attribu√©es
                    appState.unassignedImages.push(image);
                } else {
                    // Ajouter √† la section cible
                    const targetSection = appState.sections.find(s => s.id === targetSectionId);
                    if (targetSection) {
                        targetSection.images.push(image);
                    }
                }
                updateStats();
                updateAllFilenames();
            }
        }
        
        function moveImagesToSectionAtPosition(imageFilenames, targetSectionId, insertIndex) {
            console.log(`üì¶ D√©placement group√© de ${imageFilenames.length} images vers section ${targetSectionId} √† l'index ${insertIndex}`);
            
            // Collecter toutes les images dans l'ordre fourni (qui respecte l'ordre d'origine)
            const imagesToMove = [];
            
            // Pour chaque nom de fichier dans l'ordre fourni, trouver et collecter l'image
            imageFilenames.forEach(filename => {
                let image = null;
                
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    image = appState.unassignedImages[unassignedIndex];
                    if (image) imagesToMove.push(image);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            image = section.images[imageIndex];
                            if (image) imagesToMove.push(image);
                            break;
                        }
                    }
                }
            });
            
            // Maintenant supprimer les images de leurs positions actuelles
            // Supprimer dans l'ordre inverse pour √©viter les d√©calages d'index
            imageFilenames.slice().reverse().forEach(filename => {
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    appState.unassignedImages.splice(unassignedIndex, 1);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            section.images.splice(imageIndex, 1);
                            break;
                        }
                    }
                }
            });
            
            console.log(`  üìã ${imagesToMove.length} images collect√©es pour d√©placement (ordre pr√©serv√©)`);
            
            if (imagesToMove.length === 0) return;
            
            if (targetSectionId === 'unassigned') {
                // Ajouter toutes les images aux non attribu√©es
                appState.unassignedImages.push(...imagesToMove);
            } else {
                // Ins√©rer dans la section cible √† la position sp√©cifi√©e
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    // Calculer la position d'insertion r√©elle (en tenant compte des suppressions)
                    let actualInsertIndex = Math.min(insertIndex, targetSection.images.length);
                    
                    // Ins√©rer toutes les images en bloc √† la position calcul√©e
                    targetSection.images.splice(actualInsertIndex, 0, ...imagesToMove);
                    
                    console.log(`  ‚úÖ Images ins√©r√©es dans section ${targetSection.sectionNumber} √† l'index ${actualInsertIndex}`);
                }
            }
            
            updateStats();
            updateAllFilenames();
        }

        function reorderImagesInSection(sectionId) {
            // R√©cup√©rer l'ordre actuel depuis le DOM
            const grid = document.querySelector(`[data-section-id="${sectionId}"]`);
            const imageCards = grid.querySelectorAll('.image-card');
            const section = appState.sections.find(s => s.id === sectionId);
            
            if (section) {
                const newOrder = Array.from(imageCards).map(card => {
                    const filename = card.dataset.imageFilename;
                    return section.images.find(img => img.filename === filename);
                }).filter(img => img); // Filtrer les undefined
                
                section.images = newOrder;
                updateAllFilenames();
            }
        }


        
        function updateNomenclatureNumber(sectionId, newNumber) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (section) {
                section.nomenclatureNumber = newNumber.trim();
                // Marquer comme personnalis√© si diff√©rent du num√©ro de section
                section.isCustomNomenclature = (newNumber.trim() !== section.sectionNumber);
                updateAllFilenames();
                renderSections(); // Re-render pour mettre √† jour l'exemple et les noms de fichiers
            }
        }
        
        function editNomenclature(sectionId, currentNomenclature, element) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (!section) return;
            
            // Cr√©er un input temporaire
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentNomenclature;
            input.className = 'nomenclature-input';
            input.style.cssText = `
                background: rgba(15, 23, 42, 0.9);
                border: 2px solid var(--accent-blue);
                border-radius: 6px;
                color: white;
                padding: 0.25rem 0.5rem;
                font-size: 0.9rem;
                font-weight: 600;
                font-family: Monaco, Menlo, monospace;
                min-width: 100px;
                outline: none;
            `;
            
            // Remplacer temporairement le contenu
            const originalHTML = element.innerHTML;
            element.innerHTML = '';
            element.appendChild(input);
            
            // Focus et s√©lectionner le texte
            input.focus();
            input.select();
            
            // Fonction pour valider et revenir √† l'affichage normal
            const finishEdit = () => {
                const newValue = input.value.trim();
                if (newValue && newValue !== currentNomenclature) {
                    updateNomenclatureNumber(sectionId, newValue);
                } else {
                    // Annuler, remettre l'affichage original
                    element.innerHTML = originalHTML;
                }
            };
            
            // √âv√©nements
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    element.innerHTML = originalHTML;
                }
            });
        }

        function generateFilename(sectionNumber, imageNumber) {
            return `${appState.prefix}-${appState.documentName}-${sectionNumber} n_${imageNumber}.${appState.format}`;
        }

        function updateAllFilenames() {
            // Mettre √† jour l'affichage des noms de fichiers
            renderSections();
        }

        function updateStats() {
            document.getElementById('sectionsCount').textContent = appState.sections.length;
            document.getElementById('imagesCount').textContent = extractedImages.length;
            updateSelectionStats();
        }

        function updateUnassignedImages() {
            console.log('üîÑ Mise √† jour des images non attribu√©es...');
            
            const assignedFilenames = new Set();
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    assignedFilenames.add(image.filename);
                });
            });
            
            console.log(`  Images assign√©es: ${assignedFilenames.size}`);
            console.log(`  Images extraites total: ${extractedImages.length}`);
            
            appState.unassignedImages = extractedImages.filter(image => 
                !assignedFilenames.has(image.filename)
            );
            
            console.log(`  Images non attribu√©es calcul√©es: ${appState.unassignedImages.length}`);
            
            renderUnassignedImages();
        }
        
        function renderUnassignedImages() {
            const container = document.getElementById('unassignedImagesContainer');
            const grid = document.getElementById('unassignedGrid');
            const badge = document.getElementById('unassignedBadge');
            
            // TOUJOURS vider le contenu HTML d'abord pour √©viter les doublons
            grid.innerHTML = '';
            
            if (appState.unassignedImages.length === 0) {
                container.style.display = 'none';
            } else {
                container.style.display = 'block';
                badge.textContent = appState.unassignedImages.length;
                
                grid.innerHTML = appState.unassignedImages.map((image, index) => 
                    renderImageCard(image, 'NON-ATTRIBUEE', index + 1)
                ).join('');
                
                // Synchroniser l'√©tat de s√©lection pour les images non attribu√©es
                setTimeout(() => {
                    const unassignedCards = grid.querySelectorAll('.image-card');
                    unassignedCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (selectedImages.has(filename) && !card.classList.contains('selected')) {
                            card.classList.add('selected');
                            logDebug(`‚úÖ Synchronisation: classe 'selected' ajout√©e √† ${filename} (non attribu√©e)`);
                        }
                    });
                }, 10);
            }
        }

        function showImagePreview(filename, event = null) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            logDebug(`Aper√ßu demand√© pour: ${filename}`);
            
            // Construire la liste de toutes les images disponibles
            buildCurrentImagesList();
            
            // Trouver l'index de l'image courante
            currentImageIndex = currentImagesList.findIndex(img => img.filename === filename);
            if (currentImageIndex === -1) {
                currentImageIndex = 0;
                logError(`Image non trouv√©e dans la liste: ${filename}`);
            }
            
            // Cr√©er ou r√©cup√©rer l'instance de modal
            if (!imageModalInstance) {
                imageModalInstance = new bootstrap.Modal(document.getElementById('imageModal'));
                setupModalKeyboardNavigation();
            }
            
            // Afficher l'image actuelle
            displayCurrentImage();
            
            // Afficher la modal
            imageModalInstance.show();
        }
        
        function buildCurrentImagesList() {
            currentImagesList = [];
            
            // Ajouter d'abord les images non attribu√©es
            appState.unassignedImages.forEach(image => {
                currentImagesList.push({
                    filename: image.filename,
                    page: image.page,
                    section: 'Non attribu√©es',
                    sectionNumber: 'N/A'
                });
            });
            
            // Puis ajouter les images de toutes les sections dans l'ordre
            appState.sections.forEach(section => {
                section.images.forEach((image, index) => {
                    currentImagesList.push({
                        filename: image.filename,
                        page: image.page,
                        section: section.name,
                        sectionNumber: section.nomenclatureNumber || section.sectionNumber || section.number,
                        imageNumber: index + 1
                    });
                });
            });
            
            logDebug(`Liste d'images construite: ${currentImagesList.length} images`);
        }
        
        function displayCurrentImage() {
            if (currentImagesList.length === 0) return;
            
            const currentImage = currentImagesList[currentImageIndex];
            const modalImage = document.getElementById('modalImage');
            const modalInfo = document.getElementById('modalImageInfo');
            const modalCounter = document.getElementById('modalImageCounter');
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            const loading = document.getElementById('modalImageLoading');
            
            // Afficher le loading
            loading.style.display = 'block';
            modalImage.style.opacity = '0.5';
            
            // Mettre √† jour les boutons de navigation
            prevBtn.disabled = currentImageIndex === 0;
            nextBtn.disabled = currentImageIndex === currentImagesList.length - 1;
            
            // Mettre √† jour le compteur
            modalCounter.textContent = `${currentImageIndex + 1} / ${currentImagesList.length}`;
            
            // Charger la nouvelle image avec timestamp anti-cache
            const newImageSrc = `/image/${appState.documentName}/${currentImage.filename}?t=${Date.now()}`;
            
            modalImage.onload = function() {
                loading.style.display = 'none';
                modalImage.style.opacity = '1';
                modalImage.classList.add('modal-image-transition');
                
                // Supprimer la classe d'animation apr√®s l'animation
                setTimeout(() => {
                    modalImage.classList.remove('modal-image-transition');
                }, 300);
            };
            
            modalImage.onerror = function() {
                loading.style.display = 'none';
                modalImage.style.opacity = '1';
                modalInfo.innerHTML = `<span class="text-danger">‚ùå Erreur de chargement de l'image</span>`;
            };
            
            modalImage.src = newImageSrc;
            
            // Mettre √† jour les informations
            const sectionInfo = currentImage.section !== 'Non attribu√©es' ? 
                `Section ${currentImage.sectionNumber}${currentImage.imageNumber ? ` - Image ${currentImage.imageNumber}` : ''}` : 
                currentImage.section;
                
            modalInfo.innerHTML = `
                <div class="d-flex justify-content-between align-items-center w-100">
                    <div>
                        <strong>Fichier:</strong> ${currentImage.filename}<br>
                        <strong>Section:</strong> ${sectionInfo}<br>
                        <strong>Page:</strong> ${currentImage.page}
                    </div>
                </div>
            `;
            
            logDebug(`Affichage image ${currentImageIndex + 1}/${currentImagesList.length}: ${currentImage.filename}`);
        }
        
        function navigateImage(direction) {
            if (currentImagesList.length === 0) return;
            
            const newIndex = currentImageIndex + direction;
            
            if (newIndex >= 0 && newIndex < currentImagesList.length) {
                currentImageIndex = newIndex;
                displayCurrentImage();
            }
        }
        
        function setupModalKeyboardNavigation() {
            const modalElement = document.getElementById('imageModal');
            
            modalElement.addEventListener('keydown', function(event) {
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        navigateImage(-1);
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        navigateImage(1);
                        break;
                    case 'Escape':
                        event.preventDefault();
                        imageModalInstance.hide();
                        break;
                    case 'Home':
                        event.preventDefault();
                        if (currentImagesList.length > 0) {
                            currentImageIndex = 0;
                            displayCurrentImage();
                        }
                        break;
                    case 'End':
                        event.preventDefault();
                        if (currentImagesList.length > 0) {
                            currentImageIndex = currentImagesList.length - 1;
                            displayCurrentImage();
                        }
                        break;
                }
            });
            
            // S'assurer que la modal peut recevoir le focus pour les √©v√©nements clavier
            modalElement.addEventListener('shown.bs.modal', function() {
                modalElement.focus();
            });
        }

        // Fonction pour √©diter l'image depuis la modal de preview
        function editCurrentModalImage() {
            if (currentImagesList.length > 0 && currentImageIndex >= 0 && currentImageIndex < currentImagesList.length) {
                const currentImage = currentImagesList[currentImageIndex];
                logInfo(`üé® Ouverture √©diteur depuis modal pour: ${currentImage.filename}`);
                
                // V√©rifier que l'√©diteur d'images est disponible
                if (typeof window.openImageEditor !== 'function') {
                    logError('√âditeur d\'images non disponible');
                    alert('L\'√©diteur d\'images n\'est pas encore charg√©. Veuillez r√©essayer dans quelques secondes.');
                    return;
                }
                
                // Fermer la modal de preview
                if (imageModalInstance) {
                    imageModalInstance.hide();
                }
                
                // Ouvrir l'√©diteur d'images
                setTimeout(() => {
                    window.openImageEditor(currentImage.filename, currentImage);
                }, 300); // D√©lai pour que la modal se ferme proprement
            } else {
                logError('Aucune image courante pour √©dition');
            }
        }

        // Fonction pour toggle les tips
        function toggleTips() {
            const content = document.getElementById('tipsContent');
            const chevron = document.getElementById('tipsChevron');
            
            content.classList.toggle('collapsed');
            chevron.classList.toggle('rotated');
        }
        
        // Variables globales pour le s√©lecteur de section
        let currentSectionSelector = null;
        
        // Variables globales pour la s√©lection multiple
        let selectedImages = new Set();
        
        // Variables pour le drag stack
        let dragStackContainer = null;
        let isDraggingMultiple = false;
        
        // Variables pour la navigation d'images dans la modal
        let currentImageIndex = 0;
        let currentImagesList = [];
        let imageModalInstance = null;
        
        // Syst√®me de logs pour le debug
        let appLogs = [];
        const MAX_LOGS = 100;
        
        function logDebug(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'debug',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] DEBUG:`, message, data || '');
        }
        
        function logInfo(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'info',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] INFO:`, message, data || '');
        }
        
        function logError(message, error = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'error',
                message: message,
                data: error ? error.toString() : null
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.error(`[${timestamp}] ERROR:`, message, error || '');
        }
        
        function showSectionSelector(imageFilename, event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Fermer le s√©lecteur existant s'il y en a un
            closeSectionSelector();
            
            // Cr√©er le s√©lecteur
            const selector = document.createElement('div');
            selector.className = 'section-selector';
            selector.innerHTML = generateSectionSelectorHTML(imageFilename);
            
            // Positionner le s√©lecteur pr√®s du bouton
            const rect = event.target.getBoundingClientRect();
            selector.style.left = (rect.left + window.scrollX + 60) + 'px';
            selector.style.top = (rect.top + window.scrollY - 150) + 'px';
            
            // Ajouter au document
            document.body.appendChild(selector);
            currentSectionSelector = selector;
            
            // Fermer le s√©lecteur si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeSectionSelectorOnClickOutside);
            }, 100);
        }
        
        function generateSectionSelectorHTML(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const selectedCount = selectedImages.size;
            const totalToMove = isImageSelected ? selectedCount : (selectedCount > 0 ? selectedCount + 1 : 1);
            
            let html = `
                <div class="section-selector-header">
                    <i class="fas fa-arrow-right me-2"></i>
                    ${totalToMove > 1 ? 
                        `Assigner ${totalToMove} images √† une section` : 
                        'Assigner √† une section'
                    }
                    ${totalToMove > 1 ? `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        ${isImageSelected ? 'Cette image + s√©lection' : 'Cette image + ' + selectedCount + ' s√©lectionn√©es'}
                    </div>` : ''}
                </div>
            `;
            
            // Ajouter toutes les sections disponibles
            appState.sections.forEach(section => {
                const level = section.level || 1;
                const sectionNumber = section.sectionNumber || section.number;
                const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
                const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
                const levelClass = level === 2 ? 'section-option-level-2' : level === 3 ? 'section-option-level-3' : '';
                
                html += `
                    <div class="section-option ${levelClass}" onclick="assignImageToSection('${imageFilename}', ${section.id})">
                        <span class="section-option-number">${levelIcon} ${nomenclatureNumber}</span>
                        <span class="section-option-label">Section ${sectionNumber}</span>
                    </div>
                `;
            });
            
            return html;
        }
        
        function assignImageToSection(imageFilename, targetSectionId) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMove = [];
            
            // Ajouter l'image cliqu√©e si elle n'est pas d√©j√† s√©lectionn√©e
            if (!isImageSelected) {
                imagesToMove.push(imageFilename);
            }
            
            // Ajouter toutes les images s√©lectionn√©es
            imagesToMove.push(...getSelectedImagesList());
            
            logInfo(`üìã D√©placement anim√© de ${imagesToMove.length} images vers ${targetSectionId === 'unassigned' ? 'les non attribu√©es' : 'section ' + targetSectionId}`);
            
            // D√©placer avec animation
            animateImagesMoveToSection(imagesToMove, targetSectionId);
        }
        
        function closeSectionSelector() {
            if (currentSectionSelector) {
                currentSectionSelector.remove();
                currentSectionSelector = null;
                document.removeEventListener('click', closeSectionSelectorOnClickOutside);
            }
        }
        
        function closeSectionSelectorOnClickOutside(event) {
            if (currentSectionSelector && !currentSectionSelector.contains(event.target)) {
                closeSectionSelector();
            }
        }
        
        // === ANIMATION DE D√âPLACEMENT D'IMAGES ===
        
        function animateImagesMoveToSection(imagesToMove, targetSectionId) {
            logInfo(`üé¨ D√©but animation pour ${imagesToMove.length} images`);
            
            // Fermer le s√©lecteur imm√©diatement
            closeSectionSelector();
            
            // Animer les images avec un d√©lai √©chelonn√© pour un effet cascade
            imagesToMove.forEach((filename, index) => {
                setTimeout(() => {
                    animateImageMove(filename, targetSectionId);
                }, index * 100); // 100ms de d√©lai entre chaque image
            });
            
            // Apr√®s la derni√®re animation, mettre √† jour l'interface
            const totalDelay = imagesToMove.length * 100 + 700; // 700ms = dur√©e de l'animation
            setTimeout(() => {
                finalizeMoveAfterAnimation(imagesToMove, targetSectionId);
            }, totalDelay);
        }
        
        function animateImageMove(imageFilename, targetSectionId) {
            const sourceCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
            if (!sourceCard) {
                logError(`Image source introuvable: ${imageFilename}`);
                return;
            }
            
            // Capturer la position initiale
            const sourceRect = sourceCard.getBoundingClientRect();
            const sourceImage = sourceCard.querySelector('.image-preview');
            
            // Calculer la position de destination
            const targetPos = calculateTargetPosition(targetSectionId);
            if (!targetPos) {
                logError(`Position cible introuvable pour section: ${targetSectionId}`);
                return;
            }
            
            // Cr√©er la copie anim√©e
            const animatedImage = createAnimatedImageCopy(sourceImage, sourceRect, imageFilename);
            
            // Masquer temporairement l'image source
            sourceCard.style.opacity = '0.3';
            sourceCard.style.transform = 'scale(0.95)';
            
            // D√©clencher l'animation apr√®s un petit d√©lai pour permettre le rendu
            setTimeout(() => {
                animatedImage.classList.add('animating');
                animatedImage.style.left = targetPos.x + 'px';
                animatedImage.style.top = targetPos.y + 'px';
                animatedImage.style.width = targetPos.width + 'px';
                animatedImage.style.height = targetPos.height + 'px';
            }, 50);
            
            // Nettoyer apr√®s l'animation
            setTimeout(() => {
                // Effet de fade out final
                animatedImage.classList.add('fade-out');
                setTimeout(() => {
                    if (animatedImage.parentNode) {
                        animatedImage.parentNode.removeChild(animatedImage);
                    }
                }, 300);
                
                // Restaurer l'opacit√© de l'image source
                sourceCard.style.opacity = '';
                sourceCard.style.transform = '';
            }, 700);
        }
        
        function createAnimatedImageCopy(sourceImage, sourceRect, imageFilename) {
            const animatedImage = document.createElement('div');
            animatedImage.className = 'image-slide-animation';
            
            // Positionner exactement sur l'image source
            animatedImage.style.left = sourceRect.left + 'px';
            animatedImage.style.top = sourceRect.top + 'px';
            animatedImage.style.width = sourceRect.width + 'px';
            animatedImage.style.height = sourceRect.height + 'px';
            
            // Copier l'image
            const img = document.createElement('img');
            img.src = sourceImage.src;
            img.alt = imageFilename;
            animatedImage.appendChild(img);
            
            // Ajouter au document
            document.body.appendChild(animatedImage);
            
            return animatedImage;
        }
        
        function calculateTargetPosition(targetSectionId) {
            let targetContainer;
            
            if (targetSectionId === 'unassigned') {
                targetContainer = document.getElementById('unassignedGrid');
            } else {
                targetContainer = document.querySelector(`[data-section-id="${targetSectionId}"] .images-grid`);
            }
            
            if (!targetContainer) {
                logError(`Container cible introuvable: ${targetSectionId}`);
                return null;
            }
            
            const targetRect = targetContainer.getBoundingClientRect();
            
            // Calculer la position exacte o√π l'image va appara√Ætre
            const existingImages = targetContainer.querySelectorAll('.image-card');
            const gridCols = Math.floor(targetContainer.offsetWidth / 232); // 200px + 32px gap/margin
            const nextImageIndex = existingImages.length;
            
            const row = Math.floor(nextImageIndex / gridCols);
            const col = nextImageIndex % gridCols;
            
            // Calculer position exacte dans la grille CSS
            const imageWidth = 200;
            const imageHeight = 220; // Hauteur standard d'une carte image
            const gap = 16; // 1rem = 16px
            const padding = 16; // Padding du container
            
            const x = targetRect.left + padding + col * (imageWidth + gap);
            const y = targetRect.top + padding + row * (imageHeight + gap);
            
            return {
                x: x,
                y: y,
                width: imageWidth,
                height: imageHeight
            };
        }
        
        function finalizeMoveAfterAnimation(imagesToMove, targetSectionId) {
            logInfo(`üé¨ Finalisation du d√©placement de ${imagesToMove.length} images`);
            
            // Effectuer le d√©placement r√©el dans les donn√©es
            if (targetSectionId === 'unassigned') {
                imagesToMove.forEach(filename => {
                    moveImageToSection(filename, targetSectionId);
                });
            } else {
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    moveImagesToSectionAtPosition(imagesToMove, targetSectionId, targetSection.images.length);
                }
            }
            
            // Nettoyer la s√©lection
            clearSelection();
            
            // Mettre √† jour l'interface
            renderSections();
            updateUnassignedImages();
            updateStats();
            
            logInfo(`‚úÖ ${imagesToMove.length} images d√©plac√©es avec animation termin√©e`);
        }
        
        // Fonctions de s√©lection multiple
        function toggleImageSelection(imageFilename, isSelected) {
            const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
            
            if (isSelected) {
                selectedImages.add(imageFilename);
                imageCard.classList.add('selected');
            } else {
                selectedImages.delete(imageFilename);
                imageCard.classList.remove('selected');
            }
            
            updateSelectionStats();
        }
        
        function toggleImageSelectionByClick(imageFilename) {
            try {
                const isCurrentlySelected = selectedImages.has(imageFilename);
                const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
                
                logDebug(`Toggle s√©lection - Image: ${imageFilename}, Actuellement s√©lectionn√©e: ${isCurrentlySelected}`);
                
                if (!imageCard) {
                    logError(`Element DOM introuvable pour l'image: ${imageFilename}`);
                    return;
                }
                
                // V√©rifier la section parente pour diagnostic
                const parentSection = imageCard.closest('[data-section-id]');
                const sectionId = parentSection ? parentSection.dataset.sectionId : 'inconnue';
                logDebug(`Image ${imageFilename} dans section ID: ${sectionId}`);
                
                if (isCurrentlySelected) {
                    selectedImages.delete(imageFilename);
                    imageCard.classList.remove('selected');
                    logDebug(`‚úÖ Image d√©s√©lectionn√©e: ${imageFilename}, Classes apr√®s: ${imageCard.className}`);
                } else {
                    selectedImages.add(imageFilename);
                    imageCard.classList.add('selected');
                    logDebug(`‚úÖ Image s√©lectionn√©e: ${imageFilename}, Classes apr√®s: ${imageCard.className}`);
                    
                    // V√©rifier que la classe a bien √©t√© ajout√©e
                    setTimeout(() => {
                        const hasSelectedClass = imageCard.classList.contains('selected');
                        logDebug(`V√©rification retard√©e - Classe 'selected' pr√©sente: ${hasSelectedClass}`);
                        if (!hasSelectedClass) {
                            logError(`‚ùå La classe 'selected' n'a pas √©t√© appliqu√©e √† ${imageFilename}`);
                        }
                    }, 100);
                }
                
                updateSelectionStats();
            } catch (error) {
                logError(`Erreur lors de la s√©lection de l'image ${imageFilename}:`, error);
            }
        }
        
        function updateSelectionStats() {
            document.getElementById('selectedCount').textContent = selectedImages.size;
        }
        
        function clearSelection() {
            const count = selectedImages.size;
            selectedImages.forEach(filename => {
                const imageCard = document.querySelector(`[data-image-filename="${filename}"]`);
                if (imageCard) imageCard.classList.remove('selected');
            });
            selectedImages.clear();
            updateSelectionStats();
            logDebug(`S√©lection vid√©e - ${count} images d√©s√©lectionn√©es`);
        }
        
        function getSelectedImagesList() {
            // Retourner les images s√©lectionn√©es dans l'ordre d'apparition dans l'interface
            const allImages = document.querySelectorAll('.image-card');
            const orderedSelectedImages = [];
            
            allImages.forEach(card => {
                const filename = card.dataset.imageFilename;
                if (selectedImages.has(filename)) {
                    orderedSelectedImages.push(filename);
                }
            });
            
            return orderedSelectedImages;
        }
        
        function getSelectedImagesInSourceOrder() {
            // Retourner les images s√©lectionn√©es dans l'ordre qu'elles avaient dans leurs sections d'origine
            const orderedSelectedImages = [];
            
            // D'abord, chercher dans les images non attribu√©es
            appState.unassignedImages.forEach(image => {
                if (selectedImages.has(image.filename)) {
                    orderedSelectedImages.push(image.filename);
                }
            });
            
            // Ensuite, parcourir toutes les sections dans l'ordre hi√©rarchique
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    if (selectedImages.has(image.filename)) {
                        orderedSelectedImages.push(image.filename);
                    }
                });
            });
            
            return orderedSelectedImages;
        }
        
        function toggleSelectAll() {
            try {
                const allImageCards = document.querySelectorAll('.image-card');
                logDebug(`Toggle select all - ${allImageCards.length} images trouv√©es, ${selectedImages.size} s√©lectionn√©es`);
                
                // V√©rifier combien d'images actuellement visibles sont s√©lectionn√©es
                let visibleSelectedCount = 0;
                allImageCards.forEach(card => {
                    const filename = card.dataset.imageFilename;
                    if (selectedImages.has(filename)) {
                        visibleSelectedCount++;
                    }
                });
                
                const allVisibleSelected = (allImageCards.length > 0 && visibleSelectedCount === allImageCards.length);
                logDebug(`Images visibles s√©lectionn√©es: ${visibleSelectedCount}/${allImageCards.length}, tout s√©lectionn√©: ${allVisibleSelected}`);
                
                if (allVisibleSelected) {
                    // Tout d√©s√©lectionner
                    logDebug('D√©s√©lection de toutes les images');
                    clearSelection();
                    document.getElementById('selectAllText').textContent = 'Tout s√©lectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-check-square';
                } else {
                    // Tout s√©lectionner
                    logDebug('S√©lection de toutes les images visibles');
                    allImageCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (!selectedImages.has(filename)) {
                            selectedImages.add(filename);
                            card.classList.add('selected');
                        }
                    });
                    updateSelectionStats();
                    document.getElementById('selectAllText').textContent = 'Tout d√©s√©lectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-square';
                }
            } catch (error) {
                logError('Erreur dans toggleSelectAll:', error);
            }
        }
        
        // Fonctions pour le drag stack
        function createDragStack(imageFilename, mousePosX, mousePosY) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToShow = [];
            
            // Ajouter l'image principale si elle n'est pas s√©lectionn√©e
            if (!isImageSelected) {
                imagesToShow.push(imageFilename);
            }
            
            // Ajouter les images s√©lectionn√©es (max 4 pour l'affichage)
            const selectedList = getSelectedImagesList();
            imagesToShow.push(...selectedList.slice(0, 4));
            
            if (imagesToShow.length <= 1) return;
            
            // Cr√©er le container
            dragStackContainer = document.createElement('div');
            dragStackContainer.className = 'drag-stack-container';
            dragStackContainer.style.left = (mousePosX - 75) + 'px';
            dragStackContainer.style.top = (mousePosY - 50) + 'px';
            
            // Cr√©er les images empil√©es (maximum 3 visibles + compteur)
            imagesToShow.slice(0, 3).forEach((filename, index) => {
                const stackImage = document.createElement('div');
                stackImage.className = `drag-stack-image stack-${index + 1}`;
                
                const img = document.createElement('img');
                img.src = `/image/${appState.documentName}/${filename}`;
                img.onerror = () => img.style.display = 'none';
                
                stackImage.appendChild(img);
                dragStackContainer.appendChild(stackImage);
            });
            
            // Ajouter le compteur si plus de 3 images
            if (imagesToShow.length > 1) {
                const counter = document.createElement('div');
                counter.className = 'drag-stack-counter';
                counter.textContent = imagesToShow.length;
                dragStackContainer.appendChild(counter);
            }
            
            document.body.appendChild(dragStackContainer);
            isDraggingMultiple = true;
        }
        
        function updateDragStackPosition(mousePosX, mousePosY) {
            if (dragStackContainer) {
                dragStackContainer.style.left = (mousePosX - 75) + 'px';
                dragStackContainer.style.top = (mousePosY - 50) + 'px';
            }
        }
        
        function removeDragStack() {
            if (dragStackContainer) {
                dragStackContainer.remove();
                dragStackContainer = null;
                isDraggingMultiple = false;
            }
        }
        
        function markImagesAsBeingDragged(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMark = [];
            
            if (!isImageSelected) {
                imagesToMark.push(imageFilename);
            }
            imagesToMark.push(...getSelectedImagesList());
            
            imagesToMark.forEach(filename => {
                const card = document.querySelector(`[data-image-filename="${filename}"]`);
                if (card) {
                    card.classList.add('being-dragged');
                }
            });
        }
        
        function unmarkImagesAsBeingDragged() {
            document.querySelectorAll('.being-dragged').forEach(card => {
                card.classList.remove('being-dragged');
            });
        }
        
        function setupDragStackMouseTracking() {
            // Utiliser un tracking global de souris pour SortableJS
            let isTrackingMouse = false;
            
            document.addEventListener('mousedown', function(e) {
                if (e.target.closest('.image-card')) {
                    isTrackingMouse = true;
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDraggingMultiple && dragStackContainer && isTrackingMouse) {
                    updateDragStackPosition(e.clientX, e.clientY);
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                isTrackingMouse = false;
            });
        }
        
        function exportImages() {
            // G√©n√©rer la configuration d'export
            const exportConfig = {
                prefix: appState.prefix,
                documentName: appState.documentName,
                format: appState.format,
                sections: appState.sections.map(section => ({
                    number: section.nomenclatureNumber || section.sectionNumber || section.number,
                    displayNumber: section.sectionNumber || section.number,
                    name: section.name,
                    level: section.level || 1,
                    images: section.images.map((image, index) => ({
                        originalFilename: image.filename,
                        newFilename: generateFilename(section.nomenclatureNumber || section.sectionNumber || section.number, index + 1),
                        page: image.page
                    }))
                }))
            };
            
            // Envoyer la configuration au serveur pour g√©n√©rer le ZIP
            fetch('/export-custom', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportConfig)
            })
            .then(response => response.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `${appState.documentName}_custom.zip`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Erreur lors de l\'export:', error);
                alert('Erreur lors de l\'export. Veuillez r√©essayer.');
            });
        }

    </script>

    <!-- Include Image Editor Modal -->
    {% include 'partials/image-editor-modal.html' %}

    <!-- Image Editor Scripts -->
    <script src="{{ url_for('static', filename='js/image-editor.js') }}"></script>
</body>
</html> 