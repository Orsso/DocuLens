<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocuLens - Éditeur de Sections</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-blue: #1e3a8a;
            --dark-blue: #1e293b;
            --glass-bg: rgba(30, 58, 138, 0.1);
            --glass-border: rgba(59, 130, 246, 0.2);
            --glass-shadow: rgba(0, 0, 0, 0.3);
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --accent-blue: #3b82f6;
            --success-green: #10b981;
            --warning-orange: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #1e3a8a 100%);
            background-attachment: fixed;
            background-size: 100% 100%;
            min-height: 100vh;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-primary);
            overflow-x: hidden;
            overscroll-behavior: none;
        }
        
        html {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #1e3a8a 100%);
            background-attachment: fixed;
            overscroll-behavior: none;
        }

        /* Glassmorphism Effects */
        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px var(--glass-shadow);
        }

        .glass-card {
            background: rgba(30, 58, 138, 0.15);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
            border-color: rgba(59, 130, 246, 0.5);
        }



        /* Configuration Panel */
        .config-panel {
            position: sticky;
            top: 20px;
            z-index: 100;
        }

        .config-form {
            display: grid;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-control {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary) !important;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            background: rgba(15, 23, 42, 0.8);
            color: var(--text-primary) !important;
        }
        
        .form-control::placeholder {
            color: rgba(203, 213, 225, 0.5) !important;
        }
        
        .form-control:disabled {
            background: rgba(15, 23, 42, 0.3) !important;
            border-color: rgba(59, 130, 246, 0.1) !important;
            color: var(--text-secondary) !important;
            cursor: not-allowed !important;
        }
        
        .form-control option {
            background: var(--dark-blue);
            color: var(--text-primary);
        }

        .btn-glass {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.8), rgba(29, 78, 216, 0.8));
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            color: white;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-glass:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
            text-decoration: none;
            color: white;
        }

        /* Sections Management */
        .sections-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Section grouping structure */
        .section-group-wrapper {
            margin-bottom: 2rem;
        }

        .section-editor {
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* Main sections */
        .main-section {
            border-left: 4px solid var(--accent-blue);
        }
        
        /* Main sections with subsections - larger container */
        .main-section-with-subs {
            border-left: 4px solid var(--accent-blue);
            background: rgba(59, 130, 246, 0.02);
            border: 1px solid rgba(59, 130, 246, 0.15);
        }
        
        /* Subsections container inside main section */
        .main-section-with-subs .subsections-container {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(59, 130, 246, 0.03);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            position: relative;
        }
        
        .main-section-with-subs .subsections-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.6), transparent);
            border-radius: 4px 4px 0 0;
        }
        
        /* Sub-sections */
        .sub-section {
            border-left: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.05);
            margin-bottom: 1rem;
        }
        
        .sub-section:last-child {
            margin-bottom: 0;
        }
        
        /* Sub-sub-sections */
        .sub-sub-section {
            border-left: 2px solid #f59e0b;
            background: rgba(245, 158, 11, 0.05);
            margin-bottom: 0.75rem;
        }
        
        .sub-sub-sections-container {
            margin-left: 1rem;
            margin-top: 0.75rem;
            padding-left: 1rem;
            border-left: 2px solid rgba(245, 158, 11, 0.3);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        .section-number {
            background: linear-gradient(135deg, var(--accent-blue), #1d4ed8);
            color: white;
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-weight: 700;
            min-width: 80px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .section-number:hover {
            background: linear-gradient(135deg, #60a5fa, var(--accent-blue));
            transform: scale(1.02);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
        }
        
        .section-number:active {
            cursor: grabbing;
        }
        
        .section-number i {
            margin-right: 0.5rem;
            font-size: 0.9rem;
        }
        
        .section-number-text {
            font-weight: inherit;
        }
        
        .nomenclature-badge {
            display: inline-block;
            background: rgba(16, 185, 129, 0.8);
            color: white;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            font-weight: 500;
        }



        .section-controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .btn-add {
            background: linear-gradient(135deg, var(--success-green), #059669);
            color: white;
        }

        .btn-add-sub {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }

        .btn-delete {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        /* Images Grid */
        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            min-height: 100px;
            border: 2px dashed rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .images-grid.dragover {
            border-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .image-card {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .image-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
        }

        .image-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 5;
        }

        .image-card:hover .image-overlay {
            opacity: 1;
            pointer-events: none; /* L'overlay ne doit pas capturer les événements */
        }

        .image-card:hover .btn-assign {
            pointer-events: all; /* Seul le bouton capture les événements */
        }

        .btn-zoom {
            position: absolute;
            top: 8px;
            left: 8px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(29, 78, 216, 0.9));
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            backdrop-filter: blur(8px);
            z-index: 10;
            pointer-events: all;
        }

        .btn-zoom:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.6);
            background: linear-gradient(135deg, #60a5fa, var(--accent-blue));
        }

        .image-card.selected {
            border: 2px solid var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            transform: scale(1.02);
        }

        .image-card.selected .image-preview {
            opacity: 0.8;
        }

        /* Animation pour déplacement - masquer l'original */
        .image-card.being-dragged {
            opacity: 0.3;
            transform: scale(0.8);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .image-card.selected.being-dragged {
            opacity: 0.2;
            transform: scale(0.7);
        }

        /* Stack fantôme pour drag multiple */
        .drag-stack-container {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: none;
        }

        .drag-stack-image {
            position: absolute;
            width: 150px;
            height: 100px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-blue);
            transition: all 0.1s ease;
        }

        .drag-stack-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .drag-stack-image.stack-1 {
            transform: rotate(-2deg) translate(-5px, 5px);
            z-index: 10001;
        }

        .drag-stack-image.stack-2 {
            transform: rotate(1deg) translate(5px, 10px);
            z-index: 10002;
        }

        .drag-stack-image.stack-3 {
            transform: rotate(-1deg) translate(-3px, 15px);
            z-index: 10003;
        }

        .drag-stack-counter {
            position: absolute;
            top: -15px;
            right: -15px;
            background: var(--accent-blue);
            color: white;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.6);
            z-index: 10004;
        }

        .btn-assign {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, var(--accent-blue), #1d4ed8);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            backdrop-filter: blur(8px);
            z-index: 10;
            pointer-events: all;
        }

        .btn-assign:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.6);
            background: linear-gradient(135deg, #60a5fa, var(--accent-blue));
        }



        .image-preview {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }

        .image-info {
            padding: 0.75rem;
            background: rgba(15, 23, 42, 0.8);
        }

        .image-filename {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            word-break: break-word;
        }

        .image-page {
            font-size: 0.7rem;
            color: var(--accent-blue);
            font-weight: 600;
        }

        /* Stats Panel */
        .stats-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            text-align: center;
        }

        .stat-item {
            padding: 0.75rem;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-blue);
            display: block;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Modal Styles */
        .modal-content {
            background: var(--dark-blue);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(20px);
        }

        .modal-header, .modal-footer {
            border-color: rgba(59, 130, 246, 0.2);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .section-title {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            
            .images-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
            
            .stats-panel {
                position: relative;
                bottom: auto;
                right: auto;
                margin-top: 2rem;
            }
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-editor {
            animation: fadeInUp 0.5s ease-out;
        }

        /* Tooltips */
        [data-bs-toggle="tooltip"] {
            cursor: help;
        }
        
        /* Tips Box */
        .tips-box {
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            margin-top: 1rem;
            overflow: hidden;
            backdrop-filter: blur(16px);
        }
        
        .tips-header {
            background: rgba(59, 130, 246, 0.15);
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .tips-header:hover {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .tips-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .tips-title i {
            color: #fbbf24;
            font-size: 1rem;
        }
        
        .tips-title span {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .tips-chevron {
            color: var(--text-secondary);
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }
        
        .tips-chevron.rotated {
            transform: rotate(180deg);
        }
        
        .tips-content {
            padding: 0.75rem 1rem;
            max-height: 500px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .tips-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .tip-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .tip-item:last-child {
            margin-bottom: 0;
        }
        
        .tip-item i {
            color: var(--accent-blue);
            font-size: 0.9rem;
            margin-top: 0.1rem;
            min-width: 1rem;
        }
        
        .tip-item span {
            color: var(--text-secondary);
        }
        
        /* Section Selector */
        .section-selector {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1rem;
            max-height: 350px;
            overflow-y: auto;
            z-index: 1000;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .section-selector-header {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .section-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.2rem;
            font-size: 0.9rem;
            position: relative;
        }
        
        .section-option:hover {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .section-option:last-child {
            margin-bottom: 0;
        }
        
        .section-option-number {
            font-weight: 600;
            color: var(--accent-blue);
            min-width: 60px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-option-number i {
            font-size: 0.85rem;
            width: 1rem;
            text-align: center;
        }
        
        .section-option-label {
            color: var(--text-primary);
        }
        
        .section-option-level-2 {
            margin-left: 1.5rem;
            position: relative;
        }
        
        .section-option-level-2::before {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: 50%;
            width: 0.75rem;
            height: 1px;
            background: #8b5cf6;
            border-top: 1px solid #8b5cf6;
        }
        
        .section-option-level-2::after {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: -0.5rem;
            bottom: 50%;
            width: 1px;
            background: #8b5cf6;
        }
        
        /* Ligne verticale pour connecter les sous-sections */
        .section-option-level-2:not(:last-child)::after {
            bottom: -0.5rem;
        }
        
        .section-option-level-3 {
            margin-left: 3rem;
            position: relative;
        }
        
        .section-option-level-3::before {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: 50%;
            width: 0.75rem;
            height: 1px;
            background: #f59e0b;
            border-top: 1px solid #f59e0b;
        }
        
        .section-option-level-3::after {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: -0.5rem;
            bottom: 50%;
            width: 1px;
            background: #f59e0b;
        }
        
        /* Ligne verticale pour connecter les sous-sous-sections */
        .section-option-level-3:not(:last-child)::after {
            bottom: -0.5rem;
        }
        
        /* Zone Images Non Attribuées */
        .unassigned-container {
            margin-bottom: 2rem;
        }
        
        .unassigned-card {
            border-left: 4px solid #f59e0b;
            background: rgba(245, 158, 11, 0.05);
        }
        
        .unassigned-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(245, 158, 11, 0.2);
        }
        
        .unassigned-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .unassigned-title i {
            color: #f59e0b;
            font-size: 1.2rem;
        }
        
        .unassigned-badge {
            background: #f59e0b;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 700;
            min-width: 30px;
            text-align: center;
        }

        /* Bouton Debug Flottant */
        .debug-button {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 22px;
            height: 22px;
            background: rgba(245, 158, 11, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 999;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.3);
        }

        .debug-button:hover {
            background: rgba(245, 158, 11, 1);
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(245, 158, 11, 0.5);
        }

        /* Modal Debug */
        .debug-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .debug-modal-content {
            background: var(--dark-blue);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 16px;
            max-width: 800px;
            max-height: 80vh;
            width: 100%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .debug-modal-header {
            background: rgba(245, 158, 11, 0.15);
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(245, 158, 11, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .debug-modal-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .debug-modal-title i {
            color: #f59e0b;
            font-size: 1.2rem;
        }

        .debug-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .debug-modal-close:hover {
            color: var(--text-primary);
            background: rgba(245, 158, 11, 0.2);
        }

        .debug-modal-body {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .debug-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(245, 158, 11, 0.05);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 8px;
        }

        .debug-section-title {
            font-size: 1rem;
            font-weight: 600;
            color: #f59e0b;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .debug-info {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .debug-info.error {
            color: #ef4444;
        }

        .debug-info.success {
            color: #10b981;
        }

        .debug-info.warning {
            color: #f59e0b;
        }

    </style>
</head>
<body>
    <div class="container-fluid px-4 py-3">


        <div class="row">
            <!-- Configuration Panel -->
            <div class="col-lg-3">
                <div class="config-panel">
                    <div class="glass-card">
                        <h5 class="mb-3"><i class="fas fa-cog me-2"></i>Configuration</h5>
                        
                        <div class="config-form">
                            <div class="form-group">
                                <label class="form-label">Préfixe</label>
                                <input type="text" id="prefixInput" class="form-control" value="CLR" placeholder="CLR">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Nom du Document</label>
                                <input type="text" id="documentNameInput" class="form-control" value="{{ result.document_name }}" placeholder="Nom du document">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Format</label>
                                <select id="formatSelect" class="form-control">
                                    <option value="jpg">JPEG (.jpg)</option>
                                    <option value="png">PNG (.png)</option>
                                </select>
                            </div>
                        </div>
                        
                        <hr style="border-color: rgba(59, 130, 246, 0.2); margin: 1.5rem 0;">
                        
                        <div class="d-grid gap-2">
                            <button class="btn-glass" onclick="addNewSection()">
                                <i class="fas fa-plus"></i>
                                Ajouter Section
                            </button>
                            
                            <button class="btn-glass" onclick="toggleSelectAll()" id="selectAllBtn">
                                <i class="fas fa-check-square"></i>
                                <span id="selectAllText">Tout sélectionner</span>
                            </button>
                            
                            <button class="btn-glass" onclick="exportImages()">
                                <i class="fas fa-download"></i>
                                Exporter ZIP
                            </button>
                            
                            <a href="/" class="btn-glass text-center">
                                <i class="fas fa-arrow-left"></i>
                                Retour
                            </a>
                        </div>
                    </div>
                    
                    <!-- Tips Box - Rétractable -->
                    <div class="tips-box">
                        <div class="tips-header" onclick="toggleTips()">
                            <div class="tips-title">
                                <i class="fas fa-lightbulb"></i>
                                <span>Conseils d'utilisation</span>
                            </div>
                            <i class="fas fa-chevron-down tips-chevron" id="tipsChevron"></i>
                        </div>
                        <div class="tips-content" id="tipsContent">
                            <div class="tip-item">
                                <i class="fas fa-plus-circle"></i>
                                <span>Utilisez le bouton violet sur une section pour créer une sous-section</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-edit"></i>
                                <span>Cliquez sur la boîte bleue du numéro pour modifier la nomenclature (ex: ANNEXE-A)</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-arrows-alt"></i>
                                <span>Glissez-déposez les sections par leur boîte bleue pour les réorganiser</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sections Editor -->
            <div class="col-lg-9">
                <!-- Zone Images Non Attribuées -->
                <div id="unassignedImagesContainer" class="unassigned-container" style="display: none;">
                    <div class="glass-card unassigned-card">
                        <div class="unassigned-header">
                            <div class="unassigned-title">
                                <i class="fas fa-inbox"></i>
                                <span>Images non attribuées</span>
                                <span id="unassignedBadge" class="unassigned-badge">0</span>
                            </div>
                        </div>
                        <div class="images-grid" id="unassignedGrid" data-section-id="unassigned">
                            <!-- Images non attribuées -->
                        </div>
                    </div>
                </div>
                
                <div id="sectionsContainer" class="sections-container">
                    <!-- Les sections seront générées par JavaScript -->
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="empty-state" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <h4>Aucune section créée</h4>
                    <p>Cliquez sur "Ajouter Section" pour commencer</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <div class="glass-card">
            <div class="stats-grid">
                <div class="stat-item">
                    <span id="sectionsCount" class="stat-number">0</span>
                    <span class="stat-label">Sections</span>
                </div>
                <div class="stat-item">
                    <span id="imagesCount" class="stat-number">{{ result.total_images }}</span>
                    <span class="stat-label">Images</span>
                </div>
                <div class="stat-item">
                    <span id="selectedCount" class="stat-number">0</span>
                    <span class="stat-label">Sélectionnées</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div class="modal fade" id="imageModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title text-white">Aperçu de l'image</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body text-center">
                    <img id="modalImage" src="" class="img-fluid rounded" style="max-height: 70vh;">
                </div>
                <div class="modal-footer">
                    <div id="modalImageInfo" class="text-white"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Button -->
    <div class="debug-button" onclick="showDebugModal()" title="Diagnostic du système">
        <i class="fas fa-bug"></i>
    </div>

    <!-- Debug Modal -->
    <div class="debug-modal" id="debugModal">
        <div class="debug-modal-content">
            <div class="debug-modal-header">
                <div class="debug-modal-title">
                    <i class="fas fa-bug"></i>
                    <span>Diagnostic du Système</span>
                </div>
                <button class="debug-modal-close" onclick="closeDebugModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="debug-modal-body" id="debugModalBody">
                <!-- Le contenu de debug sera inséré ici -->
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <script type="application/json" id="sectionsData">{{ result.sections | tojson | safe }}</script>
    <script type="application/json" id="imagesData">{{ result.extracted_files | tojson | safe }}</script>
    
    <script>
        // État global de l'application
        let appState = {
            sections: [],
            unassignedImages: [],
            prefix: 'CLR',
            documentName: '{{ result.document_name }}',
            format: 'jpg',
            nextSectionId: 1,
            maxSubsectionId: {}  // Stocke le prochain ID de sous-section pour chaque section
        };

        // Images extraites du serveur
        let extractedImages = [];
        
        // Sections détectées par le serveur
        let detectedSections = JSON.parse(document.getElementById('sectionsData').textContent);
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            logInfo('🚀 Initialisation de DocuLens v2');
            setupEventListeners();
            loadImagesFromServer();
            lockDocumentNameAfterProcessing();
            setupDragStackMouseTracking();
            
            // Nettoyer les tooltips au chargement pour éviter les résidus
            setTimeout(() => {
                cleanupTooltips();
                logInfo('✅ Initialisation terminée');
            }, 1000);
        });

        function initializeApp() {
            // Debug : afficher toutes les images extraites
            console.log('🖼️ Images extraites du serveur:', extractedImages.length);
            extractedImages.forEach((img, i) => {
                console.log(`  ${i+1}. ${img.filename} - Section: "${img.section}" - Page: ${img.page}`);
            });
            
            // Créer les sections basées sur la détection automatique
            if (detectedSections && detectedSections.length > 0) {
                console.log('🔍 Sections détectées:', detectedSections.length);
                detectedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. Section "${section.number}" (niveau ${section.level || 1}) - Titre: "${section.title}"`);
                });
                
                // Trier les sections détectées par ordre hiérarchique
                const sortedSections = [...detectedSections].sort((a, b) => {
                    return compareVersions(a.number, b.number);
                });
                
                console.log('📋 Ordre de création des sections:');
                sortedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. ${section.number} (niveau ${section.level || 1})`);
                });
                
                // Créer les sections selon l'ordre hiérarchique
                sortedSections.forEach((detectedSection, index) => {
                    const sectionName = detectedSection.title || `Section ${detectedSection.number}`;
                    const level = detectedSection.level || 1;
                    
                    // Déterminer si c'est une sous-section et trouver le parent
                    let parentSectionId = null;
                    
                    if (level > 1 && detectedSection.number.includes('.')) {
                        const parentNumber = detectedSection.number.split('.')[0];
                        const parentSection = appState.sections.find(s => 
                            s.sectionNumber == parentNumber || s.nomenclatureNumber == parentNumber
                        );
                        if (parentSection) {
                            parentSectionId = parentSection.id;
                            console.log(`  🔗 Section ${detectedSection.number} rattachée au parent ${parentNumber} (ID: ${parentSectionId})`);
                        } else {
                            console.warn(`  ⚠️  Parent ${parentNumber} non trouvé pour section ${detectedSection.number}`);
                        }
                    }
                    
                    const createdSection = addNewSection(sectionName, parentSectionId);
                    
                    if (createdSection) {
                        // Assigner les images de cette section
                        const sectionImages = extractedImages.filter(img => 
                            img.section === detectedSection.number.toString()
                        );
                        
                        createdSection.images = sectionImages;
                        createdSection.sectionNumber = detectedSection.number;
                        createdSection.nomenclatureNumber = detectedSection.number; // Par défaut, même que le numéro de section
                        createdSection.level = level;
                        createdSection.isCustomNomenclature = false; // Détection automatique, pas personnalisée
                        console.log(`  📁 Section ${detectedSection.number}: ${sectionImages.length} images (niveau ${level})`);
                    }
                });
                
                // Forcer la renumération finale et le rendu
                console.log('🔢 Renumération finale...');
                renumberSections(false); // Ne pas écraser les nomenclatures personnalisées
                renderSections();
                updateUnassignedImages();
                debugImageAssignment();
            } else {
                // Fallback : créer une section par défaut
                console.log('⚠️  Aucune section détectée, création d\'une section par défaut');
                if (extractedImages.length > 0) {
                    addNewSection('Section 1');
                    appState.sections[0].images = [...extractedImages];
                    renderSections();
                    updateUnassignedImages();
                }
            }
            updateStats();
        }
        
        function debugImageAssignment() {
            console.log('🔍 DEBUG - État après initialisation:');
            console.log(`  Total images extraites: ${extractedImages.length}`);
            
            let debugInfo = {
                totalExtracted: extractedImages.length,
                sections: [],
                totalAssigned: 0,
                unassigned: appState.unassignedImages.length,
                problems: []
            };
            
            // Analyser chaque section
            appState.sections.forEach(section => {
                const sectionInfo = {
                    number: section.sectionNumber,
                    nomenclature: section.nomenclatureNumber,
                    level: section.level,
                    imageCount: section.images.length,
                    images: section.images.map(img => img.filename)
                };
                debugInfo.sections.push(sectionInfo);
                debugInfo.totalAssigned += section.images.length;
                console.log(`  Section ${section.sectionNumber}: ${section.images.length} images`);
            });
            
            console.log(`  Images assignées total: ${debugInfo.totalAssigned}`);
            console.log(`  Images non attribuées: ${debugInfo.unassigned}`);
            console.log(`  Différence: ${debugInfo.totalExtracted - debugInfo.totalAssigned - debugInfo.unassigned}`);
            
            // Vérifier les problèmes
            if (debugInfo.totalExtracted !== debugInfo.totalAssigned + debugInfo.unassigned) {
                console.error('❌ PROBLÈME: Des images sont perdues!');
                
                // Trouver les images perdues
                const assignedFilenames = new Set();
                appState.sections.forEach(section => {
                    section.images.forEach(img => assignedFilenames.add(img.filename));
                });
                appState.unassignedImages.forEach(img => assignedFilenames.add(img.filename));
                
                const lostImages = extractedImages.filter(img => !assignedFilenames.has(img.filename));
                debugInfo.problems.push({
                    type: 'error',
                    message: 'Images perdues détectées',
                    details: lostImages
                });
                console.error('Images perdues:', lostImages);
            }
            
            return debugInfo;
        }
        
        function showDebugModal() {
            const debugData = debugImageAssignment();
            const modalBody = document.getElementById('debugModalBody');
            
            let html = `
                <div class="debug-section">
                    <div class="debug-section-title">
                        <i class="fas fa-chart-bar"></i>
                        Résumé Global
                    </div>
                    <div class="debug-info">Total images extraites: <strong>${debugData.totalExtracted}</strong></div>
                    <div class="debug-info">Images assignées: <strong>${debugData.totalAssigned}</strong></div>
                    <div class="debug-info">Images non attribuées: <strong>${debugData.unassigned}</strong></div>
                    <div class="debug-info ${debugData.totalExtracted === debugData.totalAssigned + debugData.unassigned ? 'success' : 'error'}">
                        État: ${debugData.totalExtracted === debugData.totalAssigned + debugData.unassigned ? '✅ Toutes les images sont comptabilisées' : '❌ Des images sont perdues!'}
                    </div>
                </div>
                
                <div class="debug-section">
                    <div class="debug-section-title">
                        <i class="fas fa-list"></i>
                        Sections Détectées (${debugData.sections.length})
                    </div>
            `;
            
            debugData.sections.forEach(section => {
                const levelIcon = section.level === 1 ? '<i class="fas fa-book"></i>' : section.level === 2 ? '<i class="fas fa-file-alt"></i>' : '<i class="fas fa-sticky-note"></i>';
                const indent = '&nbsp;&nbsp;'.repeat((section.level - 1) * 2);
                html += `
                    <div class="debug-info">
                        ${indent}${levelIcon} Section ${section.number} 
                        ${section.nomenclature !== section.number ? `(→ ${section.nomenclature})` : ''}
                        - <strong>${section.imageCount} images</strong>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Ajouter les images non attribuées si il y en a
            if (debugData.unassigned > 0) {
                html += `
                    <div class="debug-section">
                        <div class="debug-section-title">
                            <i class="fas fa-inbox"></i>
                            Images Non Attribuées (${debugData.unassigned})
                        </div>
                `;
                appState.unassignedImages.forEach(img => {
                    html += `<div class="debug-info">📄 ${img.filename} (Page ${img.page})</div>`;
                });
                html += '</div>';
            }
            
            // Ajouter les problèmes s'il y en a
            if (debugData.problems.length > 0) {
                html += `
                    <div class="debug-section">
                        <div class="debug-section-title">
                            <i class="fas fa-exclamation-triangle"></i>
                            Problèmes Détectés
                        </div>
                `;
                debugData.problems.forEach(problem => {
                    html += `<div class="debug-info ${problem.type}">${problem.message}</div>`;
                    if (problem.details && problem.details.length > 0) {
                        problem.details.forEach(detail => {
                            html += `<div class="debug-info">&nbsp;&nbsp;• ${typeof detail === 'string' ? detail : detail.filename}</div>`;
                        });
                    }
                });
                html += '</div>';
            }
            
            // Ajouter la section des logs récents
            html += `
                <div class="debug-section">
                    <div class="debug-section-title">
                        <i class="fas fa-list-ul"></i>
                        Logs Récents (${appLogs.length} entrées)
                                                 <button class="debug-clear-logs" onclick="clearLogs()" style="margin-left: 1rem; background: rgba(239, 68, 68, 0.8); border: none; border-radius: 4px; padding: 0.25rem 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                             <i class="fas fa-trash"></i> Vider
                         </button>
                         <button class="debug-diagnose" onclick="diagnoseSelectionIssue()" style="margin-left: 0.5rem; background: rgba(59, 130, 246, 0.8); border: none; border-radius: 4px; padding: 0.25rem 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                             <i class="fas fa-stethoscope"></i> Diagnostiquer
                         </button>
                         <button class="debug-sync" onclick="syncSelectionStateWithDOM()" style="margin-left: 0.5rem; background: rgba(16, 185, 129, 0.8); border: none; border-radius: 4px; padding: 0.25rem 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                             <i class="fas fa-sync-alt"></i> Sync DOM
                         </button>
                    </div>
                    <div class="debug-logs-container" style="max-height: 200px; overflow-y: auto; background: rgba(15, 23, 42, 0.5); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 6px; padding: 0.75rem; margin-top: 0.5rem;">
            `;
            
            if (appLogs.length === 0) {
                html += `<div class="debug-info" style="font-style: italic; opacity: 0.7;">Aucun log disponible</div>`;
            } else {
                appLogs.slice(0, 20).forEach(log => {
                    const iconClass = log.type === 'error' ? 'fas fa-exclamation-circle' : 
                                     log.type === 'info' ? 'fas fa-info-circle' : 'fas fa-bug';
                    const typeClass = log.type === 'error' ? 'error' : log.type === 'info' ? 'success' : '';
                    
                    html += `
                        <div class="debug-info ${typeClass}" style="margin-bottom: 0.5rem; padding: 0.25rem; border-left: 2px solid ${log.type === 'error' ? '#ef4444' : log.type === 'info' ? '#10b981' : '#f59e0b'};">
                            <span style="color: var(--text-secondary); font-size: 0.8rem;">[${log.time}]</span>
                            <i class="${iconClass}" style="margin: 0 0.5rem; color: ${log.type === 'error' ? '#ef4444' : log.type === 'info' ? '#10b981' : '#f59e0b'};"></i>
                            ${log.message}
                            ${log.data ? `<br><span style="margin-left: 2rem; opacity: 0.8; font-size: 0.9em;">${log.data}</span>` : ''}
                        </div>
                    `;
                });
                
                if (appLogs.length > 20) {
                    html += `<div class="debug-info" style="font-style: italic; opacity: 0.7; text-align: center;">... et ${appLogs.length - 20} logs plus anciens</div>`;
                }
            }
            
            html += '</div></div>';
            
            modalBody.innerHTML = html;
            document.getElementById('debugModal').style.display = 'flex';
        }
        
        function closeDebugModal() {
            document.getElementById('debugModal').style.display = 'none';
        }
        
        function clearLogs() {
            appLogs = [];
            logInfo('Logs vidés manuellement');
            // Rafraîchir la modal si elle est ouverte
            if (document.getElementById('debugModal').style.display === 'flex') {
                showDebugModal();
            }
        }
        
        function syncSelectionStateWithDOM() {
            logDebug('🔄 Synchronisation DOM avec état de sélection...');
            
            let syncCount = 0;
            const allImageCards = document.querySelectorAll('.image-card');
            
            allImageCards.forEach(card => {
                const filename = card.dataset.imageFilename;
                const shouldBeSelected = selectedImages.has(filename);
                const isCurrentlySelected = card.classList.contains('selected');
                
                if (shouldBeSelected && !isCurrentlySelected) {
                    card.classList.add('selected');
                    syncCount++;
                    logDebug(`✅ Classe 'selected' ajoutée à ${filename}`);
                } else if (!shouldBeSelected && isCurrentlySelected) {
                    card.classList.remove('selected');
                    syncCount++;
                    logDebug(`❌ Classe 'selected' supprimée de ${filename}`);
                }
            });
            
            if (syncCount > 0) {
                logInfo(`🔄 ${syncCount} images synchronisées avec l'état de sélection`);
            }
        }
        
        function diagnoseSelectionIssue() {
            logInfo('=== DIAGNOSTIC COMPLET DE LA SÉLECTION ===');
            
            // Vérifier l'état des sélections
            logInfo(`Images sélectionnées en mémoire: ${selectedImages.size}`);
            selectedImages.forEach(filename => {
                logInfo(`  - ${filename}`);
            });
            
            // Vérifier l'état dans le DOM
            const allImageCards = document.querySelectorAll('.image-card');
            logInfo(`Images totales dans le DOM: ${allImageCards.length}`);
            
            let domSelectedCount = 0;
            allImageCards.forEach((card, index) => {
                const filename = card.dataset.imageFilename;
                const hasSelectedClass = card.classList.contains('selected');
                const isInMemory = selectedImages.has(filename);
                
                if (hasSelectedClass) domSelectedCount++;
                
                if (hasSelectedClass !== isInMemory) {
                    logError(`Incohérence détectée - ${filename}: DOM=${hasSelectedClass}, Mémoire=${isInMemory}`);
                }
                
                // Log détaillé pour chaque section
                const sectionEl = card.closest('[data-section-id]');
                const sectionId = sectionEl ? sectionEl.dataset.sectionId : 'inconnu';
                
                logDebug(`Image ${index + 1}: ${filename} | Section: ${sectionId} | DOM selected: ${hasSelectedClass} | Memory: ${isInMemory}`);
            });
            
            logInfo(`Images sélectionnées dans le DOM: ${domSelectedCount}`);
            
            if (domSelectedCount !== selectedImages.size) {
                logError(`PROBLÈME: ${selectedImages.size} en mémoire vs ${domSelectedCount} dans le DOM`);
            }
            
            logInfo('=== FIN DIAGNOSTIC ===');
        }
        
        // Fermer la modal debug en cliquant en dehors
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('debugModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeDebugModal();
                }
            });
        });

        function setupEventListeners() {
            // Configuration inputs
            document.getElementById('prefixInput').addEventListener('input', (e) => {
                appState.prefix = e.target.value || 'CLR';
                updateAllFilenames();
            });
            
            document.getElementById('documentNameInput').addEventListener('input', (e) => {
                // Ne pas permettre de changer le nom du document après traitement
                // car cela casserait les URLs des images
                console.warn('Changement du nom de document désactivé après traitement');
            });
            
            document.getElementById('formatSelect').addEventListener('change', (e) => {
                appState.format = e.target.value;
                updateAllFilenames();
            });
        }
        
        function lockDocumentNameAfterProcessing() {
            const documentNameInput = document.getElementById('documentNameInput');
            if (documentNameInput) {
                documentNameInput.disabled = true;
                documentNameInput.style.opacity = '0.6';
                documentNameInput.style.cursor = 'not-allowed';
                documentNameInput.title = 'Le nom du document ne peut pas être modifié après traitement';
                
                // Ajouter une icône de cadenas
                const parent = documentNameInput.parentElement;
                const lockIcon = document.createElement('i');
                lockIcon.className = 'fas fa-lock';
                lockIcon.style.position = 'absolute';
                lockIcon.style.right = '10px';
                lockIcon.style.top = '50%';
                lockIcon.style.transform = 'translateY(-50%)';
                lockIcon.style.color = 'var(--text-secondary)';
                lockIcon.style.pointerEvents = 'none';
                parent.style.position = 'relative';
                parent.appendChild(lockIcon);
            }
        }

        function loadImagesFromServer() {
            // Utiliser les images extraites directement du template
            const extractedFiles = JSON.parse(document.getElementById('imagesData').textContent);
            
            // Convertir les données du serveur au format attendu par le client
            extractedImages = extractedFiles.map(file => ({
                filename: file.filename,
                section: file.section,
                page: file.page,
                image_number: file.image_number
            }));
            
            console.log('📊 Images chargées:', extractedImages.length, 'images');
            console.log('📊 Première image:', extractedImages[0]);
            
            appState.unassignedImages = [...extractedImages];
            initializeApp();
            updateStats();
        }

        function addNewSection(name = null, parentSectionId = null, afterSectionId = null) {
            try {
                let sectionNumber, sectionName, level, nomenclatureNumber;
                let insertIndex = appState.sections.length; // Par défaut, à la fin
                
                logInfo(`Ajout nouvelle section - name: "${name}", parent: ${parentSectionId}, after: ${afterSectionId}`);
            
            if (parentSectionId) {
                // Créer une sous-section ou sous-sous-section
                const parentSection = appState.sections.find(s => s.id === parentSectionId);
                if (!parentSection) {
                    console.error(`❌ Section parent ${parentSectionId} introuvable`);
                    return;
                }
                
                const parentNumber = parentSection.sectionNumber || parentSection.number;
                
                // Initialiser le compteur de sous-sections pour cette section parent
                if (!appState.maxSubsectionId[parentNumber]) {
                    appState.maxSubsectionId[parentNumber] = 1;
                } else {
                    appState.maxSubsectionId[parentNumber]++;
                }
                
                sectionNumber = `${parentNumber}.${appState.maxSubsectionId[parentNumber]}`;
                level = (parentSection.level || 1) + 1;
                nomenclatureNumber = sectionNumber; // Par défaut, même que le numéro hiérarchique
                
                sectionName = name || `Section ${sectionNumber}`;
                
                // Position pour sous-section : après le parent et ses sous-sections existantes
                const parentIndex = appState.sections.findIndex(s => s.id === parentSectionId);
                insertIndex = parentIndex + 1;
                
                // Trouver la position après toutes les sous-sections existantes du parent
                while (insertIndex < appState.sections.length && 
                       appState.sections[insertIndex].parentId === parentSectionId) {
                    insertIndex++;
                }
            } else if (afterSectionId) {
                // Créer une section principale après une section spécifique
                const afterSection = appState.sections.find(s => s.id === afterSectionId);
                if (afterSection) {
                    const afterIndex = appState.sections.findIndex(s => s.id === afterSectionId);
                    insertIndex = afterIndex + 1;
                    
                    // Si la section après laquelle on insère a des sous-sections, insérer après toutes ses sous-sections
                    while (insertIndex < appState.sections.length && 
                           (appState.sections[insertIndex].parentId === afterSectionId ||
                            (appState.sections[insertIndex].level > 1 && 
                             appState.sections[insertIndex].sectionNumber && 
                             appState.sections[insertIndex].sectionNumber.startsWith(afterSection.sectionNumber + '.')))) {
                        insertIndex++;
                    }
                }
                
                // Le numéro sera déterminé après insertion et renumération
                level = 1;
                sectionName = name || `Section temporaire`;
                nomenclatureNumber = "temp";
            } else {
                // Créer une section principale à la fin ou lors de l'initialisation
                const mainSections = appState.sections.filter(s => (s.level || 1) === 1);
                if (name && name.includes('Section ') && !isNaN(parseInt(name.split(' ')[1]))) {
                    // Si un nom avec numéro est fourni, l'utiliser
                    const providedNumber = parseInt(name.split(' ')[1]);
                    sectionNumber = providedNumber;
                } else {
                    sectionNumber = mainSections.length + 1;
                }
                sectionName = name || `Section ${sectionNumber}`;
                nomenclatureNumber = sectionNumber.toString();
                level = 1;
            }
            
            const newSection = {
                id: appState.nextSectionId++,
                name: sectionName,
                number: insertIndex + 1,                    // Position dans la liste (sera mise à jour)
                sectionNumber: sectionNumber,               // Numéro hiérarchique (sera mis à jour si nécessaire)
                nomenclatureNumber: nomenclatureNumber,     // Numéro utilisé dans la nomenclature des fichiers
                level: level,
                parentId: parentSectionId,
                images: []
            };
            
            console.log(`  📝 Section créée: "${newSection.name}" (n°${newSection.sectionNumber}, niveau ${newSection.level})`);
            
            // Insérer la section à la position calculée
            appState.sections.splice(insertIndex, 0, newSection);
            
            // Ne pas renumbéroter automatiquement lors de l'initialisation pour préserver les numéros détectés
            if (!name || !name.includes('Section ')) {
                renumberSections(true);
            }
            
            // Toujours faire le rendu et mettre à jour les stats après ajout
            renderSections();
            updateStats();
            updateUnassignedImages();
            
            return newSection;
            } catch (error) {
                logError('Erreur lors de l\'ajout de section:', error);
                return null;
            }
        }
        
                 function renumberSections(isAutomaticRename = true) {
             let mainSectionCount = 1;
             const subsectionCounters = {};
             
             appState.sections.forEach((section, index) => {
                 section.number = index + 1; // Position dans la liste
                 
                 if (section.level === 1) {
                     const oldSectionNumber = section.sectionNumber;
                     section.sectionNumber = mainSectionCount.toString();
                     
                     // Mise à jour automatique de la nomenclature seulement si c'est un rename automatique
                     if (isAutomaticRename && (!section.nomenclatureNumber || 
                         section.nomenclatureNumber === oldSectionNumber || 
                         section.nomenclatureNumber === (mainSectionCount - 1).toString() || 
                         section.nomenclatureNumber === "temp")) {
                         section.nomenclatureNumber = mainSectionCount.toString();
                         section.isCustomNomenclature = false; // Flag pour indiquer que ce n'est pas personnalisé
                     } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                         section.isCustomNomenclature = true; // Flag pour indiquer une personnalisation
                     }
                     
                     // Mettre à jour le nom si c'était temporaire
                     if (section.name === "Section temporaire") {
                         section.name = `Section ${mainSectionCount}`;
                     }
                     subsectionCounters[mainSectionCount] = 1;
                     mainSectionCount++;
                 } else if (section.level === 2 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise à jour automatique seulement si approprié
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                         subsectionCounters[section.sectionNumber] = 1;
                     }
                 } else if (section.level === 3 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise à jour automatique seulement si approprié
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                     }
                 }
             });
         }

        function deleteSection(sectionId) {
            const sectionIndex = appState.sections.findIndex(s => s.id === sectionId);
            if (sectionIndex !== -1) {
                const sectionToDelete = appState.sections[sectionIndex];
                
                // Supprimer aussi toutes les sous-sections de cette section
                const sectionsToDelete = [sectionToDelete];
                if (sectionToDelete.level === 1) {
                    const subsections = appState.sections.filter(s => s.parentId === sectionId);
                    sectionsToDelete.push(...subsections);
                }
                
                // Remettre toutes les images dans unassigned
                sectionsToDelete.forEach(section => {
                    appState.unassignedImages.push(...section.images);
                });
                
                // Supprimer les sections
                sectionsToDelete.forEach(section => {
                    const index = appState.sections.findIndex(s => s.id === section.id);
                    if (index !== -1) {
                        appState.sections.splice(index, 1);
                    }
                });
                
                // Renumbéroter les sections (automatique)
                renumberSections(true);
                renderSections();
                updateStats();
                updateAllFilenames();
            }
        }

                function cleanupTooltips() {
            // Supprimer tous les tooltips existants pour éviter les doublons
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                tooltip.remove();
            });
            
            // Disposer des instances Bootstrap Tooltip existantes
            document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(element => {
                const tooltipInstance = bootstrap.Tooltip.getInstance(element);
                if (tooltipInstance) {
                    tooltipInstance.dispose();
                }
            });
        }

        function renderSections() {
            const container = document.getElementById('sectionsContainer');
            const emptyState = document.getElementById('emptyState');
            
            if (appState.sections.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            
            // Organiser les sections par hiérarchie
            const organizedHTML = buildHierarchicalSections(appState.sections);
            container.innerHTML = organizedHTML;
            
            // Forcer la synchronisation de l'état de sélection
            syncSelectionStateWithDOM();
            
            // Initialiser les zones de drop
            setupSortable();
            
            // Nettoyer les anciens tooltips pour éviter les doublons
            cleanupTooltips();
            
            // Activer les nouveaux tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }
        
        function buildHierarchicalSections(sections) {
            let html = '';
            
            // Filtrer les sections principales (niveau 1)
            const mainSections = sections.filter(s => (s.level || 1) === 1);
            
            mainSections.forEach(mainSection => {
                html += renderMainSection(mainSection, sections);
            });
            
            return html;
        }
        
                function renderMainSection(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            const nomenclatureNumber = mainSection.nomenclatureNumber || sectionNumber;
            
            // Trouver toutes les sous-sections de cette section principale et les organiser hiérarchiquement
            const subsections = getOrderedSubsections(mainSection, allSections);
            
            let html = `
            <div class="section-group-wrapper">
                ${renderSectionCard(mainSection, subsections)}
            </div>
            `;
            
            return html;
        }
        
        function getOrderedSubsections(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            
            // Récupérer toutes les sections qui appartiennent à cette section principale
            const relatedSections = allSections.filter(s => 
                s.level > 1 && 
                s.sectionNumber && 
                s.sectionNumber.startsWith(sectionNumber + '.')
            );
            
            // Trier par numéro de section pour respecter l'ordre hiérarchique
            relatedSections.sort((a, b) => {
                return compareVersions(a.sectionNumber, b.sectionNumber);
            });
            
            return relatedSections;
        }
        
        function compareVersions(a, b) {
            const aParts = a.split('.').map(Number);
            const bParts = b.split('.').map(Number);
            
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const aPart = aParts[i] || 0;
                const bPart = bParts[i] || 0;
                
                if (aPart !== bPart) {
                    return aPart - bPart;
                }
            }
            
            return 0;
        }
        
        function renderHierarchicalSubsections(subsections) {
            let html = '';
            let currentLevel2Section = null;
            let level3Sections = [];
            
            for (let i = 0; i < subsections.length; i++) {
                const section = subsections[i];
                
                if (section.level === 2) {
                    // Si on avait une section niveau 2 en cours, on la rend avec ses sous-sections niveau 3
                    if (currentLevel2Section) {
                        html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
                        level3Sections = [];
                    }
                    currentLevel2Section = section;
                } else if (section.level === 3 && currentLevel2Section) {
                    // Ajouter cette sous-sous-section à la liste de la section niveau 2 courante
                    level3Sections.push(section);
                } else {
                    // Section orpheline, la rendre directement
                    html += renderSectionCard(section);
                }
            }
            
            // Traiter la dernière section niveau 2 s'il y en a une
            if (currentLevel2Section) {
                html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
            }
            
            return html;
        }
        
        function renderSectionWithSubsections(level2Section, level3Sections) {
            let html = renderSectionCard(level2Section);
            
            if (level3Sections.length > 0) {
                html += '<div class="sub-sub-sections-container">';
                html += level3Sections.map(sub => renderSectionCard(sub)).join('');
                html += '</div>';
            }
            
            return html;
        }
        
        function renderSectionCard(section, subsections = []) {
            const level = section.level || 1;
            const sectionNumber = section.sectionNumber || section.number;
            const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
            const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
            
            // Classes CSS selon le niveau
            let cardClass = 'section-editor glass-card';
            if (level === 1) {
                cardClass += subsections.length > 0 ? ' main-section-with-subs' : ' main-section';
            } else if (level === 2) {
                cardClass += ' sub-section';
            } else {
                cardClass += ' sub-sub-section';
            }
            
            return `
            <div class="${cardClass}" data-section-id="${section.id}">
                <div class="section-header">
                    <div class="section-title">
                        <div class="section-number" title="Cliquez pour modifier la nomenclature (actuellement: ${nomenclatureNumber})" 
                             onclick="editNomenclature(${section.id}, '${nomenclatureNumber}', this)">
                            ${levelIcon} <span class="section-number-text">${sectionNumber}</span>
                            ${section.isCustomNomenclature && nomenclatureNumber !== sectionNumber ? `<span class="nomenclature-badge">→ ${nomenclatureNumber}</span>` : ''}
                        </div>
                    </div>
                    <div class="section-controls">
                        ${level < 3 ? `
                            <button class="btn-icon btn-add-sub" onclick="addNewSection(null, ${section.id})" 
                                    data-bs-toggle="tooltip" title="Ajouter une ${level === 1 ? 'sous-section' : 'sous-sous-section'}">
                                <i class="fas fa-plus-circle"></i>
                            </button>
                        ` : ''}
                        <button class="btn-icon btn-delete" onclick="deleteSection(${section.id})"
                                data-bs-toggle="tooltip" title="Supprimer cette ${level === 1 ? 'section' : level === 2 ? 'sous-section' : 'sous-sous-section'}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="images-grid" data-section-id="${section.id}">
                    ${section.images.map((image, index) => renderImageCard(image, nomenclatureNumber, index + 1)).join('')}
                    ${section.images.length === 0 ? '<div class="empty-state"><i class="fas fa-images"></i><p>Glissez des images ici</p></div>' : ''}
                </div>
                
                ${level === 1 && subsections.length > 0 ? `
                    <div class="subsections-container">
                        ${renderHierarchicalSubsections(subsections)}
                    </div>
                ` : ''}
            </div>
            `;
        }

        function renderImageCard(image, sectionNumber, imageNumber) {
            const filename = generateFilename(sectionNumber, imageNumber);
            const isSelected = selectedImages.has(image.filename);
            
            // Log détaillé pour le diagnostic
            logDebug(`Rendu image: ${image.filename} | Généré: ${filename} | Sélectionnée: ${isSelected}`);
            
            if (isSelected) {
                logDebug(`✅ Image sélectionnée à rendre: ${image.filename} dans section ${sectionNumber}`);
            }
            
            return `
                <div class="image-card ${isSelected ? 'selected' : ''}" data-image-filename="${image.filename}" onclick="toggleImageSelectionByClick('${image.filename}')">
                    <img src="/image/${appState.documentName}/${image.filename}" 
                         alt="${image.filename}" class="image-preview" 
                         onerror="this.style.display='none'">
                    <div class="image-overlay">
                        <button class="btn-zoom" onclick="showImagePreview('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Agrandir l'image">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button class="btn-assign" onclick="showSectionSelector('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Assigner à une section">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                    <div class="image-info">
                        <div class="image-filename">${filename}</div>
                        <div class="image-page">Page ${image.page}</div>
                    </div>
                </div>
            `;
        }

        function setupSortable() {
            // Sortable pour les grilles d'images
            document.querySelectorAll('.images-grid').forEach(grid => {
                new Sortable(grid, {
                    group: 'images',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    onStart: function(evt) {
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const totalImages = isSelected ? selectedImages.size : (selectedImages.size > 0 ? selectedImages.size + 1 : 1);
                        
                        // Marquer les images comme étant draggées (les masquer)
                        markImagesAsBeingDragged(imageFilename);
                        
                        // Créer le stack visuel si multiple images
                        if (totalImages > 1) {
                            // Position initiale
                            const rect = evt.item.getBoundingClientRect();
                            createDragStack(imageFilename, rect.left + rect.width/2, rect.top + rect.height/2);
                        }
                    },
                    onMove: function(evt) {
                        // Mettre à jour la position du stack pendant le drag
                        if (isDraggingMultiple && dragStackContainer) {
                            const rect = evt.related.getBoundingClientRect();
                            updateDragStackPosition(rect.left, rect.top);
                        }
                    },
                    onAdd: function(evt) {
                        const sectionId = parseInt(evt.to.dataset.sectionId);
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const dropIndex = evt.newIndex;
                        
                        // Préparer la liste des images à déplacer dans le bon ordre d'origine
                        const imagesToMove = [];
                        
                        // Si l'image draguée n'était pas sélectionnée, elle va en premier
                        if (!isSelected) {
                            imagesToMove.push(imageFilename);
                        }
                        
                        // Ajouter les images sélectionnées dans l'ordre qu'elles avaient dans leur section d'origine
                        const selectedInOrder = getSelectedImagesInSourceOrder();
                        imagesToMove.push(...selectedInOrder);
                        
                        // Déplacer les images en préservant l'ordre et la position
                        moveImagesToSectionAtPosition(imagesToMove, sectionId, dropIndex);
                        
                        clearSelection();
                        renderSections();
                        updateUnassignedImages();
                    },
                    onUpdate: function(evt) {
                        // Réorganisation dans la même section
                        const sectionId = parseInt(evt.from.dataset.sectionId);
                        if (sectionId && !isNaN(sectionId)) {
                            reorderImagesInSection(sectionId);
                        }
                        updateUnassignedImages();
                    },
                    onEnd: function(evt) {
                        // Nettoyer le stack et les états de drag
                        removeDragStack();
                        unmarkImagesAsBeingDragged();
                    }
                });
            });
            
            // Sortable pour les groupes de sections principales
            const sectionsContainer = document.getElementById('sectionsContainer');
            if (sectionsContainer) {
                new Sortable(sectionsContainer, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '[class*="main-section"] .section-number', // Seules les sections principales peuvent être déplacées
                    onEnd: function(evt) {
                        // Réorganiser les sections selon le nouvel ordre des groupes
                        rebuildSectionsOrderFromDOM();
                        
                        // Renumération automatique après déplacement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            }
            
            // Sortable pour les sous-sections dans leurs containers
            document.querySelectorAll('.subsections-container').forEach(container => {
                new Sortable(container, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '.section-number', // Sous-sections peuvent être réorganisées entre elles
                    onEnd: function(evt) {
                        // Réorganiser les sous-sections
                        rebuildSectionsOrderFromDOM();
                        
                        // Renumération automatique après déplacement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            });
        }
        
        function rebuildSectionsOrderFromDOM() {
            const newOrder = [];
            
            // Parcourir chaque wrapper de section
            document.querySelectorAll('.section-group-wrapper').forEach(wrapper => {
                // Ajouter la section principale
                const mainSectionEl = wrapper.querySelector('.main-section, .main-section-with-subs');
                if (mainSectionEl) {
                    const mainSectionId = parseInt(mainSectionEl.dataset.sectionId);
                    const mainSection = appState.sections.find(s => s.id === mainSectionId);
                    if (mainSection) {
                        newOrder.push(mainSection);
                    }
                    
                    // Ajouter les sous-sections dans l'ordre
                    const subsectionsContainer = mainSectionEl.querySelector('.subsections-container');
                    if (subsectionsContainer) {
                        // Parcourir dans l'ordre : sous-sections niveau 2, puis leurs sous-sections niveau 3
                        subsectionsContainer.querySelectorAll('.sub-section').forEach(subEl => {
                            const subSectionId = parseInt(subEl.dataset.sectionId);
                            const subSection = appState.sections.find(s => s.id === subSectionId);
                            if (subSection) {
                                newOrder.push(subSection);
                                
                                // Ajouter les sous-sous-sections de cette sous-section
                                const subSubContainer = subEl.nextElementSibling;
                                if (subSubContainer && subSubContainer.classList.contains('sub-sub-sections-container')) {
                                    subSubContainer.querySelectorAll('.sub-sub-section').forEach(subSubEl => {
                                        const subSubSectionId = parseInt(subSubEl.dataset.sectionId);
                                        const subSubSection = appState.sections.find(s => s.id === subSubSectionId);
                                        if (subSubSection) {
                                            newOrder.push(subSubSection);
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
            });
            
            appState.sections = newOrder;
        }

        function moveImageToSection(imageFilename, targetSectionId) {
            // Trouver l'image
            let image = null;
            let sourceSection = null;
            
            // Chercher dans unassigned
            const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === imageFilename);
            if (unassignedIndex !== -1) {
                image = appState.unassignedImages.splice(unassignedIndex, 1)[0];
            } else {
                // Chercher dans les sections
                for (let section of appState.sections) {
                    const imageIndex = section.images.findIndex(img => img.filename === imageFilename);
                    if (imageIndex !== -1) {
                        image = section.images.splice(imageIndex, 1)[0];
                        sourceSection = section;
                        break;
                    }
                }
            }
            
            if (image) {
                if (targetSectionId === 'unassigned') {
                    // Remettre dans les non attribuées
                    appState.unassignedImages.push(image);
                } else {
                    // Ajouter à la section cible
                    const targetSection = appState.sections.find(s => s.id === targetSectionId);
                    if (targetSection) {
                        targetSection.images.push(image);
                    }
                }
                updateStats();
                updateAllFilenames();
            }
        }
        
        function moveImagesToSectionAtPosition(imageFilenames, targetSectionId, insertIndex) {
            console.log(`📦 Déplacement groupé de ${imageFilenames.length} images vers section ${targetSectionId} à l'index ${insertIndex}`);
            
            // Collecter toutes les images dans l'ordre fourni (qui respecte l'ordre d'origine)
            const imagesToMove = [];
            
            // Pour chaque nom de fichier dans l'ordre fourni, trouver et collecter l'image
            imageFilenames.forEach(filename => {
                let image = null;
                
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    image = appState.unassignedImages[unassignedIndex];
                    if (image) imagesToMove.push(image);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            image = section.images[imageIndex];
                            if (image) imagesToMove.push(image);
                            break;
                        }
                    }
                }
            });
            
            // Maintenant supprimer les images de leurs positions actuelles
            // Supprimer dans l'ordre inverse pour éviter les décalages d'index
            imageFilenames.slice().reverse().forEach(filename => {
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    appState.unassignedImages.splice(unassignedIndex, 1);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            section.images.splice(imageIndex, 1);
                            break;
                        }
                    }
                }
            });
            
            console.log(`  📋 ${imagesToMove.length} images collectées pour déplacement (ordre préservé)`);
            
            if (imagesToMove.length === 0) return;
            
            if (targetSectionId === 'unassigned') {
                // Ajouter toutes les images aux non attribuées
                appState.unassignedImages.push(...imagesToMove);
            } else {
                // Insérer dans la section cible à la position spécifiée
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    // Calculer la position d'insertion réelle (en tenant compte des suppressions)
                    let actualInsertIndex = Math.min(insertIndex, targetSection.images.length);
                    
                    // Insérer toutes les images en bloc à la position calculée
                    targetSection.images.splice(actualInsertIndex, 0, ...imagesToMove);
                    
                    console.log(`  ✅ Images insérées dans section ${targetSection.sectionNumber} à l'index ${actualInsertIndex}`);
                }
            }
            
            updateStats();
            updateAllFilenames();
        }

        function reorderImagesInSection(sectionId) {
            // Récupérer l'ordre actuel depuis le DOM
            const grid = document.querySelector(`[data-section-id="${sectionId}"]`);
            const imageCards = grid.querySelectorAll('.image-card');
            const section = appState.sections.find(s => s.id === sectionId);
            
            if (section) {
                const newOrder = Array.from(imageCards).map(card => {
                    const filename = card.dataset.imageFilename;
                    return section.images.find(img => img.filename === filename);
                }).filter(img => img); // Filtrer les undefined
                
                section.images = newOrder;
                updateAllFilenames();
            }
        }


        
        function updateNomenclatureNumber(sectionId, newNumber) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (section) {
                section.nomenclatureNumber = newNumber.trim();
                // Marquer comme personnalisé si différent du numéro de section
                section.isCustomNomenclature = (newNumber.trim() !== section.sectionNumber);
                updateAllFilenames();
                renderSections(); // Re-render pour mettre à jour l'exemple et les noms de fichiers
            }
        }
        
        function editNomenclature(sectionId, currentNomenclature, element) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (!section) return;
            
            // Créer un input temporaire
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentNomenclature;
            input.className = 'nomenclature-input';
            input.style.cssText = `
                background: rgba(15, 23, 42, 0.9);
                border: 2px solid var(--accent-blue);
                border-radius: 6px;
                color: white;
                padding: 0.25rem 0.5rem;
                font-size: 0.9rem;
                font-weight: 600;
                font-family: Monaco, Menlo, monospace;
                min-width: 100px;
                outline: none;
            `;
            
            // Remplacer temporairement le contenu
            const originalHTML = element.innerHTML;
            element.innerHTML = '';
            element.appendChild(input);
            
            // Focus et sélectionner le texte
            input.focus();
            input.select();
            
            // Fonction pour valider et revenir à l'affichage normal
            const finishEdit = () => {
                const newValue = input.value.trim();
                if (newValue && newValue !== currentNomenclature) {
                    updateNomenclatureNumber(sectionId, newValue);
                } else {
                    // Annuler, remettre l'affichage original
                    element.innerHTML = originalHTML;
                }
            };
            
            // Événements
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    element.innerHTML = originalHTML;
                }
            });
        }

        function generateFilename(sectionNumber, imageNumber) {
            return `${appState.prefix}-${appState.documentName}-${sectionNumber} n_${imageNumber}.${appState.format}`;
        }

        function updateAllFilenames() {
            // Mettre à jour l'affichage des noms de fichiers
            renderSections();
        }

        function updateStats() {
            document.getElementById('sectionsCount').textContent = appState.sections.length;
            document.getElementById('imagesCount').textContent = extractedImages.length;
            updateSelectionStats();
        }

        function updateUnassignedImages() {
            console.log('🔄 Mise à jour des images non attribuées...');
            
            const assignedFilenames = new Set();
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    assignedFilenames.add(image.filename);
                });
            });
            
            console.log(`  Images assignées: ${assignedFilenames.size}`);
            console.log(`  Images extraites total: ${extractedImages.length}`);
            
            appState.unassignedImages = extractedImages.filter(image => 
                !assignedFilenames.has(image.filename)
            );
            
            console.log(`  Images non attribuées calculées: ${appState.unassignedImages.length}`);
            
            renderUnassignedImages();
        }
        
        function renderUnassignedImages() {
            const container = document.getElementById('unassignedImagesContainer');
            const grid = document.getElementById('unassignedGrid');
            const badge = document.getElementById('unassignedBadge');
            
            if (appState.unassignedImages.length === 0) {
                container.style.display = 'none';
            } else {
                container.style.display = 'block';
                badge.textContent = appState.unassignedImages.length;
                
                grid.innerHTML = appState.unassignedImages.map((image, index) => 
                    renderImageCard(image, 'NON-ATTRIBUEE', index + 1)
                ).join('');
                
                // Synchroniser l'état de sélection pour les images non attribuées
                setTimeout(() => {
                    const unassignedCards = grid.querySelectorAll('.image-card');
                    unassignedCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (selectedImages.has(filename) && !card.classList.contains('selected')) {
                            card.classList.add('selected');
                            logDebug(`✅ Synchronisation: classe 'selected' ajoutée à ${filename} (non attribuée)`);
                        }
                    });
                }, 10);
            }
        }

        function showImagePreview(filename, event = null) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            logDebug(`Aperçu demandé pour: ${filename}`);
            
            const modal = new bootstrap.Modal(document.getElementById('imageModal'));
            const modalImage = document.getElementById('modalImage');
            const modalInfo = document.getElementById('modalImageInfo');
            
            modalImage.src = `/image/${appState.documentName}/${filename}`;
            modalInfo.innerHTML = `<strong>Fichier:</strong> ${filename}`;
            
            modal.show();
        }

        // Fonction pour toggle les tips
        function toggleTips() {
            const content = document.getElementById('tipsContent');
            const chevron = document.getElementById('tipsChevron');
            
            content.classList.toggle('collapsed');
            chevron.classList.toggle('rotated');
        }
        
        // Variables globales pour le sélecteur de section
        let currentSectionSelector = null;
        
        // Variables globales pour la sélection multiple
        let selectedImages = new Set();
        
        // Variables pour le drag stack
        let dragStackContainer = null;
        let isDraggingMultiple = false;
        
        // Système de logs pour le debug
        let appLogs = [];
        const MAX_LOGS = 100;
        
        function logDebug(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'debug',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] DEBUG:`, message, data || '');
        }
        
        function logInfo(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'info',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] INFO:`, message, data || '');
        }
        
        function logError(message, error = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'error',
                message: message,
                data: error ? error.toString() : null
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.error(`[${timestamp}] ERROR:`, message, error || '');
        }
        
        function showSectionSelector(imageFilename, event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Fermer le sélecteur existant s'il y en a un
            closeSectionSelector();
            
            // Créer le sélecteur
            const selector = document.createElement('div');
            selector.className = 'section-selector';
            selector.innerHTML = generateSectionSelectorHTML(imageFilename);
            
            // Positionner le sélecteur près du bouton
            const rect = event.target.getBoundingClientRect();
            selector.style.left = (rect.left + window.scrollX + 60) + 'px';
            selector.style.top = (rect.top + window.scrollY - 150) + 'px';
            
            // Ajouter au document
            document.body.appendChild(selector);
            currentSectionSelector = selector;
            
            // Fermer le sélecteur si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeSectionSelectorOnClickOutside);
            }, 100);
        }
        
        function generateSectionSelectorHTML(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const selectedCount = selectedImages.size;
            const totalToMove = isImageSelected ? selectedCount : (selectedCount > 0 ? selectedCount + 1 : 1);
            
            let html = `
                <div class="section-selector-header">
                    <i class="fas fa-arrow-right me-2"></i>
                    ${totalToMove > 1 ? 
                        `Assigner ${totalToMove} images à une section` : 
                        'Assigner à une section'
                    }
                    ${totalToMove > 1 ? `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        ${isImageSelected ? 'Cette image + sélection' : 'Cette image + ' + selectedCount + ' sélectionnées'}
                    </div>` : ''}
                </div>
            `;
            
            // Ajouter toutes les sections disponibles
            appState.sections.forEach(section => {
                const level = section.level || 1;
                const sectionNumber = section.sectionNumber || section.number;
                const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
                const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
                const levelClass = level === 2 ? 'section-option-level-2' : level === 3 ? 'section-option-level-3' : '';
                
                html += `
                    <div class="section-option ${levelClass}" onclick="assignImageToSection('${imageFilename}', ${section.id})">
                        <span class="section-option-number">${levelIcon} ${nomenclatureNumber}</span>
                        <span class="section-option-label">Section ${sectionNumber}</span>
                    </div>
                `;
            });
            
            return html;
        }
        
        function assignImageToSection(imageFilename, targetSectionId) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMove = [];
            
            // Ajouter l'image cliquée si elle n'est pas déjà sélectionnée
            if (!isImageSelected) {
                imagesToMove.push(imageFilename);
            }
            
            // Ajouter toutes les images sélectionnées
            imagesToMove.push(...getSelectedImagesList());
            
            // Déplacer toutes les images groupées à la fin de la section (pas d'index spécifique)
            if (targetSectionId === 'unassigned') {
                imagesToMove.forEach(filename => {
                    moveImageToSection(filename, targetSectionId);
                });
            } else {
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    moveImagesToSectionAtPosition(imagesToMove, targetSectionId, targetSection.images.length);
                }
            }
            
            // Nettoyer la sélection
            clearSelection();
            
            renderSections();
            updateStats();
            closeSectionSelector();
        }
        
        function closeSectionSelector() {
            if (currentSectionSelector) {
                currentSectionSelector.remove();
                currentSectionSelector = null;
                document.removeEventListener('click', closeSectionSelectorOnClickOutside);
            }
        }
        
        function closeSectionSelectorOnClickOutside(event) {
            if (currentSectionSelector && !currentSectionSelector.contains(event.target)) {
                closeSectionSelector();
            }
        }
        
        // Fonctions de sélection multiple
        function toggleImageSelection(imageFilename, isSelected) {
            const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
            
            if (isSelected) {
                selectedImages.add(imageFilename);
                imageCard.classList.add('selected');
            } else {
                selectedImages.delete(imageFilename);
                imageCard.classList.remove('selected');
            }
            
            updateSelectionStats();
        }
        
        function toggleImageSelectionByClick(imageFilename) {
            try {
                const isCurrentlySelected = selectedImages.has(imageFilename);
                const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
                
                logDebug(`Toggle sélection - Image: ${imageFilename}, Actuellement sélectionnée: ${isCurrentlySelected}`);
                
                if (!imageCard) {
                    logError(`Element DOM introuvable pour l'image: ${imageFilename}`);
                    return;
                }
                
                // Vérifier la section parente pour diagnostic
                const parentSection = imageCard.closest('[data-section-id]');
                const sectionId = parentSection ? parentSection.dataset.sectionId : 'inconnue';
                logDebug(`Image ${imageFilename} dans section ID: ${sectionId}`);
                
                if (isCurrentlySelected) {
                    selectedImages.delete(imageFilename);
                    imageCard.classList.remove('selected');
                    logDebug(`✅ Image désélectionnée: ${imageFilename}, Classes après: ${imageCard.className}`);
                } else {
                    selectedImages.add(imageFilename);
                    imageCard.classList.add('selected');
                    logDebug(`✅ Image sélectionnée: ${imageFilename}, Classes après: ${imageCard.className}`);
                    
                    // Vérifier que la classe a bien été ajoutée
                    setTimeout(() => {
                        const hasSelectedClass = imageCard.classList.contains('selected');
                        logDebug(`Vérification retardée - Classe 'selected' présente: ${hasSelectedClass}`);
                        if (!hasSelectedClass) {
                            logError(`❌ La classe 'selected' n'a pas été appliquée à ${imageFilename}`);
                        }
                    }, 100);
                }
                
                updateSelectionStats();
            } catch (error) {
                logError(`Erreur lors de la sélection de l'image ${imageFilename}:`, error);
            }
        }
        
        function updateSelectionStats() {
            document.getElementById('selectedCount').textContent = selectedImages.size;
        }
        
        function clearSelection() {
            const count = selectedImages.size;
            selectedImages.forEach(filename => {
                const imageCard = document.querySelector(`[data-image-filename="${filename}"]`);
                if (imageCard) imageCard.classList.remove('selected');
            });
            selectedImages.clear();
            updateSelectionStats();
            logDebug(`Sélection vidée - ${count} images désélectionnées`);
        }
        
        function getSelectedImagesList() {
            // Retourner les images sélectionnées dans l'ordre d'apparition dans l'interface
            const allImages = document.querySelectorAll('.image-card');
            const orderedSelectedImages = [];
            
            allImages.forEach(card => {
                const filename = card.dataset.imageFilename;
                if (selectedImages.has(filename)) {
                    orderedSelectedImages.push(filename);
                }
            });
            
            return orderedSelectedImages;
        }
        
        function getSelectedImagesInSourceOrder() {
            // Retourner les images sélectionnées dans l'ordre qu'elles avaient dans leurs sections d'origine
            const orderedSelectedImages = [];
            
            // D'abord, chercher dans les images non attribuées
            appState.unassignedImages.forEach(image => {
                if (selectedImages.has(image.filename)) {
                    orderedSelectedImages.push(image.filename);
                }
            });
            
            // Ensuite, parcourir toutes les sections dans l'ordre hiérarchique
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    if (selectedImages.has(image.filename)) {
                        orderedSelectedImages.push(image.filename);
                    }
                });
            });
            
            return orderedSelectedImages;
        }
        
        function toggleSelectAll() {
            try {
                const allImageCards = document.querySelectorAll('.image-card');
                logDebug(`Toggle select all - ${allImageCards.length} images trouvées, ${selectedImages.size} sélectionnées`);
                
                // Vérifier combien d'images actuellement visibles sont sélectionnées
                let visibleSelectedCount = 0;
                allImageCards.forEach(card => {
                    const filename = card.dataset.imageFilename;
                    if (selectedImages.has(filename)) {
                        visibleSelectedCount++;
                    }
                });
                
                const allVisibleSelected = (allImageCards.length > 0 && visibleSelectedCount === allImageCards.length);
                logDebug(`Images visibles sélectionnées: ${visibleSelectedCount}/${allImageCards.length}, tout sélectionné: ${allVisibleSelected}`);
                
                if (allVisibleSelected) {
                    // Tout désélectionner
                    logDebug('Désélection de toutes les images');
                    clearSelection();
                    document.getElementById('selectAllText').textContent = 'Tout sélectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-check-square';
                } else {
                    // Tout sélectionner
                    logDebug('Sélection de toutes les images visibles');
                    allImageCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (!selectedImages.has(filename)) {
                            selectedImages.add(filename);
                            card.classList.add('selected');
                        }
                    });
                    updateSelectionStats();
                    document.getElementById('selectAllText').textContent = 'Tout désélectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-square';
                }
            } catch (error) {
                logError('Erreur dans toggleSelectAll:', error);
            }
        }
        
        // Fonctions pour le drag stack
        function createDragStack(imageFilename, mousePosX, mousePosY) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToShow = [];
            
            // Ajouter l'image principale si elle n'est pas sélectionnée
            if (!isImageSelected) {
                imagesToShow.push(imageFilename);
            }
            
            // Ajouter les images sélectionnées (max 4 pour l'affichage)
            const selectedList = getSelectedImagesList();
            imagesToShow.push(...selectedList.slice(0, 4));
            
            if (imagesToShow.length <= 1) return;
            
            // Créer le container
            dragStackContainer = document.createElement('div');
            dragStackContainer.className = 'drag-stack-container';
            dragStackContainer.style.left = (mousePosX - 75) + 'px';
            dragStackContainer.style.top = (mousePosY - 50) + 'px';
            
            // Créer les images empilées (maximum 3 visibles + compteur)
            imagesToShow.slice(0, 3).forEach((filename, index) => {
                const stackImage = document.createElement('div');
                stackImage.className = `drag-stack-image stack-${index + 1}`;
                
                const img = document.createElement('img');
                img.src = `/image/${appState.documentName}/${filename}`;
                img.onerror = () => img.style.display = 'none';
                
                stackImage.appendChild(img);
                dragStackContainer.appendChild(stackImage);
            });
            
            // Ajouter le compteur si plus de 3 images
            if (imagesToShow.length > 1) {
                const counter = document.createElement('div');
                counter.className = 'drag-stack-counter';
                counter.textContent = imagesToShow.length;
                dragStackContainer.appendChild(counter);
            }
            
            document.body.appendChild(dragStackContainer);
            isDraggingMultiple = true;
        }
        
        function updateDragStackPosition(mousePosX, mousePosY) {
            if (dragStackContainer) {
                dragStackContainer.style.left = (mousePosX - 75) + 'px';
                dragStackContainer.style.top = (mousePosY - 50) + 'px';
            }
        }
        
        function removeDragStack() {
            if (dragStackContainer) {
                dragStackContainer.remove();
                dragStackContainer = null;
                isDraggingMultiple = false;
            }
        }
        
        function markImagesAsBeingDragged(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMark = [];
            
            if (!isImageSelected) {
                imagesToMark.push(imageFilename);
            }
            imagesToMark.push(...getSelectedImagesList());
            
            imagesToMark.forEach(filename => {
                const card = document.querySelector(`[data-image-filename="${filename}"]`);
                if (card) {
                    card.classList.add('being-dragged');
                }
            });
        }
        
        function unmarkImagesAsBeingDragged() {
            document.querySelectorAll('.being-dragged').forEach(card => {
                card.classList.remove('being-dragged');
            });
        }
        
        function setupDragStackMouseTracking() {
            // Utiliser un tracking global de souris pour SortableJS
            let isTrackingMouse = false;
            
            document.addEventListener('mousedown', function(e) {
                if (e.target.closest('.image-card')) {
                    isTrackingMouse = true;
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDraggingMultiple && dragStackContainer && isTrackingMouse) {
                    updateDragStackPosition(e.clientX, e.clientY);
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                isTrackingMouse = false;
            });
        }
        
        function exportImages() {
            // Générer la configuration d'export
            const exportConfig = {
                prefix: appState.prefix,
                documentName: appState.documentName,
                format: appState.format,
                sections: appState.sections.map(section => ({
                    number: section.nomenclatureNumber || section.sectionNumber || section.number,
                    displayNumber: section.sectionNumber || section.number,
                    name: section.name,
                    level: section.level || 1,
                    images: section.images.map((image, index) => ({
                        originalFilename: image.filename,
                        newFilename: generateFilename(section.nomenclatureNumber || section.sectionNumber || section.number, index + 1),
                        page: image.page
                    }))
                }))
            };
            
            // Envoyer la configuration au serveur pour générer le ZIP
            fetch('/export-custom', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportConfig)
            })
            .then(response => response.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `${appState.documentName}_custom.zip`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Erreur lors de l\'export:', error);
                alert('Erreur lors de l\'export. Veuillez réessayer.');
            });
        }
    </script>
</body>
</html> 