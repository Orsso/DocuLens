<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocuLens - √âditeur de Sections</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-blue: #1e3a8a;
            --dark-blue: #1e293b;
            --glass-bg: rgba(30, 58, 138, 0.1);
            --glass-border: rgba(59, 130, 246, 0.2);
            --glass-shadow: rgba(0, 0, 0, 0.3);
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --accent-blue: #3b82f6;
            --success-green: #10b981;
            --warning-orange: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #1e3a8a 100%);
            background-attachment: fixed;
            background-size: 100% 100%;
            min-height: 100vh;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-primary);
            overflow-x: hidden;
            overscroll-behavior: none;
        }
        
        html {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #1e3a8a 100%);
            background-attachment: fixed;
            overscroll-behavior: none;
        }

        /* Glassmorphism Effects */
        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px var(--glass-shadow);
        }

        .glass-card {
            background: rgba(30, 58, 138, 0.15);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
            border-color: rgba(59, 130, 246, 0.5);
        }



        /* Configuration Panel */
        .config-panel {
            position: sticky;
            top: 20px;
            z-index: 100;
        }

        .config-form {
            display: grid;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-control {
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary) !important;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            background: rgba(15, 23, 42, 0.8);
            color: var(--text-primary) !important;
        }
        
        .form-control::placeholder {
            color: rgba(203, 213, 225, 0.5) !important;
        }
        
        .form-control:disabled {
            background: rgba(15, 23, 42, 0.3) !important;
            border-color: rgba(59, 130, 246, 0.1) !important;
            color: var(--text-secondary) !important;
            cursor: not-allowed !important;
        }
        
        .form-control option {
            background: var(--dark-blue);
            color: var(--text-primary);
        }

        .btn-glass {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.8), rgba(29, 78, 216, 0.8));
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            padding: 0.75rem 1.5rem;
            color: white;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-glass:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
            text-decoration: none;
            color: white;
        }

        /* Sections Management */
        .sections-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Section grouping structure */
        .section-group-wrapper {
            margin-bottom: 2rem;
        }

        .section-editor {
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* Main sections */
        .main-section {
            border-left: 4px solid var(--accent-blue);
        }
        
        /* Main sections with subsections - larger container */
        .main-section-with-subs {
            border-left: 4px solid var(--accent-blue);
            background: rgba(59, 130, 246, 0.02);
            border: 1px solid rgba(59, 130, 246, 0.15);
        }
        
        /* Subsections container inside main section */
        .main-section-with-subs .subsections-container {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(59, 130, 246, 0.03);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            position: relative;
        }
        
        .main-section-with-subs .subsections-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.6), transparent);
            border-radius: 4px 4px 0 0;
        }
        
        /* Sub-sections */
        .sub-section {
            border-left: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.05);
            margin-bottom: 1rem;
        }
        
        .sub-section:last-child {
            margin-bottom: 0;
        }
        
        /* Sub-sub-sections */
        .sub-sub-section {
            border-left: 2px solid #f59e0b;
            background: rgba(245, 158, 11, 0.05);
            margin-bottom: 0.75rem;
        }
        
        .sub-sub-sections-container {
            margin-left: 1rem;
            margin-top: 0.75rem;
            padding-left: 1rem;
            border-left: 2px solid rgba(245, 158, 11, 0.3);
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        .section-number {
            background: linear-gradient(135deg, var(--accent-blue), #1d4ed8);
            color: white;
            border-radius: 8px;
            padding: 0.5rem 1rem;
            font-weight: 700;
            min-width: 80px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .section-number:hover {
            background: linear-gradient(135deg, #60a5fa, var(--accent-blue));
            transform: scale(1.02);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
        }
        
        .section-number:active {
            cursor: grabbing;
        }
        
        .section-number i {
            margin-right: 0.5rem;
            font-size: 0.9rem;
        }
        
        .section-number-text {
            font-weight: inherit;
        }
        
        .nomenclature-badge {
            display: inline-block;
            background: rgba(16, 185, 129, 0.8);
            color: white;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            font-weight: 500;
        }



        .section-controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .btn-add {
            background: linear-gradient(135deg, var(--success-green), #059669);
            color: white;
        }

        .btn-add-sub {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }

        .btn-delete {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        /* Images Grid */
        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            min-height: 100px;
            border: 2px dashed rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1rem;
            transition: all 0.3s ease;
        }

        .images-grid.dragover {
            border-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .image-card {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .image-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
        }

        .image-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 5;
        }

        .image-card:hover .image-overlay {
            opacity: 1;
            pointer-events: none; /* L'overlay ne doit pas capturer les √©v√©nements */
        }

        .image-card:hover .btn-assign {
            pointer-events: all; /* Seul le bouton capture les √©v√©nements */
        }

        .btn-zoom {
            position: absolute;
            top: 8px;
            left: 8px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(29, 78, 216, 0.9));
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            backdrop-filter: blur(8px);
            z-index: 10;
            pointer-events: all;
        }

        .btn-zoom:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.6);
            background: linear-gradient(135deg, #60a5fa, var(--accent-blue));
        }

        .image-card.selected {
            border: 2px solid var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            transform: scale(1.02);
        }

        .image-card.selected .image-preview {
            opacity: 0.8;
        }

        /* Animation pour d√©placement - masquer l'original */
        .image-card.being-dragged {
            opacity: 0.3;
            transform: scale(0.8);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .image-card.selected.being-dragged {
            opacity: 0.2;
            transform: scale(0.7);
        }

        /* Stack fant√¥me pour drag multiple */
        .drag-stack-container {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: none;
        }

        .drag-stack-image {
            position: absolute;
            width: 150px;
            height: 100px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-blue);
            transition: all 0.1s ease;
        }

        .drag-stack-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .drag-stack-image.stack-1 {
            transform: rotate(-2deg) translate(-5px, 5px);
            z-index: 10001;
        }

        .drag-stack-image.stack-2 {
            transform: rotate(1deg) translate(5px, 10px);
            z-index: 10002;
        }

        .drag-stack-image.stack-3 {
            transform: rotate(-1deg) translate(-3px, 15px);
            z-index: 10003;
        }

        .drag-stack-counter {
            position: absolute;
            top: -15px;
            right: -15px;
            background: var(--accent-blue);
            color: white;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.6);
            z-index: 10004;
        }

        .btn-assign {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, var(--accent-blue), #1d4ed8);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            backdrop-filter: blur(8px);
            z-index: 10;
            pointer-events: all;
        }

        .btn-assign:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.6);
            background: linear-gradient(135deg, #60a5fa, var(--accent-blue));
        }



        .image-preview {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }

        .image-info {
            padding: 0.75rem;
            background: rgba(15, 23, 42, 0.8);
        }

        .image-filename {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            word-break: break-word;
        }

        .image-page {
            font-size: 0.7rem;
            color: var(--accent-blue);
            font-weight: 600;
        }

        /* Stats Panel */
        .stats-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            text-align: center;
        }

        .stat-item {
            padding: 0.75rem;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-blue);
            display: block;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Modal Styles */
        .modal-content {
            background: var(--dark-blue);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(20px);
        }

        .modal-header, .modal-footer {
            border-color: rgba(59, 130, 246, 0.2);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .section-title {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            
            .images-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
            
            .stats-panel {
                position: relative;
                bottom: auto;
                right: auto;
                margin-top: 2rem;
            }
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-editor {
            animation: fadeInUp 0.5s ease-out;
        }

        /* Tooltips */
        [data-bs-toggle="tooltip"] {
            cursor: help;
        }
        
        /* Tips Box */
        .tips-box {
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            margin-top: 1rem;
            overflow: hidden;
            backdrop-filter: blur(16px);
        }
        
        .tips-header {
            background: rgba(59, 130, 246, 0.15);
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .tips-header:hover {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .tips-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .tips-title i {
            color: #fbbf24;
            font-size: 1rem;
        }
        
        .tips-title span {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .tips-chevron {
            color: var(--text-secondary);
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }
        
        .tips-chevron.rotated {
            transform: rotate(180deg);
        }
        
        .tips-content {
            padding: 0.75rem 1rem;
            max-height: 500px;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .tips-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .tip-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .tip-item:last-child {
            margin-bottom: 0;
        }
        
        .tip-item i {
            color: var(--accent-blue);
            font-size: 0.9rem;
            margin-top: 0.1rem;
            min-width: 1rem;
        }
        
        .tip-item span {
            color: var(--text-secondary);
        }
        
        /* Section Selector */
        .section-selector {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 1rem;
            max-height: 350px;
            overflow-y: auto;
            z-index: 1000;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .section-selector-header {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .section-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.2rem;
            font-size: 0.9rem;
            position: relative;
        }
        
        .section-option:hover {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .section-option:last-child {
            margin-bottom: 0;
        }
        
        .section-option-number {
            font-weight: 600;
            color: var(--accent-blue);
            min-width: 60px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-option-number i {
            font-size: 0.85rem;
            width: 1rem;
            text-align: center;
        }
        
        .section-option-label {
            color: var(--text-primary);
        }
        
        .section-option-level-2 {
            margin-left: 1.5rem;
            position: relative;
        }
        
        .section-option-level-2::before {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: 50%;
            width: 0.75rem;
            height: 1px;
            background: #8b5cf6;
            border-top: 1px solid #8b5cf6;
        }
        
        .section-option-level-2::after {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: -0.5rem;
            bottom: 50%;
            width: 1px;
            background: #8b5cf6;
        }
        
        /* Ligne verticale pour connecter les sous-sections */
        .section-option-level-2:not(:last-child)::after {
            bottom: -0.5rem;
        }
        
        .section-option-level-3 {
            margin-left: 3rem;
            position: relative;
        }
        
        .section-option-level-3::before {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: 50%;
            width: 0.75rem;
            height: 1px;
            background: #f59e0b;
            border-top: 1px solid #f59e0b;
        }
        
        .section-option-level-3::after {
            content: '';
            position: absolute;
            left: -1.25rem;
            top: -0.5rem;
            bottom: 50%;
            width: 1px;
            background: #f59e0b;
        }
        
        /* Ligne verticale pour connecter les sous-sous-sections */
        .section-option-level-3:not(:last-child)::after {
            bottom: -0.5rem;
        }
        
        /* Zone Images Non Attribu√©es */
        .unassigned-container {
            margin-bottom: 2rem;
        }
        
        .unassigned-card {
            border-left: 4px solid #f59e0b;
            background: rgba(245, 158, 11, 0.05);
        }
        
        .unassigned-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(245, 158, 11, 0.2);
        }
        
        .unassigned-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .unassigned-title i {
            color: #f59e0b;
            font-size: 1.2rem;
        }
        
        .unassigned-badge {
            background: #f59e0b;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 700;
            min-width: 30px;
            text-align: center;
        }

        /* Bouton Debug Flottant */
        .debug-button {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 22px;
            height: 22px;
            background: rgba(245, 158, 11, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 999;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.3);
        }

        .debug-button:hover {
            background: rgba(245, 158, 11, 1);
            transform: scale(1.1);
            box-shadow: 0 6px 24px rgba(245, 158, 11, 0.5);
        }

        /* Modal Debug */
        .debug-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .debug-modal-content {
            background: var(--dark-blue);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 16px;
            max-width: 800px;
            max-height: 80vh;
            width: 100%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .debug-modal-header {
            background: rgba(245, 158, 11, 0.15);
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(245, 158, 11, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .debug-modal-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .debug-modal-title i {
            color: #f59e0b;
            font-size: 1.2rem;
        }

        .debug-modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .debug-modal-close:hover {
            color: var(--text-primary);
            background: rgba(245, 158, 11, 0.2);
        }

        .debug-modal-body {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .debug-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(245, 158, 11, 0.05);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 8px;
        }

        .debug-section-title {
            font-size: 1rem;
            font-weight: 600;
            color: #f59e0b;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .debug-info {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .debug-info.error {
            color: #ef4444;
        }

        .debug-info.success {
            color: #10b981;
        }

        .debug-info.warning {
            color: #f59e0b;
        }

    </style>
</head>
<body>
    <div class="container-fluid px-4 py-3">


        <div class="row">
            <!-- Configuration Panel -->
            <div class="col-lg-3">
                <div class="config-panel">
                    <div class="glass-card">
                        <h5 class="mb-3"><i class="fas fa-cog me-2"></i>Configuration</h5>
                        
                        <div class="config-form">
                            <div class="form-group">
                                <label class="form-label">Pr√©fixe</label>
                                <input type="text" id="prefixInput" class="form-control" value="CLR" placeholder="CLR">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Nom du Document</label>
                                <input type="text" id="documentNameInput" class="form-control" value="{{ result.document_name }}" placeholder="Nom du document">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Format</label>
                                <select id="formatSelect" class="form-control">
                                    <option value="jpg">JPEG (.jpg)</option>
                                    <option value="png">PNG (.png)</option>
                                </select>
                            </div>
                        </div>
                        
                        <hr style="border-color: rgba(59, 130, 246, 0.2); margin: 1.5rem 0;">
                        
                        <div class="d-grid gap-2">
                            <button class="btn-glass" onclick="addNewSection()">
                                <i class="fas fa-plus"></i>
                                Ajouter Section
                            </button>
                            
                            <button class="btn-glass" onclick="toggleSelectAll()" id="selectAllBtn">
                                <i class="fas fa-check-square"></i>
                                <span id="selectAllText">Tout s√©lectionner</span>
                            </button>
                            
                            <button class="btn-glass" onclick="exportImages()">
                                <i class="fas fa-download"></i>
                                Exporter ZIP
                            </button>
                            
                            <a href="/" class="btn-glass text-center">
                                <i class="fas fa-arrow-left"></i>
                                Retour
                            </a>
                        </div>
                    </div>
                    
                    <!-- Tips Box - R√©tractable -->
                    <div class="tips-box">
                        <div class="tips-header" onclick="toggleTips()">
                            <div class="tips-title">
                                <i class="fas fa-lightbulb"></i>
                                <span>Conseils d'utilisation</span>
                            </div>
                            <i class="fas fa-chevron-down tips-chevron" id="tipsChevron"></i>
                        </div>
                        <div class="tips-content" id="tipsContent">
                            <div class="tip-item">
                                <i class="fas fa-plus-circle"></i>
                                <span>Utilisez le bouton violet sur une section pour cr√©er une sous-section</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-edit"></i>
                                <span>Cliquez sur la bo√Æte bleue du num√©ro pour modifier la nomenclature (ex: ANNEXE-A)</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-arrows-alt"></i>
                                <span>Glissez-d√©posez les sections par leur bo√Æte bleue pour les r√©organiser</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sections Editor -->
            <div class="col-lg-9">
                <!-- Zone Images Non Attribu√©es -->
                <div id="unassignedImagesContainer" class="unassigned-container" style="display: none;">
                    <div class="glass-card unassigned-card">
                        <div class="unassigned-header">
                            <div class="unassigned-title">
                                <i class="fas fa-inbox"></i>
                                <span>Images non attribu√©es</span>
                                <span id="unassignedBadge" class="unassigned-badge">0</span>
                            </div>
                        </div>
                        <div class="images-grid" id="unassignedGrid" data-section-id="unassigned">
                            <!-- Images non attribu√©es -->
                        </div>
                    </div>
                </div>
                
                <div id="sectionsContainer" class="sections-container">
                    <!-- Les sections seront g√©n√©r√©es par JavaScript -->
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="empty-state" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <h4>Aucune section cr√©√©e</h4>
                    <p>Cliquez sur "Ajouter Section" pour commencer</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <div class="glass-card">
            <div class="stats-grid">
                <div class="stat-item">
                    <span id="sectionsCount" class="stat-number">0</span>
                    <span class="stat-label">Sections</span>
                </div>
                <div class="stat-item">
                    <span id="imagesCount" class="stat-number">{{ result.total_images }}</span>
                    <span class="stat-label">Images</span>
                </div>
                <div class="stat-item">
                    <span id="selectedCount" class="stat-number">0</span>
                    <span class="stat-label">S√©lectionn√©es</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div class="modal fade" id="imageModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title text-white">Aper√ßu de l'image</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body text-center">
                    <img id="modalImage" src="" class="img-fluid rounded" style="max-height: 70vh;">
                </div>
                <div class="modal-footer">
                    <div id="modalImageInfo" class="text-white"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Button -->
    <div class="debug-button" onclick="showDebugModal()" title="Diagnostic du syst√®me">
        <i class="fas fa-bug"></i>
    </div>

    <!-- Debug Modal -->
    <div class="debug-modal" id="debugModal">
        <div class="debug-modal-content">
            <div class="debug-modal-header">
                <div class="debug-modal-title">
                    <i class="fas fa-bug"></i>
                    <span>Diagnostic du Syst√®me</span>
                </div>
                <button class="debug-modal-close" onclick="closeDebugModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="debug-modal-body" id="debugModalBody">
                <!-- Le contenu de debug sera ins√©r√© ici -->
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <script type="application/json" id="sectionsData">{{ result.sections | tojson | safe }}</script>
    <script type="application/json" id="imagesData">{{ result.extracted_files | tojson | safe }}</script>
    
    <script>
        // √âtat global de l'application
        let appState = {
            sections: [],
            unassignedImages: [],
            prefix: 'CLR',
            documentName: '{{ result.document_name }}',
            format: 'jpg',
            nextSectionId: 1,
            maxSubsectionId: {}  // Stocke le prochain ID de sous-section pour chaque section
        };

        // Images extraites du serveur
        let extractedImages = [];
        
        // Sections d√©tect√©es par le serveur
        let detectedSections = JSON.parse(document.getElementById('sectionsData').textContent);
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            logInfo('üöÄ Initialisation de DocuLens v2');
            setupEventListeners();
            loadImagesFromServer();
            lockDocumentNameAfterProcessing();
            setupDragStackMouseTracking();
            
            // Nettoyer les tooltips au chargement pour √©viter les r√©sidus
            setTimeout(() => {
                cleanupTooltips();
                logInfo('‚úÖ Initialisation termin√©e');
            }, 1000);
        });

        function initializeApp() {
            // Debug : afficher toutes les images extraites
            console.log('üñºÔ∏è Images extraites du serveur:', extractedImages.length);
            extractedImages.forEach((img, i) => {
                console.log(`  ${i+1}. ${img.filename} - Section: "${img.section}" - Page: ${img.page}`);
            });
            
            // Cr√©er les sections bas√©es sur la d√©tection automatique
            if (detectedSections && detectedSections.length > 0) {
                console.log('üîç Sections d√©tect√©es:', detectedSections.length);
                detectedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. Section "${section.number}" (niveau ${section.level || 1}) - Titre: "${section.title}"`);
                });
                
                // Trier les sections d√©tect√©es par ordre hi√©rarchique
                const sortedSections = [...detectedSections].sort((a, b) => {
                    return compareVersions(a.number, b.number);
                });
                
                console.log('üìã Ordre de cr√©ation des sections:');
                sortedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. ${section.number} (niveau ${section.level || 1})`);
                });
                
                // Cr√©er les sections selon l'ordre hi√©rarchique
                sortedSections.forEach((detectedSection, index) => {
                    const sectionName = detectedSection.title || `Section ${detectedSection.number}`;
                    const level = detectedSection.level || 1;
                    
                    // D√©terminer si c'est une sous-section et trouver le parent
                    let parentSectionId = null;
                    
                    if (level > 1 && detectedSection.number.includes('.')) {
                        const parentNumber = detectedSection.number.split('.')[0];
                        const parentSection = appState.sections.find(s => 
                            s.sectionNumber == parentNumber || s.nomenclatureNumber == parentNumber
                        );
                        if (parentSection) {
                            parentSectionId = parentSection.id;
                            console.log(`  üîó Section ${detectedSection.number} rattach√©e au parent ${parentNumber} (ID: ${parentSectionId})`);
                        } else {
                            console.warn(`  ‚ö†Ô∏è  Parent ${parentNumber} non trouv√© pour section ${detectedSection.number}`);
                        }
                    }
                    
                    const createdSection = addNewSection(sectionName, parentSectionId);
                    
                    if (createdSection) {
                        // Assigner les images de cette section
                        const sectionImages = extractedImages.filter(img => 
                            img.section === detectedSection.number.toString()
                        );
                        
                        createdSection.images = sectionImages;
                        createdSection.sectionNumber = detectedSection.number;
                        createdSection.nomenclatureNumber = detectedSection.number; // Par d√©faut, m√™me que le num√©ro de section
                        createdSection.level = level;
                        createdSection.isCustomNomenclature = false; // D√©tection automatique, pas personnalis√©e
                        console.log(`  üìÅ Section ${detectedSection.number}: ${sectionImages.length} images (niveau ${level})`);
                    }
                });
                
                // Forcer la renum√©ration finale et le rendu
                console.log('üî¢ Renum√©ration finale...');
                renumberSections(false); // Ne pas √©craser les nomenclatures personnalis√©es
                renderSections();
                updateUnassignedImages();
                debugImageAssignment();
            } else {
                // Fallback : cr√©er une section par d√©faut
                console.log('‚ö†Ô∏è  Aucune section d√©tect√©e, cr√©ation d\'une section par d√©faut');
                if (extractedImages.length > 0) {
                    addNewSection('Section 1');
                    appState.sections[0].images = [...extractedImages];
                    renderSections();
                    updateUnassignedImages();
                }
            }
            updateStats();
        }
        
        function debugImageAssignment() {
            console.log('üîç DEBUG - √âtat apr√®s initialisation:');
            console.log(`  Total images extraites: ${extractedImages.length}`);
            
            let debugInfo = {
                totalExtracted: extractedImages.length,
                sections: [],
                totalAssigned: 0,
                unassigned: appState.unassignedImages.length,
                problems: []
            };
            
            // Analyser chaque section
            appState.sections.forEach(section => {
                const sectionInfo = {
                    number: section.sectionNumber,
                    nomenclature: section.nomenclatureNumber,
                    level: section.level,
                    imageCount: section.images.length,
                    images: section.images.map(img => img.filename)
                };
                debugInfo.sections.push(sectionInfo);
                debugInfo.totalAssigned += section.images.length;
                console.log(`  Section ${section.sectionNumber}: ${section.images.length} images`);
            });
            
            console.log(`  Images assign√©es total: ${debugInfo.totalAssigned}`);
            console.log(`  Images non attribu√©es: ${debugInfo.unassigned}`);
            console.log(`  Diff√©rence: ${debugInfo.totalExtracted - debugInfo.totalAssigned - debugInfo.unassigned}`);
            
            // V√©rifier les probl√®mes
            if (debugInfo.totalExtracted !== debugInfo.totalAssigned + debugInfo.unassigned) {
                console.error('‚ùå PROBL√àME: Des images sont perdues!');
                
                // Trouver les images perdues
                const assignedFilenames = new Set();
                appState.sections.forEach(section => {
                    section.images.forEach(img => assignedFilenames.add(img.filename));
                });
                appState.unassignedImages.forEach(img => assignedFilenames.add(img.filename));
                
                const lostImages = extractedImages.filter(img => !assignedFilenames.has(img.filename));
                debugInfo.problems.push({
                    type: 'error',
                    message: 'Images perdues d√©tect√©es',
                    details: lostImages
                });
                console.error('Images perdues:', lostImages);
            }
            
            return debugInfo;
        }
        
        function showDebugModal() {
            const debugData = debugImageAssignment();
            const modalBody = document.getElementById('debugModalBody');
            
            let html = `
                <div class="debug-section">
                    <div class="debug-section-title">
                        <i class="fas fa-chart-bar"></i>
                        R√©sum√© Global
                    </div>
                    <div class="debug-info">Total images extraites: <strong>${debugData.totalExtracted}</strong></div>
                    <div class="debug-info">Images assign√©es: <strong>${debugData.totalAssigned}</strong></div>
                    <div class="debug-info">Images non attribu√©es: <strong>${debugData.unassigned}</strong></div>
                    <div class="debug-info ${debugData.totalExtracted === debugData.totalAssigned + debugData.unassigned ? 'success' : 'error'}">
                        √âtat: ${debugData.totalExtracted === debugData.totalAssigned + debugData.unassigned ? '‚úÖ Toutes les images sont comptabilis√©es' : '‚ùå Des images sont perdues!'}
                    </div>
                </div>
                
                <div class="debug-section">
                    <div class="debug-section-title">
                        <i class="fas fa-list"></i>
                        Sections D√©tect√©es (${debugData.sections.length})
                    </div>
            `;
            
            debugData.sections.forEach(section => {
                const levelIcon = section.level === 1 ? '<i class="fas fa-book"></i>' : section.level === 2 ? '<i class="fas fa-file-alt"></i>' : '<i class="fas fa-sticky-note"></i>';
                const indent = '&nbsp;&nbsp;'.repeat((section.level - 1) * 2);
                html += `
                    <div class="debug-info">
                        ${indent}${levelIcon} Section ${section.number} 
                        ${section.nomenclature !== section.number ? `(‚Üí ${section.nomenclature})` : ''}
                        - <strong>${section.imageCount} images</strong>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Ajouter les images non attribu√©es si il y en a
            if (debugData.unassigned > 0) {
                html += `
                    <div class="debug-section">
                        <div class="debug-section-title">
                            <i class="fas fa-inbox"></i>
                            Images Non Attribu√©es (${debugData.unassigned})
                        </div>
                `;
                appState.unassignedImages.forEach(img => {
                    html += `<div class="debug-info">üìÑ ${img.filename} (Page ${img.page})</div>`;
                });
                html += '</div>';
            }
            
            // Ajouter les probl√®mes s'il y en a
            if (debugData.problems.length > 0) {
                html += `
                    <div class="debug-section">
                        <div class="debug-section-title">
                            <i class="fas fa-exclamation-triangle"></i>
                            Probl√®mes D√©tect√©s
                        </div>
                `;
                debugData.problems.forEach(problem => {
                    html += `<div class="debug-info ${problem.type}">${problem.message}</div>`;
                    if (problem.details && problem.details.length > 0) {
                        problem.details.forEach(detail => {
                            html += `<div class="debug-info">&nbsp;&nbsp;‚Ä¢ ${typeof detail === 'string' ? detail : detail.filename}</div>`;
                        });
                    }
                });
                html += '</div>';
            }
            
            // Ajouter la section des logs r√©cents
            html += `
                <div class="debug-section">
                    <div class="debug-section-title">
                        <i class="fas fa-list-ul"></i>
                        Logs R√©cents (${appLogs.length} entr√©es)
                                                 <button class="debug-clear-logs" onclick="clearLogs()" style="margin-left: 1rem; background: rgba(239, 68, 68, 0.8); border: none; border-radius: 4px; padding: 0.25rem 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                             <i class="fas fa-trash"></i> Vider
                         </button>
                         <button class="debug-diagnose" onclick="diagnoseSelectionIssue()" style="margin-left: 0.5rem; background: rgba(59, 130, 246, 0.8); border: none; border-radius: 4px; padding: 0.25rem 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                             <i class="fas fa-stethoscope"></i> Diagnostiquer
                         </button>
                         <button class="debug-sync" onclick="syncSelectionStateWithDOM()" style="margin-left: 0.5rem; background: rgba(16, 185, 129, 0.8); border: none; border-radius: 4px; padding: 0.25rem 0.5rem; color: white; font-size: 0.8rem; cursor: pointer;">
                             <i class="fas fa-sync-alt"></i> Sync DOM
                         </button>
                    </div>
                    <div class="debug-logs-container" style="max-height: 200px; overflow-y: auto; background: rgba(15, 23, 42, 0.5); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 6px; padding: 0.75rem; margin-top: 0.5rem;">
            `;
            
            if (appLogs.length === 0) {
                html += `<div class="debug-info" style="font-style: italic; opacity: 0.7;">Aucun log disponible</div>`;
            } else {
                appLogs.slice(0, 20).forEach(log => {
                    const iconClass = log.type === 'error' ? 'fas fa-exclamation-circle' : 
                                     log.type === 'info' ? 'fas fa-info-circle' : 'fas fa-bug';
                    const typeClass = log.type === 'error' ? 'error' : log.type === 'info' ? 'success' : '';
                    
                    html += `
                        <div class="debug-info ${typeClass}" style="margin-bottom: 0.5rem; padding: 0.25rem; border-left: 2px solid ${log.type === 'error' ? '#ef4444' : log.type === 'info' ? '#10b981' : '#f59e0b'};">
                            <span style="color: var(--text-secondary); font-size: 0.8rem;">[${log.time}]</span>
                            <i class="${iconClass}" style="margin: 0 0.5rem; color: ${log.type === 'error' ? '#ef4444' : log.type === 'info' ? '#10b981' : '#f59e0b'};"></i>
                            ${log.message}
                            ${log.data ? `<br><span style="margin-left: 2rem; opacity: 0.8; font-size: 0.9em;">${log.data}</span>` : ''}
                        </div>
                    `;
                });
                
                if (appLogs.length > 20) {
                    html += `<div class="debug-info" style="font-style: italic; opacity: 0.7; text-align: center;">... et ${appLogs.length - 20} logs plus anciens</div>`;
                }
            }
            
            html += '</div></div>';
            
            modalBody.innerHTML = html;
            document.getElementById('debugModal').style.display = 'flex';
        }
        
        function closeDebugModal() {
            document.getElementById('debugModal').style.display = 'none';
        }
        
        function clearLogs() {
            appLogs = [];
            logInfo('Logs vid√©s manuellement');
            // Rafra√Æchir la modal si elle est ouverte
            if (document.getElementById('debugModal').style.display === 'flex') {
                showDebugModal();
            }
        }
        
        function syncSelectionStateWithDOM() {
            logDebug('üîÑ Synchronisation DOM avec √©tat de s√©lection...');
            
            let syncCount = 0;
            const allImageCards = document.querySelectorAll('.image-card');
            
            allImageCards.forEach(card => {
                const filename = card.dataset.imageFilename;
                const shouldBeSelected = selectedImages.has(filename);
                const isCurrentlySelected = card.classList.contains('selected');
                
                if (shouldBeSelected && !isCurrentlySelected) {
                    card.classList.add('selected');
                    syncCount++;
                    logDebug(`‚úÖ Classe 'selected' ajout√©e √† ${filename}`);
                } else if (!shouldBeSelected && isCurrentlySelected) {
                    card.classList.remove('selected');
                    syncCount++;
                    logDebug(`‚ùå Classe 'selected' supprim√©e de ${filename}`);
                }
            });
            
            if (syncCount > 0) {
                logInfo(`üîÑ ${syncCount} images synchronis√©es avec l'√©tat de s√©lection`);
            }
        }
        
        function diagnoseSelectionIssue() {
            logInfo('=== DIAGNOSTIC COMPLET DE LA S√âLECTION ===');
            
            // V√©rifier l'√©tat des s√©lections
            logInfo(`Images s√©lectionn√©es en m√©moire: ${selectedImages.size}`);
            selectedImages.forEach(filename => {
                logInfo(`  - ${filename}`);
            });
            
            // V√©rifier l'√©tat dans le DOM
            const allImageCards = document.querySelectorAll('.image-card');
            logInfo(`Images totales dans le DOM: ${allImageCards.length}`);
            
            let domSelectedCount = 0;
            allImageCards.forEach((card, index) => {
                const filename = card.dataset.imageFilename;
                const hasSelectedClass = card.classList.contains('selected');
                const isInMemory = selectedImages.has(filename);
                
                if (hasSelectedClass) domSelectedCount++;
                
                if (hasSelectedClass !== isInMemory) {
                    logError(`Incoh√©rence d√©tect√©e - ${filename}: DOM=${hasSelectedClass}, M√©moire=${isInMemory}`);
                }
                
                // Log d√©taill√© pour chaque section
                const sectionEl = card.closest('[data-section-id]');
                const sectionId = sectionEl ? sectionEl.dataset.sectionId : 'inconnu';
                
                logDebug(`Image ${index + 1}: ${filename} | Section: ${sectionId} | DOM selected: ${hasSelectedClass} | Memory: ${isInMemory}`);
            });
            
            logInfo(`Images s√©lectionn√©es dans le DOM: ${domSelectedCount}`);
            
            if (domSelectedCount !== selectedImages.size) {
                logError(`PROBL√àME: ${selectedImages.size} en m√©moire vs ${domSelectedCount} dans le DOM`);
            }
            
            logInfo('=== FIN DIAGNOSTIC ===');
        }
        
        // Fermer la modal debug en cliquant en dehors
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('debugModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeDebugModal();
                }
            });
        });

        function setupEventListeners() {
            // Configuration inputs
            document.getElementById('prefixInput').addEventListener('input', (e) => {
                appState.prefix = e.target.value || 'CLR';
                updateAllFilenames();
            });
            
            document.getElementById('documentNameInput').addEventListener('input', (e) => {
                // Ne pas permettre de changer le nom du document apr√®s traitement
                // car cela casserait les URLs des images
                console.warn('Changement du nom de document d√©sactiv√© apr√®s traitement');
            });
            
            document.getElementById('formatSelect').addEventListener('change', (e) => {
                appState.format = e.target.value;
                updateAllFilenames();
            });
        }
        
        function lockDocumentNameAfterProcessing() {
            const documentNameInput = document.getElementById('documentNameInput');
            if (documentNameInput) {
                documentNameInput.disabled = true;
                documentNameInput.style.opacity = '0.6';
                documentNameInput.style.cursor = 'not-allowed';
                documentNameInput.title = 'Le nom du document ne peut pas √™tre modifi√© apr√®s traitement';
                
                // Ajouter une ic√¥ne de cadenas
                const parent = documentNameInput.parentElement;
                const lockIcon = document.createElement('i');
                lockIcon.className = 'fas fa-lock';
                lockIcon.style.position = 'absolute';
                lockIcon.style.right = '10px';
                lockIcon.style.top = '50%';
                lockIcon.style.transform = 'translateY(-50%)';
                lockIcon.style.color = 'var(--text-secondary)';
                lockIcon.style.pointerEvents = 'none';
                parent.style.position = 'relative';
                parent.appendChild(lockIcon);
            }
        }

        function loadImagesFromServer() {
            // Utiliser les images extraites directement du template
            const extractedFiles = JSON.parse(document.getElementById('imagesData').textContent);
            
            // Convertir les donn√©es du serveur au format attendu par le client
            extractedImages = extractedFiles.map(file => ({
                filename: file.filename,
                section: file.section,
                page: file.page,
                image_number: file.image_number
            }));
            
            console.log('üìä Images charg√©es:', extractedImages.length, 'images');
            console.log('üìä Premi√®re image:', extractedImages[0]);
            
            appState.unassignedImages = [...extractedImages];
            initializeApp();
            updateStats();
        }

        function addNewSection(name = null, parentSectionId = null, afterSectionId = null) {
            try {
                let sectionNumber, sectionName, level, nomenclatureNumber;
                let insertIndex = appState.sections.length; // Par d√©faut, √† la fin
                
                logInfo(`Ajout nouvelle section - name: "${name}", parent: ${parentSectionId}, after: ${afterSectionId}`);
            
            if (parentSectionId) {
                // Cr√©er une sous-section ou sous-sous-section
                const parentSection = appState.sections.find(s => s.id === parentSectionId);
                if (!parentSection) {
                    console.error(`‚ùå Section parent ${parentSectionId} introuvable`);
                    return;
                }
                
                const parentNumber = parentSection.sectionNumber || parentSection.number;
                
                // Initialiser le compteur de sous-sections pour cette section parent
                if (!appState.maxSubsectionId[parentNumber]) {
                    appState.maxSubsectionId[parentNumber] = 1;
                } else {
                    appState.maxSubsectionId[parentNumber]++;
                }
                
                sectionNumber = `${parentNumber}.${appState.maxSubsectionId[parentNumber]}`;
                level = (parentSection.level || 1) + 1;
                nomenclatureNumber = sectionNumber; // Par d√©faut, m√™me que le num√©ro hi√©rarchique
                
                sectionName = name || `Section ${sectionNumber}`;
                
                // Position pour sous-section : apr√®s le parent et ses sous-sections existantes
                const parentIndex = appState.sections.findIndex(s => s.id === parentSectionId);
                insertIndex = parentIndex + 1;
                
                // Trouver la position apr√®s toutes les sous-sections existantes du parent
                while (insertIndex < appState.sections.length && 
                       appState.sections[insertIndex].parentId === parentSectionId) {
                    insertIndex++;
                }
            } else if (afterSectionId) {
                // Cr√©er une section principale apr√®s une section sp√©cifique
                const afterSection = appState.sections.find(s => s.id === afterSectionId);
                if (afterSection) {
                    const afterIndex = appState.sections.findIndex(s => s.id === afterSectionId);
                    insertIndex = afterIndex + 1;
                    
                    // Si la section apr√®s laquelle on ins√®re a des sous-sections, ins√©rer apr√®s toutes ses sous-sections
                    while (insertIndex < appState.sections.length && 
                           (appState.sections[insertIndex].parentId === afterSectionId ||
                            (appState.sections[insertIndex].level > 1 && 
                             appState.sections[insertIndex].sectionNumber && 
                             appState.sections[insertIndex].sectionNumber.startsWith(afterSection.sectionNumber + '.')))) {
                        insertIndex++;
                    }
                }
                
                // Le num√©ro sera d√©termin√© apr√®s insertion et renum√©ration
                level = 1;
                sectionName = name || `Section temporaire`;
                nomenclatureNumber = "temp";
            } else {
                // Cr√©er une section principale √† la fin ou lors de l'initialisation
                const mainSections = appState.sections.filter(s => (s.level || 1) === 1);
                if (name && name.includes('Section ') && !isNaN(parseInt(name.split(' ')[1]))) {
                    // Si un nom avec num√©ro est fourni, l'utiliser
                    const providedNumber = parseInt(name.split(' ')[1]);
                    sectionNumber = providedNumber;
                } else {
                    sectionNumber = mainSections.length + 1;
                }
                sectionName = name || `Section ${sectionNumber}`;
                nomenclatureNumber = sectionNumber.toString();
                level = 1;
            }
            
            const newSection = {
                id: appState.nextSectionId++,
                name: sectionName,
                number: insertIndex + 1,                    // Position dans la liste (sera mise √† jour)
                sectionNumber: sectionNumber,               // Num√©ro hi√©rarchique (sera mis √† jour si n√©cessaire)
                nomenclatureNumber: nomenclatureNumber,     // Num√©ro utilis√© dans la nomenclature des fichiers
                level: level,
                parentId: parentSectionId,
                images: []
            };
            
            console.log(`  üìù Section cr√©√©e: "${newSection.name}" (n¬∞${newSection.sectionNumber}, niveau ${newSection.level})`);
            
            // Ins√©rer la section √† la position calcul√©e
            appState.sections.splice(insertIndex, 0, newSection);
            
            // Ne pas renumb√©roter automatiquement lors de l'initialisation pour pr√©server les num√©ros d√©tect√©s
            if (!name || !name.includes('Section ')) {
                renumberSections(true);
            }
            
            // Toujours faire le rendu et mettre √† jour les stats apr√®s ajout
            renderSections();
            updateStats();
            updateUnassignedImages();
            
            return newSection;
            } catch (error) {
                logError('Erreur lors de l\'ajout de section:', error);
                return null;
            }
        }
        
                 function renumberSections(isAutomaticRename = true) {
             let mainSectionCount = 1;
             const subsectionCounters = {};
             
             appState.sections.forEach((section, index) => {
                 section.number = index + 1; // Position dans la liste
                 
                 if (section.level === 1) {
                     const oldSectionNumber = section.sectionNumber;
                     section.sectionNumber = mainSectionCount.toString();
                     
                     // Mise √† jour automatique de la nomenclature seulement si c'est un rename automatique
                     if (isAutomaticRename && (!section.nomenclatureNumber || 
                         section.nomenclatureNumber === oldSectionNumber || 
                         section.nomenclatureNumber === (mainSectionCount - 1).toString() || 
                         section.nomenclatureNumber === "temp")) {
                         section.nomenclatureNumber = mainSectionCount.toString();
                         section.isCustomNomenclature = false; // Flag pour indiquer que ce n'est pas personnalis√©
                     } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                         section.isCustomNomenclature = true; // Flag pour indiquer une personnalisation
                     }
                     
                     // Mettre √† jour le nom si c'√©tait temporaire
                     if (section.name === "Section temporaire") {
                         section.name = `Section ${mainSectionCount}`;
                     }
                     subsectionCounters[mainSectionCount] = 1;
                     mainSectionCount++;
                 } else if (section.level === 2 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise √† jour automatique seulement si appropri√©
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                         subsectionCounters[section.sectionNumber] = 1;
                     }
                 } else if (section.level === 3 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise √† jour automatique seulement si appropri√©
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                     }
                 }
             });
         }

        function deleteSection(sectionId) {
            const sectionIndex = appState.sections.findIndex(s => s.id === sectionId);
            if (sectionIndex !== -1) {
                const sectionToDelete = appState.sections[sectionIndex];
                
                // Supprimer aussi toutes les sous-sections de cette section
                const sectionsToDelete = [sectionToDelete];
                if (sectionToDelete.level === 1) {
                    const subsections = appState.sections.filter(s => s.parentId === sectionId);
                    sectionsToDelete.push(...subsections);
                }
                
                // Remettre toutes les images dans unassigned
                sectionsToDelete.forEach(section => {
                    appState.unassignedImages.push(...section.images);
                });
                
                // Supprimer les sections
                sectionsToDelete.forEach(section => {
                    const index = appState.sections.findIndex(s => s.id === section.id);
                    if (index !== -1) {
                        appState.sections.splice(index, 1);
                    }
                });
                
                // Renumb√©roter les sections (automatique)
                renumberSections(true);
                renderSections();
                updateStats();
                updateAllFilenames();
            }
        }

                function cleanupTooltips() {
            // Supprimer tous les tooltips existants pour √©viter les doublons
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                tooltip.remove();
            });
            
            // Disposer des instances Bootstrap Tooltip existantes
            document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(element => {
                const tooltipInstance = bootstrap.Tooltip.getInstance(element);
                if (tooltipInstance) {
                    tooltipInstance.dispose();
                }
            });
        }

        function renderSections() {
            const container = document.getElementById('sectionsContainer');
            const emptyState = document.getElementById('emptyState');
            
            if (appState.sections.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            
            // Organiser les sections par hi√©rarchie
            const organizedHTML = buildHierarchicalSections(appState.sections);
            container.innerHTML = organizedHTML;
            
            // Forcer la synchronisation de l'√©tat de s√©lection
            syncSelectionStateWithDOM();
            
            // Initialiser les zones de drop
            setupSortable();
            
            // Nettoyer les anciens tooltips pour √©viter les doublons
            cleanupTooltips();
            
            // Activer les nouveaux tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }
        
        function buildHierarchicalSections(sections) {
            let html = '';
            
            // Filtrer les sections principales (niveau 1)
            const mainSections = sections.filter(s => (s.level || 1) === 1);
            
            mainSections.forEach(mainSection => {
                html += renderMainSection(mainSection, sections);
            });
            
            return html;
        }
        
                function renderMainSection(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            const nomenclatureNumber = mainSection.nomenclatureNumber || sectionNumber;
            
            // Trouver toutes les sous-sections de cette section principale et les organiser hi√©rarchiquement
            const subsections = getOrderedSubsections(mainSection, allSections);
            
            let html = `
            <div class="section-group-wrapper">
                ${renderSectionCard(mainSection, subsections)}
            </div>
            `;
            
            return html;
        }
        
        function getOrderedSubsections(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            
            // R√©cup√©rer toutes les sections qui appartiennent √† cette section principale
            const relatedSections = allSections.filter(s => 
                s.level > 1 && 
                s.sectionNumber && 
                s.sectionNumber.startsWith(sectionNumber + '.')
            );
            
            // Trier par num√©ro de section pour respecter l'ordre hi√©rarchique
            relatedSections.sort((a, b) => {
                return compareVersions(a.sectionNumber, b.sectionNumber);
            });
            
            return relatedSections;
        }
        
        function compareVersions(a, b) {
            const aParts = a.split('.').map(Number);
            const bParts = b.split('.').map(Number);
            
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const aPart = aParts[i] || 0;
                const bPart = bParts[i] || 0;
                
                if (aPart !== bPart) {
                    return aPart - bPart;
                }
            }
            
            return 0;
        }
        
        function renderHierarchicalSubsections(subsections) {
            let html = '';
            let currentLevel2Section = null;
            let level3Sections = [];
            
            for (let i = 0; i < subsections.length; i++) {
                const section = subsections[i];
                
                if (section.level === 2) {
                    // Si on avait une section niveau 2 en cours, on la rend avec ses sous-sections niveau 3
                    if (currentLevel2Section) {
                        html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
                        level3Sections = [];
                    }
                    currentLevel2Section = section;
                } else if (section.level === 3 && currentLevel2Section) {
                    // Ajouter cette sous-sous-section √† la liste de la section niveau 2 courante
                    level3Sections.push(section);
                } else {
                    // Section orpheline, la rendre directement
                    html += renderSectionCard(section);
                }
            }
            
            // Traiter la derni√®re section niveau 2 s'il y en a une
            if (currentLevel2Section) {
                html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
            }
            
            return html;
        }
        
        function renderSectionWithSubsections(level2Section, level3Sections) {
            let html = renderSectionCard(level2Section);
            
            if (level3Sections.length > 0) {
                html += '<div class="sub-sub-sections-container">';
                html += level3Sections.map(sub => renderSectionCard(sub)).join('');
                html += '</div>';
            }
            
            return html;
        }
        
        function renderSectionCard(section, subsections = []) {
            const level = section.level || 1;
            const sectionNumber = section.sectionNumber || section.number;
            const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
            const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
            
            // Classes CSS selon le niveau
            let cardClass = 'section-editor glass-card';
            if (level === 1) {
                cardClass += subsections.length > 0 ? ' main-section-with-subs' : ' main-section';
            } else if (level === 2) {
                cardClass += ' sub-section';
            } else {
                cardClass += ' sub-sub-section';
            }
            
            return `
            <div class="${cardClass}" data-section-id="${section.id}">
                <div class="section-header">
                    <div class="section-title">
                        <div class="section-number" title="Cliquez pour modifier la nomenclature (actuellement: ${nomenclatureNumber})" 
                             onclick="editNomenclature(${section.id}, '${nomenclatureNumber}', this)">
                            ${levelIcon} <span class="section-number-text">${sectionNumber}</span>
                            ${section.isCustomNomenclature && nomenclatureNumber !== sectionNumber ? `<span class="nomenclature-badge">‚Üí ${nomenclatureNumber}</span>` : ''}
                        </div>
                    </div>
                    <div class="section-controls">
                        ${level < 3 ? `
                            <button class="btn-icon btn-add-sub" onclick="addNewSection(null, ${section.id})" 
                                    data-bs-toggle="tooltip" title="Ajouter une ${level === 1 ? 'sous-section' : 'sous-sous-section'}">
                                <i class="fas fa-plus-circle"></i>
                            </button>
                        ` : ''}
                        <button class="btn-icon btn-delete" onclick="deleteSection(${section.id})"
                                data-bs-toggle="tooltip" title="Supprimer cette ${level === 1 ? 'section' : level === 2 ? 'sous-section' : 'sous-sous-section'}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="images-grid" data-section-id="${section.id}">
                    ${section.images.map((image, index) => renderImageCard(image, nomenclatureNumber, index + 1)).join('')}
                    ${section.images.length === 0 ? '<div class="empty-state"><i class="fas fa-images"></i><p>Glissez des images ici</p></div>' : ''}
                </div>
                
                ${level === 1 && subsections.length > 0 ? `
                    <div class="subsections-container">
                        ${renderHierarchicalSubsections(subsections)}
                    </div>
                ` : ''}
            </div>
            `;
        }

        function renderImageCard(image, sectionNumber, imageNumber) {
            const filename = generateFilename(sectionNumber, imageNumber);
            const isSelected = selectedImages.has(image.filename);
            
            // Log d√©taill√© pour le diagnostic
            logDebug(`Rendu image: ${image.filename} | G√©n√©r√©: ${filename} | S√©lectionn√©e: ${isSelected}`);
            
            if (isSelected) {
                logDebug(`‚úÖ Image s√©lectionn√©e √† rendre: ${image.filename} dans section ${sectionNumber}`);
            }
            
            return `
                <div class="image-card ${isSelected ? 'selected' : ''}" data-image-filename="${image.filename}" onclick="toggleImageSelectionByClick('${image.filename}')">
                    <img src="/image/${appState.documentName}/${image.filename}" 
                         alt="${image.filename}" class="image-preview" 
                         onerror="this.style.display='none'">
                    <div class="image-overlay">
                        <button class="btn-zoom" onclick="showImagePreview('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Agrandir l'image">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button class="btn-assign" onclick="showSectionSelector('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Assigner √† une section">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                    <div class="image-info">
                        <div class="image-filename">${filename}</div>
                        <div class="image-page">Page ${image.page}</div>
                    </div>
                </div>
            `;
        }

        function setupSortable() {
            // Sortable pour les grilles d'images
            document.querySelectorAll('.images-grid').forEach(grid => {
                new Sortable(grid, {
                    group: 'images',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    onStart: function(evt) {
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const totalImages = isSelected ? selectedImages.size : (selectedImages.size > 0 ? selectedImages.size + 1 : 1);
                        
                        // Marquer les images comme √©tant dragg√©es (les masquer)
                        markImagesAsBeingDragged(imageFilename);
                        
                        // Cr√©er le stack visuel si multiple images
                        if (totalImages > 1) {
                            // Position initiale
                            const rect = evt.item.getBoundingClientRect();
                            createDragStack(imageFilename, rect.left + rect.width/2, rect.top + rect.height/2);
                        }
                    },
                    onMove: function(evt) {
                        // Mettre √† jour la position du stack pendant le drag
                        if (isDraggingMultiple && dragStackContainer) {
                            const rect = evt.related.getBoundingClientRect();
                            updateDragStackPosition(rect.left, rect.top);
                        }
                    },
                    onAdd: function(evt) {
                        const sectionId = parseInt(evt.to.dataset.sectionId);
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const dropIndex = evt.newIndex;
                        
                        // Pr√©parer la liste des images √† d√©placer dans le bon ordre d'origine
                        const imagesToMove = [];
                        
                        // Si l'image dragu√©e n'√©tait pas s√©lectionn√©e, elle va en premier
                        if (!isSelected) {
                            imagesToMove.push(imageFilename);
                        }
                        
                        // Ajouter les images s√©lectionn√©es dans l'ordre qu'elles avaient dans leur section d'origine
                        const selectedInOrder = getSelectedImagesInSourceOrder();
                        imagesToMove.push(...selectedInOrder);
                        
                        // D√©placer les images en pr√©servant l'ordre et la position
                        moveImagesToSectionAtPosition(imagesToMove, sectionId, dropIndex);
                        
                        clearSelection();
                        renderSections();
                        updateUnassignedImages();
                    },
                    onUpdate: function(evt) {
                        // R√©organisation dans la m√™me section
                        const sectionId = parseInt(evt.from.dataset.sectionId);
                        if (sectionId && !isNaN(sectionId)) {
                            reorderImagesInSection(sectionId);
                        }
                        updateUnassignedImages();
                    },
                    onEnd: function(evt) {
                        // Nettoyer le stack et les √©tats de drag
                        removeDragStack();
                        unmarkImagesAsBeingDragged();
                    }
                });
            });
            
            // Sortable pour les groupes de sections principales
            const sectionsContainer = document.getElementById('sectionsContainer');
            if (sectionsContainer) {
                new Sortable(sectionsContainer, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '[class*="main-section"] .section-number', // Seules les sections principales peuvent √™tre d√©plac√©es
                    onEnd: function(evt) {
                        // R√©organiser les sections selon le nouvel ordre des groupes
                        rebuildSectionsOrderFromDOM();
                        
                        // Renum√©ration automatique apr√®s d√©placement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            }
            
            // Sortable pour les sous-sections dans leurs containers
            document.querySelectorAll('.subsections-container').forEach(container => {
                new Sortable(container, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '.section-number', // Sous-sections peuvent √™tre r√©organis√©es entre elles
                    onEnd: function(evt) {
                        // R√©organiser les sous-sections
                        rebuildSectionsOrderFromDOM();
                        
                        // Renum√©ration automatique apr√®s d√©placement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            });
        }
        
        function rebuildSectionsOrderFromDOM() {
            const newOrder = [];
            
            // Parcourir chaque wrapper de section
            document.querySelectorAll('.section-group-wrapper').forEach(wrapper => {
                // Ajouter la section principale
                const mainSectionEl = wrapper.querySelector('.main-section, .main-section-with-subs');
                if (mainSectionEl) {
                    const mainSectionId = parseInt(mainSectionEl.dataset.sectionId);
                    const mainSection = appState.sections.find(s => s.id === mainSectionId);
                    if (mainSection) {
                        newOrder.push(mainSection);
                    }
                    
                    // Ajouter les sous-sections dans l'ordre
                    const subsectionsContainer = mainSectionEl.querySelector('.subsections-container');
                    if (subsectionsContainer) {
                        // Parcourir dans l'ordre : sous-sections niveau 2, puis leurs sous-sections niveau 3
                        subsectionsContainer.querySelectorAll('.sub-section').forEach(subEl => {
                            const subSectionId = parseInt(subEl.dataset.sectionId);
                            const subSection = appState.sections.find(s => s.id === subSectionId);
                            if (subSection) {
                                newOrder.push(subSection);
                                
                                // Ajouter les sous-sous-sections de cette sous-section
                                const subSubContainer = subEl.nextElementSibling;
                                if (subSubContainer && subSubContainer.classList.contains('sub-sub-sections-container')) {
                                    subSubContainer.querySelectorAll('.sub-sub-section').forEach(subSubEl => {
                                        const subSubSectionId = parseInt(subSubEl.dataset.sectionId);
                                        const subSubSection = appState.sections.find(s => s.id === subSubSectionId);
                                        if (subSubSection) {
                                            newOrder.push(subSubSection);
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
            });
            
            appState.sections = newOrder;
        }

        function moveImageToSection(imageFilename, targetSectionId) {
            // Trouver l'image
            let image = null;
            let sourceSection = null;
            
            // Chercher dans unassigned
            const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === imageFilename);
            if (unassignedIndex !== -1) {
                image = appState.unassignedImages.splice(unassignedIndex, 1)[0];
            } else {
                // Chercher dans les sections
                for (let section of appState.sections) {
                    const imageIndex = section.images.findIndex(img => img.filename === imageFilename);
                    if (imageIndex !== -1) {
                        image = section.images.splice(imageIndex, 1)[0];
                        sourceSection = section;
                        break;
                    }
                }
            }
            
            if (image) {
                if (targetSectionId === 'unassigned') {
                    // Remettre dans les non attribu√©es
                    appState.unassignedImages.push(image);
                } else {
                    // Ajouter √† la section cible
                    const targetSection = appState.sections.find(s => s.id === targetSectionId);
                    if (targetSection) {
                        targetSection.images.push(image);
                    }
                }
                updateStats();
                updateAllFilenames();
            }
        }
        
        function moveImagesToSectionAtPosition(imageFilenames, targetSectionId, insertIndex) {
            console.log(`üì¶ D√©placement group√© de ${imageFilenames.length} images vers section ${targetSectionId} √† l'index ${insertIndex}`);
            
            // Collecter toutes les images dans l'ordre fourni (qui respecte l'ordre d'origine)
            const imagesToMove = [];
            
            // Pour chaque nom de fichier dans l'ordre fourni, trouver et collecter l'image
            imageFilenames.forEach(filename => {
                let image = null;
                
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    image = appState.unassignedImages[unassignedIndex];
                    if (image) imagesToMove.push(image);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            image = section.images[imageIndex];
                            if (image) imagesToMove.push(image);
                            break;
                        }
                    }
                }
            });
            
            // Maintenant supprimer les images de leurs positions actuelles
            // Supprimer dans l'ordre inverse pour √©viter les d√©calages d'index
            imageFilenames.slice().reverse().forEach(filename => {
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    appState.unassignedImages.splice(unassignedIndex, 1);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            section.images.splice(imageIndex, 1);
                            break;
                        }
                    }
                }
            });
            
            console.log(`  üìã ${imagesToMove.length} images collect√©es pour d√©placement (ordre pr√©serv√©)`);
            
            if (imagesToMove.length === 0) return;
            
            if (targetSectionId === 'unassigned') {
                // Ajouter toutes les images aux non attribu√©es
                appState.unassignedImages.push(...imagesToMove);
            } else {
                // Ins√©rer dans la section cible √† la position sp√©cifi√©e
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    // Calculer la position d'insertion r√©elle (en tenant compte des suppressions)
                    let actualInsertIndex = Math.min(insertIndex, targetSection.images.length);
                    
                    // Ins√©rer toutes les images en bloc √† la position calcul√©e
                    targetSection.images.splice(actualInsertIndex, 0, ...imagesToMove);
                    
                    console.log(`  ‚úÖ Images ins√©r√©es dans section ${targetSection.sectionNumber} √† l'index ${actualInsertIndex}`);
                }
            }
            
            updateStats();
            updateAllFilenames();
        }

        function reorderImagesInSection(sectionId) {
            // R√©cup√©rer l'ordre actuel depuis le DOM
            const grid = document.querySelector(`[data-section-id="${sectionId}"]`);
            const imageCards = grid.querySelectorAll('.image-card');
            const section = appState.sections.find(s => s.id === sectionId);
            
            if (section) {
                const newOrder = Array.from(imageCards).map(card => {
                    const filename = card.dataset.imageFilename;
                    return section.images.find(img => img.filename === filename);
                }).filter(img => img); // Filtrer les undefined
                
                section.images = newOrder;
                updateAllFilenames();
            }
        }


        
        function updateNomenclatureNumber(sectionId, newNumber) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (section) {
                section.nomenclatureNumber = newNumber.trim();
                // Marquer comme personnalis√© si diff√©rent du num√©ro de section
                section.isCustomNomenclature = (newNumber.trim() !== section.sectionNumber);
                updateAllFilenames();
                renderSections(); // Re-render pour mettre √† jour l'exemple et les noms de fichiers
            }
        }
        
        function editNomenclature(sectionId, currentNomenclature, element) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (!section) return;
            
            // Cr√©er un input temporaire
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentNomenclature;
            input.className = 'nomenclature-input';
            input.style.cssText = `
                background: rgba(15, 23, 42, 0.9);
                border: 2px solid var(--accent-blue);
                border-radius: 6px;
                color: white;
                padding: 0.25rem 0.5rem;
                font-size: 0.9rem;
                font-weight: 600;
                font-family: Monaco, Menlo, monospace;
                min-width: 100px;
                outline: none;
            `;
            
            // Remplacer temporairement le contenu
            const originalHTML = element.innerHTML;
            element.innerHTML = '';
            element.appendChild(input);
            
            // Focus et s√©lectionner le texte
            input.focus();
            input.select();
            
            // Fonction pour valider et revenir √† l'affichage normal
            const finishEdit = () => {
                const newValue = input.value.trim();
                if (newValue && newValue !== currentNomenclature) {
                    updateNomenclatureNumber(sectionId, newValue);
                } else {
                    // Annuler, remettre l'affichage original
                    element.innerHTML = originalHTML;
                }
            };
            
            // √âv√©nements
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    element.innerHTML = originalHTML;
                }
            });
        }

        function generateFilename(sectionNumber, imageNumber) {
            return `${appState.prefix}-${appState.documentName}-${sectionNumber} n_${imageNumber}.${appState.format}`;
        }

        function updateAllFilenames() {
            // Mettre √† jour l'affichage des noms de fichiers
            renderSections();
        }

        function updateStats() {
            document.getElementById('sectionsCount').textContent = appState.sections.length;
            document.getElementById('imagesCount').textContent = extractedImages.length;
            updateSelectionStats();
        }

        function updateUnassignedImages() {
            console.log('üîÑ Mise √† jour des images non attribu√©es...');
            
            const assignedFilenames = new Set();
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    assignedFilenames.add(image.filename);
                });
            });
            
            console.log(`  Images assign√©es: ${assignedFilenames.size}`);
            console.log(`  Images extraites total: ${extractedImages.length}`);
            
            appState.unassignedImages = extractedImages.filter(image => 
                !assignedFilenames.has(image.filename)
            );
            
            console.log(`  Images non attribu√©es calcul√©es: ${appState.unassignedImages.length}`);
            
            renderUnassignedImages();
        }
        
        function renderUnassignedImages() {
            const container = document.getElementById('unassignedImagesContainer');
            const grid = document.getElementById('unassignedGrid');
            const badge = document.getElementById('unassignedBadge');
            
            if (appState.unassignedImages.length === 0) {
                container.style.display = 'none';
            } else {
                container.style.display = 'block';
                badge.textContent = appState.unassignedImages.length;
                
                grid.innerHTML = appState.unassignedImages.map((image, index) => 
                    renderImageCard(image, 'NON-ATTRIBUEE', index + 1)
                ).join('');
                
                // Synchroniser l'√©tat de s√©lection pour les images non attribu√©es
                setTimeout(() => {
                    const unassignedCards = grid.querySelectorAll('.image-card');
                    unassignedCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (selectedImages.has(filename) && !card.classList.contains('selected')) {
                            card.classList.add('selected');
                            logDebug(`‚úÖ Synchronisation: classe 'selected' ajout√©e √† ${filename} (non attribu√©e)`);
                        }
                    });
                }, 10);
            }
        }

        function showImagePreview(filename, event = null) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            logDebug(`Aper√ßu demand√© pour: ${filename}`);
            
            const modal = new bootstrap.Modal(document.getElementById('imageModal'));
            const modalImage = document.getElementById('modalImage');
            const modalInfo = document.getElementById('modalImageInfo');
            
            modalImage.src = `/image/${appState.documentName}/${filename}`;
            modalInfo.innerHTML = `<strong>Fichier:</strong> ${filename}`;
            
            modal.show();
        }

        // Fonction pour toggle les tips
        function toggleTips() {
            const content = document.getElementById('tipsContent');
            const chevron = document.getElementById('tipsChevron');
            
            content.classList.toggle('collapsed');
            chevron.classList.toggle('rotated');
        }
        
        // Variables globales pour le s√©lecteur de section
        let currentSectionSelector = null;
        
        // Variables globales pour la s√©lection multiple
        let selectedImages = new Set();
        
        // Variables pour le drag stack
        let dragStackContainer = null;
        let isDraggingMultiple = false;
        
        // Syst√®me de logs pour le debug
        let appLogs = [];
        const MAX_LOGS = 100;
        
        function logDebug(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'debug',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] DEBUG:`, message, data || '');
        }
        
        function logInfo(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'info',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] INFO:`, message, data || '');
        }
        
        function logError(message, error = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'error',
                message: message,
                data: error ? error.toString() : null
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.error(`[${timestamp}] ERROR:`, message, error || '');
        }
        
        function showSectionSelector(imageFilename, event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Fermer le s√©lecteur existant s'il y en a un
            closeSectionSelector();
            
            // Cr√©er le s√©lecteur
            const selector = document.createElement('div');
            selector.className = 'section-selector';
            selector.innerHTML = generateSectionSelectorHTML(imageFilename);
            
            // Positionner le s√©lecteur pr√®s du bouton
            const rect = event.target.getBoundingClientRect();
            selector.style.left = (rect.left + window.scrollX + 60) + 'px';
            selector.style.top = (rect.top + window.scrollY - 150) + 'px';
            
            // Ajouter au document
            document.body.appendChild(selector);
            currentSectionSelector = selector;
            
            // Fermer le s√©lecteur si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeSectionSelectorOnClickOutside);
            }, 100);
        }
        
        function generateSectionSelectorHTML(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const selectedCount = selectedImages.size;
            const totalToMove = isImageSelected ? selectedCount : (selectedCount > 0 ? selectedCount + 1 : 1);
            
            let html = `
                <div class="section-selector-header">
                    <i class="fas fa-arrow-right me-2"></i>
                    ${totalToMove > 1 ? 
                        `Assigner ${totalToMove} images √† une section` : 
                        'Assigner √† une section'
                    }
                    ${totalToMove > 1 ? `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        ${isImageSelected ? 'Cette image + s√©lection' : 'Cette image + ' + selectedCount + ' s√©lectionn√©es'}
                    </div>` : ''}
                </div>
            `;
            
            // Ajouter toutes les sections disponibles
            appState.sections.forEach(section => {
                const level = section.level || 1;
                const sectionNumber = section.sectionNumber || section.number;
                const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
                const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
                const levelClass = level === 2 ? 'section-option-level-2' : level === 3 ? 'section-option-level-3' : '';
                
                html += `
                    <div class="section-option ${levelClass}" onclick="assignImageToSection('${imageFilename}', ${section.id})">
                        <span class="section-option-number">${levelIcon} ${nomenclatureNumber}</span>
                        <span class="section-option-label">Section ${sectionNumber}</span>
                    </div>
                `;
            });
            
            return html;
        }
        
        function assignImageToSection(imageFilename, targetSectionId) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMove = [];
            
            // Ajouter l'image cliqu√©e si elle n'est pas d√©j√† s√©lectionn√©e
            if (!isImageSelected) {
                imagesToMove.push(imageFilename);
            }
            
            // Ajouter toutes les images s√©lectionn√©es
            imagesToMove.push(...getSelectedImagesList());
            
            // D√©placer toutes les images group√©es √† la fin de la section (pas d'index sp√©cifique)
            if (targetSectionId === 'unassigned') {
                imagesToMove.forEach(filename => {
                    moveImageToSection(filename, targetSectionId);
                });
            } else {
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    moveImagesToSectionAtPosition(imagesToMove, targetSectionId, targetSection.images.length);
                }
            }
            
            // Nettoyer la s√©lection
            clearSelection();
            
            renderSections();
            updateStats();
            closeSectionSelector();
        }
        
        function closeSectionSelector() {
            if (currentSectionSelector) {
                currentSectionSelector.remove();
                currentSectionSelector = null;
                document.removeEventListener('click', closeSectionSelectorOnClickOutside);
            }
        }
        
        function closeSectionSelectorOnClickOutside(event) {
            if (currentSectionSelector && !currentSectionSelector.contains(event.target)) {
                closeSectionSelector();
            }
        }
        
        // Fonctions de s√©lection multiple
        function toggleImageSelection(imageFilename, isSelected) {
            const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
            
            if (isSelected) {
                selectedImages.add(imageFilename);
                imageCard.classList.add('selected');
            } else {
                selectedImages.delete(imageFilename);
                imageCard.classList.remove('selected');
            }
            
            updateSelectionStats();
        }
        
        function toggleImageSelectionByClick(imageFilename) {
            try {
                const isCurrentlySelected = selectedImages.has(imageFilename);
                const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
                
                logDebug(`Toggle s√©lection - Image: ${imageFilename}, Actuellement s√©lectionn√©e: ${isCurrentlySelected}`);
                
                if (!imageCard) {
                    logError(`Element DOM introuvable pour l'image: ${imageFilename}`);
                    return;
                }
                
                // V√©rifier la section parente pour diagnostic
                const parentSection = imageCard.closest('[data-section-id]');
                const sectionId = parentSection ? parentSection.dataset.sectionId : 'inconnue';
                logDebug(`Image ${imageFilename} dans section ID: ${sectionId}`);
                
                if (isCurrentlySelected) {
                    selectedImages.delete(imageFilename);
                    imageCard.classList.remove('selected');
                    logDebug(`‚úÖ Image d√©s√©lectionn√©e: ${imageFilename}, Classes apr√®s: ${imageCard.className}`);
                } else {
                    selectedImages.add(imageFilename);
                    imageCard.classList.add('selected');
                    logDebug(`‚úÖ Image s√©lectionn√©e: ${imageFilename}, Classes apr√®s: ${imageCard.className}`);
                    
                    // V√©rifier que la classe a bien √©t√© ajout√©e
                    setTimeout(() => {
                        const hasSelectedClass = imageCard.classList.contains('selected');
                        logDebug(`V√©rification retard√©e - Classe 'selected' pr√©sente: ${hasSelectedClass}`);
                        if (!hasSelectedClass) {
                            logError(`‚ùå La classe 'selected' n'a pas √©t√© appliqu√©e √† ${imageFilename}`);
                        }
                    }, 100);
                }
                
                updateSelectionStats();
            } catch (error) {
                logError(`Erreur lors de la s√©lection de l'image ${imageFilename}:`, error);
            }
        }
        
        function updateSelectionStats() {
            document.getElementById('selectedCount').textContent = selectedImages.size;
        }
        
        function clearSelection() {
            const count = selectedImages.size;
            selectedImages.forEach(filename => {
                const imageCard = document.querySelector(`[data-image-filename="${filename}"]`);
                if (imageCard) imageCard.classList.remove('selected');
            });
            selectedImages.clear();
            updateSelectionStats();
            logDebug(`S√©lection vid√©e - ${count} images d√©s√©lectionn√©es`);
        }
        
        function getSelectedImagesList() {
            // Retourner les images s√©lectionn√©es dans l'ordre d'apparition dans l'interface
            const allImages = document.querySelectorAll('.image-card');
            const orderedSelectedImages = [];
            
            allImages.forEach(card => {
                const filename = card.dataset.imageFilename;
                if (selectedImages.has(filename)) {
                    orderedSelectedImages.push(filename);
                }
            });
            
            return orderedSelectedImages;
        }
        
        function getSelectedImagesInSourceOrder() {
            // Retourner les images s√©lectionn√©es dans l'ordre qu'elles avaient dans leurs sections d'origine
            const orderedSelectedImages = [];
            
            // D'abord, chercher dans les images non attribu√©es
            appState.unassignedImages.forEach(image => {
                if (selectedImages.has(image.filename)) {
                    orderedSelectedImages.push(image.filename);
                }
            });
            
            // Ensuite, parcourir toutes les sections dans l'ordre hi√©rarchique
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    if (selectedImages.has(image.filename)) {
                        orderedSelectedImages.push(image.filename);
                    }
                });
            });
            
            return orderedSelectedImages;
        }
        
        function toggleSelectAll() {
            try {
                const allImageCards = document.querySelectorAll('.image-card');
                logDebug(`Toggle select all - ${allImageCards.length} images trouv√©es, ${selectedImages.size} s√©lectionn√©es`);
                
                // V√©rifier combien d'images actuellement visibles sont s√©lectionn√©es
                let visibleSelectedCount = 0;
                allImageCards.forEach(card => {
                    const filename = card.dataset.imageFilename;
                    if (selectedImages.has(filename)) {
                        visibleSelectedCount++;
                    }
                });
                
                const allVisibleSelected = (allImageCards.length > 0 && visibleSelectedCount === allImageCards.length);
                logDebug(`Images visibles s√©lectionn√©es: ${visibleSelectedCount}/${allImageCards.length}, tout s√©lectionn√©: ${allVisibleSelected}`);
                
                if (allVisibleSelected) {
                    // Tout d√©s√©lectionner
                    logDebug('D√©s√©lection de toutes les images');
                    clearSelection();
                    document.getElementById('selectAllText').textContent = 'Tout s√©lectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-check-square';
                } else {
                    // Tout s√©lectionner
                    logDebug('S√©lection de toutes les images visibles');
                    allImageCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (!selectedImages.has(filename)) {
                            selectedImages.add(filename);
                            card.classList.add('selected');
                        }
                    });
                    updateSelectionStats();
                    document.getElementById('selectAllText').textContent = 'Tout d√©s√©lectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-square';
                }
            } catch (error) {
                logError('Erreur dans toggleSelectAll:', error);
            }
        }
        
        // Fonctions pour le drag stack
        function createDragStack(imageFilename, mousePosX, mousePosY) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToShow = [];
            
            // Ajouter l'image principale si elle n'est pas s√©lectionn√©e
            if (!isImageSelected) {
                imagesToShow.push(imageFilename);
            }
            
            // Ajouter les images s√©lectionn√©es (max 4 pour l'affichage)
            const selectedList = getSelectedImagesList();
            imagesToShow.push(...selectedList.slice(0, 4));
            
            if (imagesToShow.length <= 1) return;
            
            // Cr√©er le container
            dragStackContainer = document.createElement('div');
            dragStackContainer.className = 'drag-stack-container';
            dragStackContainer.style.left = (mousePosX - 75) + 'px';
            dragStackContainer.style.top = (mousePosY - 50) + 'px';
            
            // Cr√©er les images empil√©es (maximum 3 visibles + compteur)
            imagesToShow.slice(0, 3).forEach((filename, index) => {
                const stackImage = document.createElement('div');
                stackImage.className = `drag-stack-image stack-${index + 1}`;
                
                const img = document.createElement('img');
                img.src = `/image/${appState.documentName}/${filename}`;
                img.onerror = () => img.style.display = 'none';
                
                stackImage.appendChild(img);
                dragStackContainer.appendChild(stackImage);
            });
            
            // Ajouter le compteur si plus de 3 images
            if (imagesToShow.length > 1) {
                const counter = document.createElement('div');
                counter.className = 'drag-stack-counter';
                counter.textContent = imagesToShow.length;
                dragStackContainer.appendChild(counter);
            }
            
            document.body.appendChild(dragStackContainer);
            isDraggingMultiple = true;
        }
        
        function updateDragStackPosition(mousePosX, mousePosY) {
            if (dragStackContainer) {
                dragStackContainer.style.left = (mousePosX - 75) + 'px';
                dragStackContainer.style.top = (mousePosY - 50) + 'px';
            }
        }
        
        function removeDragStack() {
            if (dragStackContainer) {
                dragStackContainer.remove();
                dragStackContainer = null;
                isDraggingMultiple = false;
            }
        }
        
        function markImagesAsBeingDragged(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMark = [];
            
            if (!isImageSelected) {
                imagesToMark.push(imageFilename);
            }
            imagesToMark.push(...getSelectedImagesList());
            
            imagesToMark.forEach(filename => {
                const card = document.querySelector(`[data-image-filename="${filename}"]`);
                if (card) {
                    card.classList.add('being-dragged');
                }
            });
        }
        
        function unmarkImagesAsBeingDragged() {
            document.querySelectorAll('.being-dragged').forEach(card => {
                card.classList.remove('being-dragged');
            });
        }
        
        function setupDragStackMouseTracking() {
            // Utiliser un tracking global de souris pour SortableJS
            let isTrackingMouse = false;
            
            document.addEventListener('mousedown', function(e) {
                if (e.target.closest('.image-card')) {
                    isTrackingMouse = true;
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDraggingMultiple && dragStackContainer && isTrackingMouse) {
                    updateDragStackPosition(e.clientX, e.clientY);
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                isTrackingMouse = false;
            });
        }
        
        function exportImages() {
            // G√©n√©rer la configuration d'export
            const exportConfig = {
                prefix: appState.prefix,
                documentName: appState.documentName,
                format: appState.format,
                sections: appState.sections.map(section => ({
                    number: section.nomenclatureNumber || section.sectionNumber || section.number,
                    displayNumber: section.sectionNumber || section.number,
                    name: section.name,
                    level: section.level || 1,
                    images: section.images.map((image, index) => ({
                        originalFilename: image.filename,
                        newFilename: generateFilename(section.nomenclatureNumber || section.sectionNumber || section.number, index + 1),
                        page: image.page
                    }))
                }))
            };
            
            // Envoyer la configuration au serveur pour g√©n√©rer le ZIP
            fetch('/export-custom', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportConfig)
            })
            .then(response => response.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `${appState.documentName}_custom.zip`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Erreur lors de l\'export:', error);
                alert('Erreur lors de l\'export. Veuillez r√©essayer.');
            });
        }
    </script>
</body>
</html> 