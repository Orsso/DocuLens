<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocuLens - Éditeur de Sections</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-main.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-sections.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-images.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/results-modals.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/image-editor.css') }}" rel="stylesheet">
</head>
<body>
    <div class="container-fluid px-4 py-3">


        <div class="row">
            <!-- Configuration Panel -->
            <div class="col-lg-3">
                <div class="config-panel">
                    <div class="glass-card">
                        <h5 class="mb-3"><i class="fas fa-cog me-2"></i>Configuration</h5>
                        
                        <div class="config-form">
                            <div class="form-group">
                                <label class="form-label">Préfixe</label>
                                <input type="text" id="prefixInput" class="form-control" value="CRL" placeholder="CRL">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Nom du Document</label>
                                <input type="text" id="documentNameInput" class="form-control" value="{{ result.document_name }}" placeholder="Nom du document">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">Format</label>
                                <select id="formatSelect" class="form-control">
                                    <option value="jpg">JPEG (.jpg)</option>
                                    <option value="png">PNG (.png)</option>
                                </select>
                            </div>
                        </div>
                        
                        <hr style="border-color: rgba(59, 130, 246, 0.2); margin: 1.5rem 0;">
                        
                        <div class="d-grid gap-2">
                            <button class="btn-glass" onclick="addNewSection()">
                                <i class="fas fa-plus"></i>
                                Ajouter Section
                            </button>
                            
                            <button class="btn-glass" onclick="toggleSelectAll()" id="selectAllBtn">
                                <i class="fas fa-check-square"></i>
                                <span id="selectAllText">Tout sélectionner</span>
                            </button>
                            
                            <button class="btn-glass" onclick="exportImages()">
                                <i class="fas fa-download"></i>
                                Exporter ZIP
                            </button>
                            

                            
                            <a href="/" class="btn-glass text-center">
                                <i class="fas fa-arrow-left"></i>
                                Retour
                            </a>
                        </div>
                    </div>
                    
                    <!-- Tips Box - Rétractable -->
                    <div class="tips-box">
                        <div class="tips-header" onclick="toggleTips()">
                            <div class="tips-title">
                                <i class="fas fa-lightbulb"></i>
                                <span>Conseils d'utilisation</span>
                            </div>
                            <i class="fas fa-chevron-down tips-chevron" id="tipsChevron"></i>
                        </div>
                        <div class="tips-content" id="tipsContent">
                            <div class="tip-item">
                                <i class="fas fa-plus-circle"></i>
                                <span>Utilisez le bouton violet sur une section pour créer une sous-section</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-edit"></i>
                                <span>Cliquez sur la boîte bleue du numéro pour modifier la nomenclature (ex: ANNEXE-A)</span>
                            </div>
                            <div class="tip-item">
                                <i class="fas fa-arrows-alt"></i>
                                <span>Glissez-déposez les sections par leur boîte bleue pour les réorganiser</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sections Editor -->
            <div class="col-lg-9">
                <!-- Zone Images Non Attribuées -->
                <div id="unassignedImagesContainer" class="unassigned-container" style="display: none;">
                    <div class="glass-card unassigned-card">
                        <div class="unassigned-header">
                            <div class="unassigned-title">
                                <i class="fas fa-inbox"></i>
                                <span>Images non attribuées</span>
                                <span id="unassignedBadge" class="unassigned-badge">0</span>
                            </div>
                        </div>
                        <div class="images-grid" id="unassignedGrid" data-section-id="unassigned">
                            <!-- Images non attribuées -->
                        </div>
                    </div>
                </div>
                
                <div id="sectionsContainer" class="sections-container">
                    <!-- Les sections seront générées par JavaScript -->
                </div>
                
                <!-- Empty State -->
                <div id="emptyState" class="empty-state" style="display: none;">
                    <i class="fas fa-folder-open"></i>
                    <h4>Aucune section créée</h4>
                    <p>Cliquez sur "Ajouter Section" pour commencer</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <div class="glass-card">
            <div class="stats-grid">
                <div class="stat-item">
                    <span id="sectionsCount" class="stat-number">0</span>
                    <span class="stat-label">Sections</span>
                </div>
                <div class="stat-item">
                    <span id="imagesCount" class="stat-number">{{ result.total_images }}</span>
                    <span class="stat-label">Images</span>
                </div>
                <div class="stat-item">
                    <span id="selectedCount" class="stat-number">0</span>
                    <span class="stat-label">Sélectionnées</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Preview Modal -->
    <div class="modal fade" id="imageModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title text-white">Aperçu de l'image</h5>
                    <div class="modal-navigation-info">
                        <span id="modalImageCounter" class="text-white-50"></span>
                    </div>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body text-center position-relative">
                    <button id="prevImageBtn" class="btn-modal-nav btn-modal-prev" onclick="navigateImage(-1)" title="Image précédente (←)">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <img id="modalImage" src="" class="img-fluid rounded" style="max-height: 70vh;">
                    <button id="nextImageBtn" class="btn-modal-nav btn-modal-next" onclick="navigateImage(1)" title="Image suivante (→)">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <div class="modal-image-loading" id="modalImageLoading" style="display: none;">
                        <i class="fas fa-spinner fa-spin"></i>
                    </div>
                </div>
                <div class="modal-footer">
                    <div id="modalImageInfo" class="text-white"></div>
                    <div class="modal-actions">
                        <button id="editFromModalBtn" class="btn btn-purple" onclick="editCurrentModalImage()" title="Éditer cette image">
                            <i class="fas fa-edit"></i> Éditer l'image
                        </button>
                    </div>
                    <div class="modal-keyboard-hint">
                        <small class="text-white-50">
                            <i class="fas fa-keyboard"></i> Utilisez ← → pour naviguer, Échap pour fermer
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Button -->
    <div class="debug-button" onclick="showDebugModal()" title="Diagnostic du système">
        <i class="fas fa-bug"></i>
    </div>

    <!-- Debug Modal -->
    <div class="debug-modal" id="debugModal">
        <div class="debug-modal-content">
            <div class="debug-modal-header">
                <div class="debug-modal-title">
                    <i class="fas fa-bug"></i>
                    <span>Diagnostic du Système</span>
                </div>
                <button class="debug-modal-close" onclick="closeDebugModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="debug-modal-body" id="debugModalBody">
                <!-- Le contenu de debug sera inséré ici -->
            </div>
        </div>
    </div>



    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <script type="application/json" id="sectionsData">{{ result.sections | tojson | safe }}</script>
    <script type="application/json" id="imagesData">{{ result.extracted_files | tojson | safe }}</script>
    
    <script>
        // État global de l'application
        let appState = {
            sections: [],
            unassignedImages: [],
            prefix: 'CRL',
            documentName: '{{ result.document_name }}',
            format: 'jpg',
            nextSectionId: 1,
            maxSubsectionId: {}  // Stocke le prochain ID de sous-section pour chaque section
        };

        // Images extraites du serveur
        let extractedImages = [];
        
        // Sections détectées par le serveur
        let detectedSections = JSON.parse(document.getElementById('sectionsData').textContent);



        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            logInfo('🚀 Initialisation de DocuLens v2');
            setupEventListeners();
            loadImagesFromServer();
            lockDocumentNameAfterProcessing();
            setupDragStackMouseTracking();
            
            // Nettoyer les tooltips au chargement pour éviter les résidus
            setTimeout(() => {
                cleanupTooltips();
                logInfo('✅ Initialisation terminée');
            }, 1000);
        });

        // Debug info
        function logDebug(message, data = null) {
            if (data) {
                console.log(`🐛 ${message}`, data);
            } else {
                console.log(`🐛 ${message}`);
            }
        }
        
        function initializeApp() {
            // Debug : afficher toutes les images extraites
            console.log('🖼️ Images extraites du serveur:', extractedImages.length);
            extractedImages.forEach((img, i) => {
                console.log(`  ${i+1}. ${img.filename} - Section: "${img.section}" - Page: ${img.page}`);
            });
            
            // Créer les sections basées sur la détection automatique
            if (detectedSections && detectedSections.length > 0) {
                console.log('🔍 Sections détectées:', detectedSections.length);
                detectedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. Section "${section.number}" (niveau ${section.level || 1}) - Titre: "${section.title}"`);
                });
                
                // Trier les sections détectées par ordre hiérarchique
                const sortedSections = [...detectedSections].sort((a, b) => {
                    return compareVersions(a.number, b.number);
                });
                
                console.log('📋 Ordre de création des sections:');
                sortedSections.forEach((section, i) => {
                    console.log(`  ${i+1}. ${section.number} (niveau ${section.level || 1})`);
                });
                
                // Créer les sections selon l'ordre hiérarchique
                sortedSections.forEach((detectedSection, index) => {
                    const sectionName = detectedSection.title || `Section ${detectedSection.number}`;
                    const level = detectedSection.level || 1;
                    
                    // Déterminer si c'est une sous-section et trouver le parent
                    let parentSectionId = null;
                    
                    if (level > 1 && detectedSection.number.includes('.')) {
                        const parentNumber = detectedSection.number.split('.')[0];
                        const parentSection = appState.sections.find(s => 
                            s.sectionNumber == parentNumber || s.nomenclatureNumber == parentNumber
                        );
                        if (parentSection) {
                            parentSectionId = parentSection.id;
                            console.log(`  🔗 Section ${detectedSection.number} rattachée au parent ${parentNumber} (ID: ${parentSectionId})`);
                        } else {
                            console.warn(`  ⚠️  Parent ${parentNumber} non trouvé pour section ${detectedSection.number}`);
                        }
                    }
                    
                    const createdSection = addNewSection(sectionName, parentSectionId);
                    
                    if (createdSection) {
                        // Assigner les images de cette section
                        const sectionImages = extractedImages.filter(img => 
                            img.section === detectedSection.number.toString()
                        );
                        
                        createdSection.images = sectionImages;
                        createdSection.sectionNumber = detectedSection.number;
                        createdSection.nomenclatureNumber = detectedSection.number; // Par défaut, même que le numéro de section
                        createdSection.level = level;
                        createdSection.isCustomNomenclature = false; // Détection automatique, pas personnalisée
                        console.log(`  📁 Section ${detectedSection.number}: ${sectionImages.length} images (niveau ${level})`);
                    }
                });
                
                // Forcer la renumération finale et le rendu
                console.log('🔢 Renumération finale...');
                renumberSections(false); // Ne pas écraser les nomenclatures personnalisées
                renderSections();
                updateUnassignedImages();
                debugImageAssignment();
            } else {
                // Fallback : créer une section par défaut
                console.log('⚠️  Aucune section détectée, création d\'une section par défaut');
                if (extractedImages.length > 0) {
                    addNewSection('Section 1');
                    appState.sections[0].images = [...extractedImages];
                    renderSections();
                    updateUnassignedImages();
                }
            }
            updateStats();
        }
        
        function debugImageAssignment() {
            console.log('🔍 DEBUG - État après initialisation:');
            console.log(`  Total images extraites: ${extractedImages.length}`);
            
            let debugInfo = {
                totalExtracted: extractedImages.length,
                sections: [],
                totalAssigned: 0,
                unassigned: appState.unassignedImages.length,
                problems: []
            };
            
            // Analyser chaque section
            appState.sections.forEach(section => {
                const sectionInfo = {
                    number: section.sectionNumber,
                    nomenclature: section.nomenclatureNumber,
                    level: section.level,
                    imageCount: section.images.length,
                    images: section.images.map(img => img.filename)
                };
                debugInfo.sections.push(sectionInfo);
                debugInfo.totalAssigned += section.images.length;
                console.log(`  Section ${section.sectionNumber}: ${section.images.length} images`);
            });
            
            console.log(`  Images assignées total: ${debugInfo.totalAssigned}`);
            console.log(`  Images non attribuées: ${debugInfo.unassigned}`);
            console.log(`  Différence: ${debugInfo.totalExtracted - debugInfo.totalAssigned - debugInfo.unassigned}`);
            
            // Vérifier les problèmes
            if (debugInfo.totalExtracted !== debugInfo.totalAssigned + debugInfo.unassigned) {
                console.error('❌ PROBLÈME: Des images sont perdues!');
                
                // Trouver les images perdues
                const assignedFilenames = new Set();
                appState.sections.forEach(section => {
                    section.images.forEach(img => assignedFilenames.add(img.filename));
                });
                appState.unassignedImages.forEach(img => assignedFilenames.add(img.filename));
                
                const lostImages = extractedImages.filter(img => !assignedFilenames.has(img.filename));
                debugInfo.problems.push({
                    type: 'error',
                    message: 'Images perdues détectées',
                    details: lostImages
                });
                console.error('Images perdues:', lostImages);
            }
            
            return debugInfo;
        }
        
        function showDebugModal() {
            const modal = document.getElementById('debugModal');
            const body = document.getElementById('debugModalBody');
            
            let html = '<div class="debug-section">';
            html += '<div class="debug-section-title">État de l\'Application</div>';
            html += `<div class="debug-info">Sections: ${appState.sections.length}</div>`;
            html += `<div class="debug-info">Images totales: ${extractedImages.length}</div>`;
            html += `<div class="debug-info">Images non assignées: ${appState.unassignedImages.length}</div>`;
            html += `<div class="debug-info">Images sélectionnées: ${selectedImages.size}</div>`;
            html += '</div>';
            
            // Diagnostic spécial pour les duplications
            html += '<div class="debug-section">';
            html += '<div class="debug-section-title">Diagnostic Duplication</div>';
            
            // Compter les doublons dans extractedImages
            const filenameCount = {};
            extractedImages.forEach(img => {
                filenameCount[img.filename] = (filenameCount[img.filename] || 0) + 1;
            });
            const duplicatesInExtracted = Object.entries(filenameCount).filter(([filename, count]) => count > 1);
            
            html += `<div class="debug-info ${duplicatesInExtracted.length > 0 ? 'error' : 'success'}">`;
            html += `Doublons dans extractedImages: ${duplicatesInExtracted.length}</div>`;
            if (duplicatesInExtracted.length > 0) {
                duplicatesInExtracted.forEach(([filename, count]) => {
                    html += `<div class="debug-info error">  • ${filename}: ${count} occurrences</div>`;
                });
            }
            
            // Compter les doublons dans le DOM
            const domFilenames = {};
            document.querySelectorAll('[data-image-filename]').forEach(card => {
                const filename = card.getAttribute('data-image-filename');
                domFilenames[filename] = (domFilenames[filename] || 0) + 1;
            });
            const duplicatesInDOM = Object.entries(domFilenames).filter(([filename, count]) => count > 1);
            
            html += `<div class="debug-info ${duplicatesInDOM.length > 0 ? 'error' : 'success'}">`;
            html += `Doublons dans le DOM: ${duplicatesInDOM.length}</div>`;
            if (duplicatesInDOM.length > 0) {
                duplicatesInDOM.forEach(([filename, count]) => {
                    html += `<div class="debug-info error">  • ${filename}: ${count} cartes</div>`;
                        });
                    }
            
            // Compter les doublons dans les sections
            const sectionFilenames = {};
            appState.sections.forEach(section => {
                section.images.forEach(img => {
                    sectionFilenames[img.filename] = (sectionFilenames[img.filename] || 0) + 1;
                });
            });
            const duplicatesInSections = Object.entries(sectionFilenames).filter(([filename, count]) => count > 1);
            
            html += `<div class="debug-info ${duplicatesInSections.length > 0 ? 'error' : 'success'}">`;
            html += `Doublons dans les sections: ${duplicatesInSections.length}</div>`;
            if (duplicatesInSections.length > 0) {
                duplicatesInSections.forEach(([filename, count]) => {
                    html += `<div class="debug-info error">  • ${filename}: ${count} références</div>`;
                });
            }
            
            html += '</div>';

            // Section Console des logs
            html += '<div class="debug-section">';
            html += '<div class="debug-section-title">Console des Logs</div>';
            html += '<div style="max-height: 300px; overflow-y: auto; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 0.5rem; font-family: monospace; font-size: 0.75rem;">';
            
            if (appLogs && appLogs.length > 0) {
                // Afficher les 20 derniers logs
                const recentLogs = appLogs.slice(0, 20);
                recentLogs.forEach(log => {
                    const typeColor = log.type === 'error' ? '#ff6b6b' : 
                                     log.type === 'info' ? '#4dabf7' : 
                                     log.type === 'debug' ? '#69db7c' : '#ffd43b';
                    
                    html += `<div style="color: ${typeColor}; margin-bottom: 0.25rem; border-bottom: 1px solid #333; padding-bottom: 0.25rem;">`;
                    html += `<span style="color: #888;">[${log.time}]</span> `;
                    html += `<span style="color: ${typeColor}; font-weight: bold;">${log.type.toUpperCase()}:</span> `;
                    html += `<span style="color: #fff;">${log.message}</span>`;
                    if (log.data) {
                        html += `<br/><span style="color: #aaa; margin-left: 2rem;">${JSON.stringify(log.data)}</span>`;
                    }
                    html += '</div>';
                });
                
                html += `<div style="color: #888; text-align: center; margin-top: 0.5rem; font-style: italic;">`;
                html += `Affichage des 20 derniers logs sur ${appLogs.length} total`;
                html += '</div>';
            } else {
                html += '<div style="color: #888; text-align: center; padding: 1rem;">Aucun log disponible</div>';
            }
            
            html += '</div>';
            html += '<div style="margin-top: 0.5rem;">';
            html += '<button class="btn btn-secondary btn-sm" onclick="clearLogs(); showDebugModal();">Vider les logs</button>';
            html += '</div>';
            html += '</div>';

            body.innerHTML = html;
            modal.style.display = 'flex';
        }
        
        function closeDebugModal() {
            document.getElementById('debugModal').style.display = 'none';
        }

        // Style pour les éléments de debug
        const debugStyles = `
            .debug-info.success { color: #10b981; }
            .debug-info.warning { color: #f59e0b; }
            .debug-info.error { color: #ef4444; font-weight: bold; }
            .debug-section { margin-bottom: 1.5rem; }
            .debug-section-title { 
                font-weight: bold; 
                color: var(--accent-blue); 
                border-bottom: 1px solid var(--accent-blue); 
                padding-bottom: 0.5rem; 
                margin-bottom: 1rem; 
            }
        `;
        
        // Ajouter les styles si pas déjà ajoutés
        if (!document.getElementById('debugStyles')) {
            const styleSheet = document.createElement('style');
            styleSheet.id = 'debugStyles';
            styleSheet.textContent = debugStyles;
            document.head.appendChild(styleSheet);
        }

        // === FONCTION DE SUPPRESSION SIMPLIFIÉE ===
        
        function deleteImage(filename, event) {
            event.stopPropagation();
            logInfo(`🗑️ Suppression de l'image: ${filename}`);
            
            // Trouver l'image dans les sections et la remettre dans les non assignées
            let imageToMove = null;
            
            // Chercher dans les sections
            for (let section of appState.sections) {
                const imageIndex = section.images.findIndex(img => img.filename === filename);
                if (imageIndex !== -1) {
                    imageToMove = section.images.splice(imageIndex, 1)[0];
                    break;
                }
            }
            
            // Si l'image n'était pas dans une section, elle était déjà dans les non assignées
            if (imageToMove) {
                // Remettre dans les images non assignées
                appState.unassignedImages.push(imageToMove);
                
                // Désélectionner l'image si elle était sélectionnée
                selectedImages.delete(filename);
                
                // Mettre à jour l'interface
                renderSections();
                updateUnassignedImages();
                updateStats();
                
                logInfo(`✅ Image déplacée vers les non attribuées: ${filename}`);
                showToast(`Image "${filename}" remise dans les non attribuées`, 'info');
            }
        }
        
        function showToast(message, type = 'info') {
            // Simple notification toast
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                z-index: 10000;
                font-size: 0.9rem;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(8px);
                transform: translateX(100%);
                transition: transform 0.3s ease;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // Animation d'entrée
            setTimeout(() => {
                toast.style.transform = 'translateX(0)';
            }, 100);
            
            // Suppression automatique
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }
        
        function clearLogs() {
            appLogs = [];
            logInfo('Logs vidés manuellement');
            // Rafraîchir la modal si elle est ouverte
            if (document.getElementById('debugModal').style.display === 'flex') {
                showDebugModal();
            }
        }
        
        function syncSelectionStateWithDOM() {
            logDebug('🔄 Synchronisation DOM avec état de sélection...');
            
            let syncCount = 0;
            const allImageCards = document.querySelectorAll('.image-card');
            
            allImageCards.forEach(card => {
                const filename = card.dataset.imageFilename;
                const shouldBeSelected = selectedImages.has(filename);
                const isCurrentlySelected = card.classList.contains('selected');
                
                if (shouldBeSelected && !isCurrentlySelected) {
                    card.classList.add('selected');
                    syncCount++;
                    logDebug(`✅ Classe 'selected' ajoutée à ${filename}`);
                } else if (!shouldBeSelected && isCurrentlySelected) {
                    card.classList.remove('selected');
                    syncCount++;
                    logDebug(`❌ Classe 'selected' supprimée de ${filename}`);
                }
            });
            
            if (syncCount > 0) {
                logInfo(`🔄 ${syncCount} images synchronisées avec l'état de sélection`);
            }
        }
        
        function diagnoseSelectionIssue() {
            logInfo('=== DIAGNOSTIC COMPLET DE LA SÉLECTION ===');
            
            // Vérifier l'état des sélections
            logInfo(`Images sélectionnées en mémoire: ${selectedImages.size}`);
            selectedImages.forEach(filename => {
                logInfo(`  - ${filename}`);
            });
            
            // Vérifier l'état dans le DOM
            const allImageCards = document.querySelectorAll('.image-card');
            logInfo(`Images totales dans le DOM: ${allImageCards.length}`);
            
            let domSelectedCount = 0;
            allImageCards.forEach((card, index) => {
                const filename = card.dataset.imageFilename;
                const hasSelectedClass = card.classList.contains('selected');
                const isInMemory = selectedImages.has(filename);
                
                if (hasSelectedClass) domSelectedCount++;
                
                if (hasSelectedClass !== isInMemory) {
                    logError(`Incohérence détectée - ${filename}: DOM=${hasSelectedClass}, Mémoire=${isInMemory}`);
                }
                
                // Log détaillé pour chaque section
                const sectionEl = card.closest('[data-section-id]');
                const sectionId = sectionEl ? sectionEl.dataset.sectionId : 'inconnu';
                
                logDebug(`Image ${index + 1}: ${filename} | Section: ${sectionId} | DOM selected: ${hasSelectedClass} | Memory: ${isInMemory}`);
            });
            
            logInfo(`Images sélectionnées dans le DOM: ${domSelectedCount}`);
            
            if (domSelectedCount !== selectedImages.size) {
                logError(`PROBLÈME: ${selectedImages.size} en mémoire vs ${domSelectedCount} dans le DOM`);
            }
            
            logInfo('=== FIN DIAGNOSTIC ===');
        }
        
        // Fermer la modal debug en cliquant en dehors
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('debugModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeDebugModal();
                }
            });
        });

        function setupEventListeners() {
            // Configuration inputs
            document.getElementById('prefixInput').addEventListener('input', (e) => {
                appState.prefix = e.target.value || 'CRL';
                updateAllFilenames();
            });
            
            document.getElementById('documentNameInput').addEventListener('input', (e) => {
                // Ne pas permettre de changer le nom du document après traitement
                // car cela casserait les URLs des images
                console.warn('Changement du nom de document désactivé après traitement');
            });
            
            document.getElementById('formatSelect').addEventListener('change', (e) => {
                appState.format = e.target.value;
                updateAllFilenames();
            });
        }
        
        function lockDocumentNameAfterProcessing() {
            const documentNameInput = document.getElementById('documentNameInput');
            if (documentNameInput) {
                documentNameInput.disabled = true;
                documentNameInput.style.opacity = '0.6';
                documentNameInput.style.cursor = 'not-allowed';
                documentNameInput.title = 'Le nom du document ne peut pas être modifié après traitement';
                
                // Ajouter une icône de cadenas
                const parent = documentNameInput.parentElement;
                const lockIcon = document.createElement('i');
                lockIcon.className = 'fas fa-lock';
                lockIcon.style.position = 'absolute';
                lockIcon.style.right = '10px';
                lockIcon.style.top = '50%';
                lockIcon.style.transform = 'translateY(-50%)';
                lockIcon.style.color = 'var(--text-secondary)';
                lockIcon.style.pointerEvents = 'none';
                parent.style.position = 'relative';
                parent.appendChild(lockIcon);
            }
        }

        function loadImagesFromServer() {
            // Utiliser les images extraites directement du template
            const extractedFiles = JSON.parse(document.getElementById('imagesData').textContent);
            
            // Convertir les données du serveur au format attendu par le client
            extractedImages = extractedFiles.map(file => ({
                filename: file.filename,
                section: file.section,
                page: file.page,
                image_number: file.image_number
            }));
            
            console.log('📊 Images chargées:', extractedImages.length, 'images');
            console.log('📊 Première image:', extractedImages[0]);
            
            appState.unassignedImages = []; // Laisser vide, sera calculé correctement après l'initialisation
            initializeApp();
            updateStats();
        }

        function addNewSection(name = null, parentSectionId = null, afterSectionId = null) {
            try {
                let sectionNumber, sectionName, level, nomenclatureNumber;
                let insertIndex = appState.sections.length; // Par défaut, à la fin
                
                logInfo(`Ajout nouvelle section - name: "${name}", parent: ${parentSectionId}, after: ${afterSectionId}`);
            
            if (parentSectionId) {
                // Créer une sous-section ou sous-sous-section
                const parentSection = appState.sections.find(s => s.id === parentSectionId);
                if (!parentSection) {
                    console.error(`❌ Section parent ${parentSectionId} introuvable`);
                    return;
                }
                
                const parentNumber = parentSection.sectionNumber || parentSection.number;
                
                // Initialiser le compteur de sous-sections pour cette section parent
                if (!appState.maxSubsectionId[parentNumber]) {
                    appState.maxSubsectionId[parentNumber] = 1;
                } else {
                    appState.maxSubsectionId[parentNumber]++;
                }
                
                sectionNumber = `${parentNumber}.${appState.maxSubsectionId[parentNumber]}`;
                level = (parentSection.level || 1) + 1;
                nomenclatureNumber = sectionNumber; // Par défaut, même que le numéro hiérarchique
                
                sectionName = name || `Section ${sectionNumber}`;
                
                // Position pour sous-section : après le parent et ses sous-sections existantes
                const parentIndex = appState.sections.findIndex(s => s.id === parentSectionId);
                insertIndex = parentIndex + 1;
                
                // Trouver la position après toutes les sous-sections existantes du parent
                while (insertIndex < appState.sections.length && 
                       appState.sections[insertIndex].parentId === parentSectionId) {
                    insertIndex++;
                }
            } else if (afterSectionId) {
                // Créer une section principale après une section spécifique
                const afterSection = appState.sections.find(s => s.id === afterSectionId);
                if (afterSection) {
                    const afterIndex = appState.sections.findIndex(s => s.id === afterSectionId);
                    insertIndex = afterIndex + 1;
                    
                    // Si la section après laquelle on insère a des sous-sections, insérer après toutes ses sous-sections
                    while (insertIndex < appState.sections.length && 
                           (appState.sections[insertIndex].parentId === afterSectionId ||
                            (appState.sections[insertIndex].level > 1 && 
                             appState.sections[insertIndex].sectionNumber && 
                             appState.sections[insertIndex].sectionNumber.startsWith(afterSection.sectionNumber + '.')))) {
                        insertIndex++;
                    }
                }
                
                // Le numéro sera déterminé après insertion et renumération
                level = 1;
                sectionName = name || `Section temporaire`;
                nomenclatureNumber = "temp";
            } else {
                // Créer une section principale à la fin ou lors de l'initialisation
                const mainSections = appState.sections.filter(s => (s.level || 1) === 1);
                if (name && name.includes('Section ') && !isNaN(parseInt(name.split(' ')[1]))) {
                    // Si un nom avec numéro est fourni, l'utiliser
                    const providedNumber = parseInt(name.split(' ')[1]);
                    sectionNumber = providedNumber;
                } else {
                    sectionNumber = mainSections.length + 1;
                }
                sectionName = name || `Section ${sectionNumber}`;
                nomenclatureNumber = sectionNumber.toString();
                level = 1;
            }
            
            const newSection = {
                id: appState.nextSectionId++,
                name: sectionName,
                number: insertIndex + 1,                    // Position dans la liste (sera mise à jour)
                sectionNumber: sectionNumber,               // Numéro hiérarchique (sera mis à jour si nécessaire)
                nomenclatureNumber: nomenclatureNumber,     // Numéro utilisé dans la nomenclature des fichiers
                level: level,
                parentId: parentSectionId,
                images: []
            };
            
            console.log(`  📝 Section créée: "${newSection.name}" (n°${newSection.sectionNumber}, niveau ${newSection.level})`);
            
            // Insérer la section à la position calculée
            appState.sections.splice(insertIndex, 0, newSection);
            
            // Ne pas renumbéroter automatiquement lors de l'initialisation pour préserver les numéros détectés
            if (!name || !name.includes('Section ')) {
                renumberSections(true);
            }
            
            // Toujours faire le rendu et mettre à jour les stats après ajout
            renderSections();
            updateStats();
            updateUnassignedImages();
            
            return newSection;
            } catch (error) {
                logError('Erreur lors de l\'ajout de section:', error);
                return null;
            }
        }
        
                 function renumberSections(isAutomaticRename = true) {
             let mainSectionCount = 1;
             const subsectionCounters = {};
             
             appState.sections.forEach((section, index) => {
                 section.number = index + 1; // Position dans la liste
                 
                 if (section.level === 1) {
                     const oldSectionNumber = section.sectionNumber;
                     section.sectionNumber = mainSectionCount.toString();
                     
                     // Mise à jour automatique de la nomenclature seulement si c'est un rename automatique
                     if (isAutomaticRename && (!section.nomenclatureNumber || 
                         section.nomenclatureNumber === oldSectionNumber || 
                         section.nomenclatureNumber === (mainSectionCount - 1).toString() || 
                         section.nomenclatureNumber === "temp")) {
                         section.nomenclatureNumber = mainSectionCount.toString();
                         section.isCustomNomenclature = false; // Flag pour indiquer que ce n'est pas personnalisé
                     } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                         section.isCustomNomenclature = true; // Flag pour indiquer une personnalisation
                     }
                     
                     // Mettre à jour le nom si c'était temporaire
                     if (section.name === "Section temporaire") {
                         section.name = `Section ${mainSectionCount}`;
                     }
                     subsectionCounters[mainSectionCount] = 1;
                     mainSectionCount++;
                 } else if (section.level === 2 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise à jour automatique seulement si approprié
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                         subsectionCounters[section.sectionNumber] = 1;
                     }
                 } else if (section.level === 3 && section.parentId) {
                     const parentSection = appState.sections.find(s => s.id === section.parentId);
                     if (parentSection) {
                         const parentNumber = parentSection.sectionNumber;
                         const oldSectionNumber = section.sectionNumber;
                         section.sectionNumber = `${parentNumber}.${subsectionCounters[parentNumber] || 1}`;
                         
                         // Mise à jour automatique seulement si approprié
                         if (isAutomaticRename && (!section.nomenclatureNumber || 
                             section.nomenclatureNumber === oldSectionNumber || 
                             section.nomenclatureNumber.startsWith(parentNumber + '.'))) {
                             section.nomenclatureNumber = section.sectionNumber;
                             section.isCustomNomenclature = false;
                         } else if (!isAutomaticRename && section.nomenclatureNumber !== section.sectionNumber) {
                             section.isCustomNomenclature = true;
                         }
                         
                         subsectionCounters[parentNumber] = (subsectionCounters[parentNumber] || 1) + 1;
                     }
                 }
             });
         }

        function deleteSection(sectionId) {
            const sectionIndex = appState.sections.findIndex(s => s.id === sectionId);
            if (sectionIndex !== -1) {
                const sectionToDelete = appState.sections[sectionIndex];
                
                if (sectionToDelete.level === 1) {
                    // Section principale : supprimer aussi toutes les sous-sections
                    const subsections = appState.sections.filter(s => s.parentId === sectionId);
                    const sectionsToDelete = [sectionToDelete, ...subsections];
                
                    // Collecter toutes les images à animer vers unassigned
                    const imagesToAnimate = [];
                sectionsToDelete.forEach(section => {
                        imagesToAnimate.push(...section.images.map(img => img.filename));
                        console.log(`📤 Images de la section ${section.sectionNumber || section.number} préparées pour animation vers non-assignées (${section.images.length} images)`);
                    });
                    
                    if (imagesToAnimate.length > 0) {
                        // Animer le déplacement vers unassigned
                        animateImagesMoveToSection(imagesToAnimate, 'unassigned');
                        
                        // Supprimer les sections après un délai pour que l'animation démarre
                        setTimeout(() => {
                sectionsToDelete.forEach(section => {
                    const index = appState.sections.findIndex(s => s.id === section.id);
                    if (index !== -1) {
                        appState.sections.splice(index, 1);
                    }
                });
                        }, 200);
                    } else {
                        // Pas d'images, suppression directe
                        sectionsToDelete.forEach(section => {
                            const index = appState.sections.findIndex(s => s.id === section.id);
                            if (index !== -1) {
                                appState.sections.splice(index, 1);
                            }
                        });
                        finalizeSectionDeletion();
                    }
                } else {
                    // Sous-section : les images remontent dans la section parente
                    let parentSection = appState.sections.find(s => s.id === sectionToDelete.parentId);
                    
                    // Si pas de parentId, essayer de trouver par hiérarchie numérique
                    if (!parentSection && sectionToDelete.sectionNumber) {
                        const parentNumber = sectionToDelete.sectionNumber.split('.').slice(0, -1).join('.');
                        if (parentNumber) {
                            parentSection = appState.sections.find(s => 
                                (s.sectionNumber === parentNumber || s.nomenclatureNumber === parentNumber) && 
                                s.level < sectionToDelete.level
                            );
                        }
                    }
                    
                    if (parentSection && sectionToDelete.images.length > 0) {
                        // D'abord transférer les images vers la section parente dans les données
                        parentSection.images.push(...sectionToDelete.images);
                        
                        // Animer les images vers la section parente
                        const imagesToAnimate = sectionToDelete.images.map(img => img.filename);
                        console.log(`⬆️ Images de la sous-section ${sectionToDelete.sectionNumber || sectionToDelete.number} préparées pour animation vers section parente ${parentSection.sectionNumber || parentSection.number} (${sectionToDelete.images.length} images)`);
                        
                        // Vider les images de la section à supprimer (elles sont maintenant dans le parent)
                        sectionToDelete.images = [];
                        
                        // Déclencher l'animation mais avec un flag spécial pour éviter double déplacement
                        animateSubsectionImagesToParent(imagesToAnimate, parentSection.id);
                        
                        // Supprimer la sous-section après un délai
                        setTimeout(() => {
                            appState.sections.splice(sectionIndex, 1);
                            finalizeSectionDeletion();
                        }, 200);
                    } else if (sectionToDelete.images.length > 0) {
                        // Si pas de parent trouvé, animer vers unassigned
                        const imagesToAnimate = sectionToDelete.images.map(img => img.filename);
                        console.log(`📤 Images de la sous-section orpheline ${sectionToDelete.sectionNumber || sectionToDelete.number} préparées pour animation vers non-assignées (${sectionToDelete.images.length} images)`);
                        
                        animateImagesMoveToSection(imagesToAnimate, 'unassigned');
                        
                        // Supprimer la sous-section après un délai
                        setTimeout(() => {
                            appState.sections.splice(sectionIndex, 1);
                        }, 200);
                    } else {
                        // Pas d'images, suppression directe
                        appState.sections.splice(sectionIndex, 1);
                        finalizeSectionDeletion();
                    }
                }
            }
        }
        
        function animateSubsectionImagesToParent(imagesToAnimate, parentSectionId) {
            logInfo(`🎬 Animation spéciale sous-section vers parent pour ${imagesToAnimate.length} images`);
            
            // Animer les images avec un délai échelonné pour un effet cascade
            imagesToAnimate.forEach((filename, index) => {
                setTimeout(() => {
                    animateImageMove(filename, parentSectionId);
                }, index * 100); // 100ms de délai entre chaque image
            });
            
            // Mettre à jour l'interface après l'animation (sans déplacer les données qui sont déjà au bon endroit)
            const totalDelay = imagesToAnimate.length * 100 + 700; // 700ms = durée de l'animation
            setTimeout(() => {
                renderSections();
                updateUnassignedImages();
                updateStats();
                logInfo(`✅ Animation sous-section vers parent terminée`);
            }, totalDelay);
        }
        
        function finalizeSectionDeletion() {
                // Renumbéroter les sections (automatique)
                renumberSections(true);
                renderSections();
            updateUnassignedImages();
                updateStats();
                updateAllFilenames();
        }

                function cleanupTooltips() {
            // Supprimer tous les tooltips existants pour éviter les doublons
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                tooltip.remove();
            });
            
            // Disposer des instances Bootstrap Tooltip existantes
            document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(element => {
                const tooltipInstance = bootstrap.Tooltip.getInstance(element);
                if (tooltipInstance) {
                    tooltipInstance.dispose();
                }
            });
        }

        function renderSections() {
            logInfo('[DIAGNOSTIC] renderSections appelée - début du rendu');
            
            const container = document.getElementById('sectionsContainer');
            const emptyState = document.getElementById('emptyState');
            
            if (appState.sections.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                logInfo('[DIAGNOSTIC] Aucune section, affichage de l\'état vide');
                return;
            }
            
            emptyState.style.display = 'none';
            
            // Compter les images avant le rendu
            const imageCountBeforeRender = document.querySelectorAll('[data-image-filename]').length;
            
            // Organiser les sections par hiérarchie
            const organizedHTML = buildHierarchicalSections(appState.sections);
            container.innerHTML = organizedHTML;
            
            // Compter les images après le rendu
            const imageCountAfterRender = document.querySelectorAll('[data-image-filename]').length;
            
            logInfo(`[DIAGNOSTIC] Images dans le DOM - Avant: ${imageCountBeforeRender}, Après: ${imageCountAfterRender}`);
            
            // Forcer la synchronisation de l'état de sélection
            syncSelectionStateWithDOM();
            
            // Initialiser les zones de drop
            setupSortable();
            
            // Nettoyer les anciens tooltips pour éviter les doublons
            cleanupTooltips();
            
            // Activer les nouveaux tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
            
            logInfo('[DIAGNOSTIC] renderSections terminée');
        }
        
        function buildHierarchicalSections(sections) {
            let html = '';
            
            // Filtrer les sections principales (niveau 1)
            const mainSections = sections.filter(s => (s.level || 1) === 1);
            
            mainSections.forEach(mainSection => {
                html += renderMainSection(mainSection, sections);
            });
            
            return html;
        }
        
                function renderMainSection(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            const nomenclatureNumber = mainSection.nomenclatureNumber || sectionNumber;
            
            // Trouver toutes les sous-sections de cette section principale et les organiser hiérarchiquement
            const subsections = getOrderedSubsections(mainSection, allSections);
            
            let html = `
            <div class="section-group-wrapper">
                ${renderSectionCard(mainSection, subsections)}
            </div>
            `;
            
            return html;
        }
        
        function getOrderedSubsections(mainSection, allSections) {
            const sectionNumber = mainSection.sectionNumber || mainSection.number;
            
            // Récupérer toutes les sections qui appartiennent à cette section principale
            const relatedSections = allSections.filter(s => 
                s.level > 1 && 
                s.sectionNumber && 
                s.sectionNumber.startsWith(sectionNumber + '.')
            );
            
            // Trier par numéro de section pour respecter l'ordre hiérarchique
            relatedSections.sort((a, b) => {
                return compareVersions(a.sectionNumber, b.sectionNumber);
            });
            
            return relatedSections;
        }
        
        function compareVersions(a, b) {
            const aParts = a.split('.').map(Number);
            const bParts = b.split('.').map(Number);
            
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const aPart = aParts[i] || 0;
                const bPart = bParts[i] || 0;
                
                if (aPart !== bPart) {
                    return aPart - bPart;
                }
            }
            
            return 0;
        }
        
        function renderHierarchicalSubsections(subsections) {
            let html = '';
            let currentLevel2Section = null;
            let level3Sections = [];
            
            for (let i = 0; i < subsections.length; i++) {
                const section = subsections[i];
                
                if (section.level === 2) {
                    // Si on avait une section niveau 2 en cours, on la rend avec ses sous-sections niveau 3
                    if (currentLevel2Section) {
                        html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
                        level3Sections = [];
                    }
                    currentLevel2Section = section;
                } else if (section.level === 3 && currentLevel2Section) {
                    // Ajouter cette sous-sous-section à la liste de la section niveau 2 courante
                    level3Sections.push(section);
                } else {
                    // Section orpheline, la rendre directement
                    html += renderSectionCard(section);
                }
            }
            
            // Traiter la dernière section niveau 2 s'il y en a une
            if (currentLevel2Section) {
                html += renderSectionWithSubsections(currentLevel2Section, level3Sections);
            }
            
            return html;
        }
        
        function renderSectionWithSubsections(level2Section, level3Sections) {
            let html = renderSectionCard(level2Section);
            
            if (level3Sections.length > 0) {
                html += '<div class="sub-sub-sections-container">';
                html += level3Sections.map(sub => renderSectionCard(sub)).join('');
                html += '</div>';
            }
            
            return html;
        }
        
        function renderSectionCard(section, subsections = []) {
            const level = section.level || 1;
            const sectionNumber = section.sectionNumber || section.number;
            const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
            const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
            
            // Classes CSS selon le niveau
            let cardClass = 'section-editor glass-card';
            if (level === 1) {
                cardClass += subsections.length > 0 ? ' main-section-with-subs' : ' main-section';
            } else if (level === 2) {
                cardClass += ' sub-section';
            } else {
                cardClass += ' sub-sub-section';
            }
            
            return `
            <div class="${cardClass}" data-section-id="${section.id}">
                <div class="section-header">
                    <div class="section-title">
                        <div class="section-number" title="Cliquez pour modifier la nomenclature (actuellement: ${nomenclatureNumber})" 
                             onclick="editNomenclature(${section.id}, '${nomenclatureNumber}', this)">
                            ${levelIcon} <span class="section-number-text">${sectionNumber}</span>
                            ${section.isCustomNomenclature && nomenclatureNumber !== sectionNumber ? `<span class="nomenclature-badge">→ ${nomenclatureNumber}</span>` : ''}
                        </div>
                    </div>
                    <div class="section-controls">
                        ${level < 3 ? `
                            <button class="btn-icon btn-add-sub" onclick="addNewSection(null, ${section.id})" 
                                    data-bs-toggle="tooltip" title="Ajouter une ${level === 1 ? 'sous-section' : 'sous-sous-section'}">
                                <i class="fas fa-plus-circle"></i>
                            </button>
                        ` : ''}
                        <button class="btn-icon btn-section-delete" onclick="deleteSection(${section.id})"
                                data-bs-toggle="tooltip" title="Supprimer cette ${level === 1 ? 'section' : level === 2 ? 'sous-section' : 'sous-sous-section'}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="images-grid" data-section-id="${section.id}">
                    ${section.images.map((image, index) => renderImageCard(image, nomenclatureNumber, index + 1)).join('')}
                </div>
                
                ${level === 1 && subsections.length > 0 ? `
                    <div class="subsections-container">
                        ${renderHierarchicalSubsections(subsections)}
                    </div>
                ` : ''}
            </div>
            `;
        }

        function renderImageCard(image, sectionNumber, imageNumber) {
            const filename = generateFilename(sectionNumber, imageNumber);
            const isSelected = selectedImages.has(image.filename);
            
            // Log détaillé pour le diagnostic
            logDebug(`Rendu image: ${image.filename} | Généré: ${filename} | Sélectionnée: ${isSelected}`);
            
            if (isSelected) {
                logDebug(`✅ Image sélectionnée à rendre: ${image.filename} dans section ${sectionNumber}`);
            }
            
            return `
                <div class="image-card ${isSelected ? 'selected' : ''}" data-image-filename="${image.filename}" onclick="toggleImageSelectionByClick('${image.filename}')">
                    <img src="/image/${appState.documentName}/${image.filename}" 
                         alt="${image.filename}" class="image-preview" 
                         onerror="this.style.display='none'">
                    <div class="image-overlay">
                        <button class="btn-zoom" onclick="showImagePreview('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Agrandir l'image">
                            <i class="fas fa-search-plus"></i>
                        </button>

                        <button class="btn-assign" onclick="showSectionSelector('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Assigner à une section">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                        <button class="btn-image-delete" onclick="deleteImage('${image.filename}', event)" 
                                data-bs-toggle="tooltip" title="Supprimer l'image">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <div class="image-info">
                        <div class="image-filename">${filename}</div>
                        <div class="image-page">Page ${image.page}</div>
                    </div>
                </div>
            `;
        }

        function setupSortable() {
            // Sortable pour les grilles d'images
            document.querySelectorAll('.images-grid').forEach(grid => {
                new Sortable(grid, {
                    group: 'images',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    onStart: function(evt) {
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const totalImages = isSelected ? selectedImages.size : (selectedImages.size > 0 ? selectedImages.size + 1 : 1);
                        
                        // Marquer les images comme étant draggées (les masquer)
                        markImagesAsBeingDragged(imageFilename);
                        
                        // Créer le stack visuel si multiple images
                        if (totalImages > 1) {
                            // Position initiale
                            const rect = evt.item.getBoundingClientRect();
                            createDragStack(imageFilename, rect.left + rect.width/2, rect.top + rect.height/2);
                        }
                    },
                    onMove: function(evt) {
                        // Mettre à jour la position du stack pendant le drag
                        if (isDraggingMultiple && dragStackContainer) {
                            const rect = evt.related.getBoundingClientRect();
                            updateDragStackPosition(rect.left, rect.top);
                        }
                    },
                    onAdd: function(evt) {
                        const sectionId = parseInt(evt.to.dataset.sectionId);
                        const imageFilename = evt.item.dataset.imageFilename;
                        const isSelected = selectedImages.has(imageFilename);
                        const dropIndex = evt.newIndex;
                        
                        // Préparer la liste des images à déplacer dans le bon ordre d'origine
                        const imagesToMove = [];
                        
                        // Si l'image draguée n'était pas sélectionnée, elle va en premier
                        if (!isSelected) {
                            imagesToMove.push(imageFilename);
                        }
                        
                        // Ajouter les images sélectionnées dans l'ordre qu'elles avaient dans leur section d'origine
                        const selectedInOrder = getSelectedImagesInSourceOrder();
                        imagesToMove.push(...selectedInOrder);
                        
                        // Déplacer les images en préservant l'ordre et la position
                        moveImagesToSectionAtPosition(imagesToMove, sectionId, dropIndex);
                        
                        clearSelection();
                        renderSections();
                        updateUnassignedImages();
                    },
                    onUpdate: function(evt) {
                        // Réorganisation dans la même section
                        const sectionId = parseInt(evt.from.dataset.sectionId);
                        if (sectionId && !isNaN(sectionId)) {
                            reorderImagesInSection(sectionId);
                        }
                        updateUnassignedImages();
                    },
                    onEnd: function(evt) {
                        // Nettoyer le stack et les états de drag
                        removeDragStack();
                        unmarkImagesAsBeingDragged();
                    }
                });
            });
            
            // Sortable pour les groupes de sections principales
            const sectionsContainer = document.getElementById('sectionsContainer');
            if (sectionsContainer) {
                new Sortable(sectionsContainer, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '[class*="main-section"] .section-number', // Seules les sections principales peuvent être déplacées
                    onEnd: function(evt) {
                        // Réorganiser les sections selon le nouvel ordre des groupes
                        rebuildSectionsOrderFromDOM();
                        
                        // Renumération automatique après déplacement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            }
            
            // Sortable pour les sous-sections dans leurs containers
            document.querySelectorAll('.subsections-container').forEach(container => {
                new Sortable(container, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    dragClass: 'dragging',
                    handle: '.section-number', // Sous-sections peuvent être réorganisées entre elles
                    onEnd: function(evt) {
                        // Réorganiser les sous-sections
                        rebuildSectionsOrderFromDOM();
                        
                        // Renumération automatique après déplacement
                        renumberSections(true);
                        renderSections();
                        updateStats();
                        updateAllFilenames();
                    }
                });
            });
        }
        
        function rebuildSectionsOrderFromDOM() {
            const newOrder = [];
            
            // Parcourir chaque wrapper de section
            document.querySelectorAll('.section-group-wrapper').forEach(wrapper => {
                // Ajouter la section principale
                const mainSectionEl = wrapper.querySelector('.main-section, .main-section-with-subs');
                if (mainSectionEl) {
                    const mainSectionId = parseInt(mainSectionEl.dataset.sectionId);
                    const mainSection = appState.sections.find(s => s.id === mainSectionId);
                    if (mainSection) {
                        newOrder.push(mainSection);
                    }
                    
                    // Ajouter les sous-sections dans l'ordre
                    const subsectionsContainer = mainSectionEl.querySelector('.subsections-container');
                    if (subsectionsContainer) {
                        // Parcourir dans l'ordre : sous-sections niveau 2, puis leurs sous-sections niveau 3
                        subsectionsContainer.querySelectorAll('.sub-section').forEach(subEl => {
                            const subSectionId = parseInt(subEl.dataset.sectionId);
                            const subSection = appState.sections.find(s => s.id === subSectionId);
                            if (subSection) {
                                newOrder.push(subSection);
                                
                                // Ajouter les sous-sous-sections de cette sous-section
                                const subSubContainer = subEl.nextElementSibling;
                                if (subSubContainer && subSubContainer.classList.contains('sub-sub-sections-container')) {
                                    subSubContainer.querySelectorAll('.sub-sub-section').forEach(subSubEl => {
                                        const subSubSectionId = parseInt(subSubEl.dataset.sectionId);
                                        const subSubSection = appState.sections.find(s => s.id === subSubSectionId);
                                        if (subSubSection) {
                                            newOrder.push(subSubSection);
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
            });
            
            appState.sections = newOrder;
        }

        function moveImageToSection(imageFilename, targetSectionId) {
            // Trouver l'image
            let image = null;
            let sourceSection = null;
            
            // Chercher dans unassigned
            const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === imageFilename);
            if (unassignedIndex !== -1) {
                image = appState.unassignedImages.splice(unassignedIndex, 1)[0];
            } else {
                // Chercher dans les sections
                for (let section of appState.sections) {
                    const imageIndex = section.images.findIndex(img => img.filename === imageFilename);
                    if (imageIndex !== -1) {
                        image = section.images.splice(imageIndex, 1)[0];
                        sourceSection = section;
                        break;
                    }
                }
            }
            
            if (image) {
                if (targetSectionId === 'unassigned') {
                    // Remettre dans les non attribuées
                    appState.unassignedImages.push(image);
                } else {
                    // Ajouter à la section cible
                    const targetSection = appState.sections.find(s => s.id === targetSectionId);
                    if (targetSection) {
                        targetSection.images.push(image);
                    }
                }
                updateStats();
                updateAllFilenames();
            }
        }
        
        function moveImagesToSectionAtPosition(imageFilenames, targetSectionId, insertIndex) {
            console.log(`📦 Déplacement groupé de ${imageFilenames.length} images vers section ${targetSectionId} à l'index ${insertIndex}`);
            
            // Collecter toutes les images dans l'ordre fourni (qui respecte l'ordre d'origine)
            const imagesToMove = [];
            
            // Pour chaque nom de fichier dans l'ordre fourni, trouver et collecter l'image
            imageFilenames.forEach(filename => {
                let image = null;
                
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    image = appState.unassignedImages[unassignedIndex];
                    if (image) imagesToMove.push(image);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            image = section.images[imageIndex];
                            if (image) imagesToMove.push(image);
                            break;
                        }
                    }
                }
            });
            
            // Maintenant supprimer les images de leurs positions actuelles
            // Supprimer dans l'ordre inverse pour éviter les décalages d'index
            imageFilenames.slice().reverse().forEach(filename => {
                // Chercher dans unassigned
                const unassignedIndex = appState.unassignedImages.findIndex(img => img.filename === filename);
                if (unassignedIndex !== -1) {
                    appState.unassignedImages.splice(unassignedIndex, 1);
                } else {
                    // Chercher dans les sections
                    for (let section of appState.sections) {
                        const imageIndex = section.images.findIndex(img => img.filename === filename);
                        if (imageIndex !== -1) {
                            section.images.splice(imageIndex, 1);
                            break;
                        }
                    }
                }
            });
            
            console.log(`  📋 ${imagesToMove.length} images collectées pour déplacement (ordre préservé)`);
            
            if (imagesToMove.length === 0) return;
            
            if (targetSectionId === 'unassigned') {
                // Ajouter toutes les images aux non attribuées
                appState.unassignedImages.push(...imagesToMove);
            } else {
                // Insérer dans la section cible à la position spécifiée
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    // Calculer la position d'insertion réelle (en tenant compte des suppressions)
                    let actualInsertIndex = Math.min(insertIndex, targetSection.images.length);
                    
                    // Insérer toutes les images en bloc à la position calculée
                    targetSection.images.splice(actualInsertIndex, 0, ...imagesToMove);
                    
                    console.log(`  ✅ Images insérées dans section ${targetSection.sectionNumber} à l'index ${actualInsertIndex}`);
                }
            }
            
            updateStats();
            updateAllFilenames();
        }

        function reorderImagesInSection(sectionId) {
            // Récupérer l'ordre actuel depuis le DOM
            const grid = document.querySelector(`[data-section-id="${sectionId}"]`);
            const imageCards = grid.querySelectorAll('.image-card');
            const section = appState.sections.find(s => s.id === sectionId);
            
            if (section) {
                const newOrder = Array.from(imageCards).map(card => {
                    const filename = card.dataset.imageFilename;
                    return section.images.find(img => img.filename === filename);
                }).filter(img => img); // Filtrer les undefined
                
                section.images = newOrder;
                updateAllFilenames();
            }
        }


        
        function updateNomenclatureNumber(sectionId, newNumber) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (section) {
                section.nomenclatureNumber = newNumber.trim();
                // Marquer comme personnalisé si différent du numéro de section
                section.isCustomNomenclature = (newNumber.trim() !== section.sectionNumber);
                updateAllFilenames();
                renderSections(); // Re-render pour mettre à jour l'exemple et les noms de fichiers
            }
        }
        
        function editNomenclature(sectionId, currentNomenclature, element) {
            const section = appState.sections.find(s => s.id === sectionId);
            if (!section) return;
            
            // Créer un input temporaire
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentNomenclature;
            input.className = 'nomenclature-input';
            input.style.cssText = `
                background: rgba(15, 23, 42, 0.9);
                border: 2px solid var(--accent-blue);
                border-radius: 6px;
                color: white;
                padding: 0.25rem 0.5rem;
                font-size: 0.9rem;
                font-weight: 600;
                font-family: Monaco, Menlo, monospace;
                min-width: 100px;
                outline: none;
            `;
            
            // Remplacer temporairement le contenu
            const originalHTML = element.innerHTML;
            element.innerHTML = '';
            element.appendChild(input);
            
            // Focus et sélectionner le texte
            input.focus();
            input.select();
            
            // Fonction pour valider et revenir à l'affichage normal
            const finishEdit = () => {
                const newValue = input.value.trim();
                if (newValue && newValue !== currentNomenclature) {
                    updateNomenclatureNumber(sectionId, newValue);
                } else {
                    // Annuler, remettre l'affichage original
                    element.innerHTML = originalHTML;
                }
            };
            
            // Événements
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    element.innerHTML = originalHTML;
                }
            });
        }

        function generateFilename(sectionNumber, imageNumber) {
            return `${appState.prefix}-${appState.documentName}-${sectionNumber} n_${imageNumber}.${appState.format}`;
        }

        function updateAllFilenames() {
            // Mettre à jour l'affichage des noms de fichiers
            renderSections();
        }

        function updateStats() {
            document.getElementById('sectionsCount').textContent = appState.sections.length;
            document.getElementById('imagesCount').textContent = extractedImages.length;
            updateSelectionStats();
        }

        function updateUnassignedImages() {
            console.log('🔄 Mise à jour des images non attribuées...');
            
            const assignedFilenames = new Set();
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    assignedFilenames.add(image.filename);
                });
            });
            
            console.log(`  Images assignées: ${assignedFilenames.size}`);
            console.log(`  Images extraites total: ${extractedImages.length}`);
            
            appState.unassignedImages = extractedImages.filter(image => 
                !assignedFilenames.has(image.filename)
            );
            
            console.log(`  Images non attribuées calculées: ${appState.unassignedImages.length}`);
            
            renderUnassignedImages();
        }
        
        function renderUnassignedImages() {
            const container = document.getElementById('unassignedImagesContainer');
            const grid = document.getElementById('unassignedGrid');
            const badge = document.getElementById('unassignedBadge');
            
            // TOUJOURS vider le contenu HTML d'abord pour éviter les doublons
            grid.innerHTML = '';
            
            if (appState.unassignedImages.length === 0) {
                container.style.display = 'none';
            } else {
                container.style.display = 'block';
                badge.textContent = appState.unassignedImages.length;
                
                grid.innerHTML = appState.unassignedImages.map((image, index) => 
                    renderImageCard(image, 'NON-ATTRIBUEE', index + 1)
                ).join('');
                
                // Synchroniser l'état de sélection pour les images non attribuées
                setTimeout(() => {
                    const unassignedCards = grid.querySelectorAll('.image-card');
                    unassignedCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (selectedImages.has(filename) && !card.classList.contains('selected')) {
                            card.classList.add('selected');
                            logDebug(`✅ Synchronisation: classe 'selected' ajoutée à ${filename} (non attribuée)`);
                        }
                    });
                }, 10);
            }
        }

        function showImagePreview(filename, event = null) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            logDebug(`Aperçu demandé pour: ${filename}`);
            
            // Construire la liste de toutes les images disponibles
            buildCurrentImagesList();
            
            // Trouver l'index de l'image courante
            currentImageIndex = currentImagesList.findIndex(img => img.filename === filename);
            if (currentImageIndex === -1) {
                currentImageIndex = 0;
                logError(`Image non trouvée dans la liste: ${filename}`);
            }
            
            // Créer ou récupérer l'instance de modal
            if (!imageModalInstance) {
                imageModalInstance = new bootstrap.Modal(document.getElementById('imageModal'));
                setupModalKeyboardNavigation();
            }
            
            // Afficher l'image actuelle
            displayCurrentImage();
            
            // Afficher la modal
            imageModalInstance.show();
        }
        
        function buildCurrentImagesList() {
            currentImagesList = [];
            
            // Ajouter d'abord les images non attribuées
            appState.unassignedImages.forEach(image => {
                currentImagesList.push({
                    filename: image.filename,
                    page: image.page,
                    section: 'Non attribuées',
                    sectionNumber: 'N/A'
                });
            });
            
            // Puis ajouter les images de toutes les sections dans l'ordre
            appState.sections.forEach(section => {
                section.images.forEach((image, index) => {
                    currentImagesList.push({
                        filename: image.filename,
                        page: image.page,
                        section: section.name,
                        sectionNumber: section.nomenclatureNumber || section.sectionNumber || section.number,
                        imageNumber: index + 1
                    });
                });
            });
            
            logDebug(`Liste d'images construite: ${currentImagesList.length} images`);
        }
        
        function displayCurrentImage() {
            if (currentImagesList.length === 0) return;
            
            const currentImage = currentImagesList[currentImageIndex];
            const modalImage = document.getElementById('modalImage');
            const modalInfo = document.getElementById('modalImageInfo');
            const modalCounter = document.getElementById('modalImageCounter');
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            const loading = document.getElementById('modalImageLoading');
            
            // Afficher le loading
            loading.style.display = 'block';
            modalImage.style.opacity = '0.5';
            
            // Mettre à jour les boutons de navigation
            prevBtn.disabled = currentImageIndex === 0;
            nextBtn.disabled = currentImageIndex === currentImagesList.length - 1;
            
            // Mettre à jour le compteur
            modalCounter.textContent = `${currentImageIndex + 1} / ${currentImagesList.length}`;
            
            // Charger la nouvelle image avec timestamp anti-cache
            const newImageSrc = `/image/${appState.documentName}/${currentImage.filename}?t=${Date.now()}`;
            
            modalImage.onload = function() {
                loading.style.display = 'none';
                modalImage.style.opacity = '1';
                modalImage.classList.add('modal-image-transition');
                
                // Supprimer la classe d'animation après l'animation
                setTimeout(() => {
                    modalImage.classList.remove('modal-image-transition');
                }, 300);
            };
            
            modalImage.onerror = function() {
                loading.style.display = 'none';
                modalImage.style.opacity = '1';
                modalInfo.innerHTML = `<span class="text-danger">❌ Erreur de chargement de l'image</span>`;
            };
            
            modalImage.src = newImageSrc;
            
            // Mettre à jour les informations
            const sectionInfo = currentImage.section !== 'Non attribuées' ? 
                `Section ${currentImage.sectionNumber}${currentImage.imageNumber ? ` - Image ${currentImage.imageNumber}` : ''}` : 
                currentImage.section;
                
            modalInfo.innerHTML = `
                <div class="d-flex justify-content-between align-items-center w-100">
                    <div>
                        <strong>Fichier:</strong> ${currentImage.filename}<br>
                        <strong>Section:</strong> ${sectionInfo}<br>
                        <strong>Page:</strong> ${currentImage.page}
                    </div>
                </div>
            `;
            
            logDebug(`Affichage image ${currentImageIndex + 1}/${currentImagesList.length}: ${currentImage.filename}`);
        }
        
        function navigateImage(direction) {
            if (currentImagesList.length === 0) return;
            
            const newIndex = currentImageIndex + direction;
            
            if (newIndex >= 0 && newIndex < currentImagesList.length) {
                currentImageIndex = newIndex;
                displayCurrentImage();
            }
        }
        
        function setupModalKeyboardNavigation() {
            const modalElement = document.getElementById('imageModal');
            
            modalElement.addEventListener('keydown', function(event) {
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        navigateImage(-1);
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        navigateImage(1);
                        break;
                    case 'Escape':
                        event.preventDefault();
                        imageModalInstance.hide();
                        break;
                    case 'Home':
                        event.preventDefault();
                        if (currentImagesList.length > 0) {
                            currentImageIndex = 0;
                            displayCurrentImage();
                        }
                        break;
                    case 'End':
                        event.preventDefault();
                        if (currentImagesList.length > 0) {
                            currentImageIndex = currentImagesList.length - 1;
                            displayCurrentImage();
                        }
                        break;
                }
            });
            
            // S'assurer que la modal peut recevoir le focus pour les événements clavier
            modalElement.addEventListener('shown.bs.modal', function() {
                modalElement.focus();
            });
        }

        // Fonction pour éditer l'image depuis la modal de preview
        function editCurrentModalImage() {
            if (currentImagesList.length > 0 && currentImageIndex >= 0 && currentImageIndex < currentImagesList.length) {
                const currentImage = currentImagesList[currentImageIndex];
                logInfo(`🎨 Ouverture éditeur depuis modal pour: ${currentImage.filename}`);
                
                // Vérifier que l'éditeur d'images est disponible
                if (typeof window.openImageEditor !== 'function') {
                    logError('Éditeur d\'images non disponible');
                    alert('L\'éditeur d\'images n\'est pas encore chargé. Veuillez réessayer dans quelques secondes.');
                    return;
                }
                
                // Fermer la modal de preview
                if (imageModalInstance) {
                    imageModalInstance.hide();
                }
                
                // Ouvrir l'éditeur d'images
                setTimeout(() => {
                    window.openImageEditor(currentImage.filename, currentImage);
                }, 300); // Délai pour que la modal se ferme proprement
            } else {
                logError('Aucune image courante pour édition');
            }
        }

        // Fonction pour toggle les tips
        function toggleTips() {
            const content = document.getElementById('tipsContent');
            const chevron = document.getElementById('tipsChevron');
            
            content.classList.toggle('collapsed');
            chevron.classList.toggle('rotated');
        }
        
        // Variables globales pour le sélecteur de section
        let currentSectionSelector = null;
        
        // Variables globales pour la sélection multiple
        let selectedImages = new Set();
        
        // Variables pour le drag stack
        let dragStackContainer = null;
        let isDraggingMultiple = false;
        
        // Variables pour la navigation d'images dans la modal
        let currentImageIndex = 0;
        let currentImagesList = [];
        let imageModalInstance = null;
        
        // Système de logs pour le debug
        let appLogs = [];
        const MAX_LOGS = 100;
        
        function logDebug(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'debug',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] DEBUG:`, message, data || '');
        }
        
        function logInfo(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'info',
                message: message,
                data: data
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.log(`[${timestamp}] INFO:`, message, data || '');
        }
        
        function logError(message, error = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                time: timestamp,
                type: 'error',
                message: message,
                data: error ? error.toString() : null
            };
            appLogs.unshift(logEntry);
            if (appLogs.length > MAX_LOGS) {
                appLogs.pop();
            }
            console.error(`[${timestamp}] ERROR:`, message, error || '');
        }
        
        function showSectionSelector(imageFilename, event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Fermer le sélecteur existant s'il y en a un
            closeSectionSelector();
            
            // Créer le sélecteur
            const selector = document.createElement('div');
            selector.className = 'section-selector';
            selector.innerHTML = generateSectionSelectorHTML(imageFilename);
            
            // Positionner le sélecteur près du bouton
            const rect = event.target.getBoundingClientRect();
            selector.style.left = (rect.left + window.scrollX + 60) + 'px';
            selector.style.top = (rect.top + window.scrollY - 150) + 'px';
            
            // Ajouter au document
            document.body.appendChild(selector);
            currentSectionSelector = selector;
            
            // Fermer le sélecteur si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeSectionSelectorOnClickOutside);
            }, 100);
        }
        
        function generateSectionSelectorHTML(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const selectedCount = selectedImages.size;
            const totalToMove = isImageSelected ? selectedCount : (selectedCount > 0 ? selectedCount + 1 : 1);
            
            let html = `
                <div class="section-selector-header">
                    <i class="fas fa-arrow-right me-2"></i>
                    ${totalToMove > 1 ? 
                        `Assigner ${totalToMove} images à une section` : 
                        'Assigner à une section'
                    }
                    ${totalToMove > 1 ? `<div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        ${isImageSelected ? 'Cette image + sélection' : 'Cette image + ' + selectedCount + ' sélectionnées'}
                    </div>` : ''}
                </div>
            `;
            
            // Ajouter toutes les sections disponibles
            appState.sections.forEach(section => {
                const level = section.level || 1;
                const sectionNumber = section.sectionNumber || section.number;
                const nomenclatureNumber = section.nomenclatureNumber || sectionNumber;
                const levelIcon = level === 1 ? '<i class="fas fa-book"></i>' : level === 2 ? '<i class="fas fa-file-alt"></i>' : level === 3 ? '<i class="fas fa-sticky-note"></i>' : '<i class="fas fa-clipboard"></i>';
                const levelClass = level === 2 ? 'section-option-level-2' : level === 3 ? 'section-option-level-3' : '';
                
                html += `
                    <div class="section-option ${levelClass}" onclick="assignImageToSection('${imageFilename}', ${section.id})">
                        <span class="section-option-number">${levelIcon} ${nomenclatureNumber}</span>
                        <span class="section-option-label">Section ${sectionNumber}</span>
                    </div>
                `;
            });
            
            return html;
        }
        
        function assignImageToSection(imageFilename, targetSectionId) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMove = [];
            
            // Ajouter l'image cliquée si elle n'est pas déjà sélectionnée
            if (!isImageSelected) {
                imagesToMove.push(imageFilename);
            }
            
            // Ajouter toutes les images sélectionnées
            imagesToMove.push(...getSelectedImagesList());
            
            logInfo(`📋 Déplacement animé de ${imagesToMove.length} images vers ${targetSectionId === 'unassigned' ? 'les non attribuées' : 'section ' + targetSectionId}`);
            
            // Déplacer avec animation
            animateImagesMoveToSection(imagesToMove, targetSectionId);
        }
        
        function closeSectionSelector() {
            if (currentSectionSelector) {
                currentSectionSelector.remove();
                currentSectionSelector = null;
                document.removeEventListener('click', closeSectionSelectorOnClickOutside);
            }
        }
        
        function closeSectionSelectorOnClickOutside(event) {
            if (currentSectionSelector && !currentSectionSelector.contains(event.target)) {
                closeSectionSelector();
            }
        }
        
        // === ANIMATION DE DÉPLACEMENT D'IMAGES ===
        
        function animateImagesMoveToSection(imagesToMove, targetSectionId) {
            logInfo(`🎬 Début animation pour ${imagesToMove.length} images`);
            
            // Fermer le sélecteur immédiatement
            closeSectionSelector();
            
            // Animer les images avec un délai échelonné pour un effet cascade
            imagesToMove.forEach((filename, index) => {
                setTimeout(() => {
                    animateImageMove(filename, targetSectionId);
                }, index * 100); // 100ms de délai entre chaque image
            });
            
            // Après la dernière animation, mettre à jour l'interface
            const totalDelay = imagesToMove.length * 100 + 700; // 700ms = durée de l'animation
            setTimeout(() => {
                finalizeMoveAfterAnimation(imagesToMove, targetSectionId);
            }, totalDelay);
        }
        
        function animateImageMove(imageFilename, targetSectionId) {
            const sourceCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
            if (!sourceCard) {
                logError(`Image source introuvable: ${imageFilename}`);
                return;
            }
            
            // Capturer la position initiale
            const sourceRect = sourceCard.getBoundingClientRect();
            const sourceImage = sourceCard.querySelector('.image-preview');
            
            // Calculer la position de destination
            const targetPos = calculateTargetPosition(targetSectionId);
            if (!targetPos) {
                logError(`Position cible introuvable pour section: ${targetSectionId}`);
                return;
            }
            
            // Créer la copie animée
            const animatedImage = createAnimatedImageCopy(sourceImage, sourceRect, imageFilename);
            
            // Masquer temporairement l'image source
            sourceCard.style.opacity = '0.3';
            sourceCard.style.transform = 'scale(0.95)';
            
            // Déclencher l'animation après un petit délai pour permettre le rendu
            setTimeout(() => {
                animatedImage.classList.add('animating');
                animatedImage.style.left = targetPos.x + 'px';
                animatedImage.style.top = targetPos.y + 'px';
                animatedImage.style.width = targetPos.width + 'px';
                animatedImage.style.height = targetPos.height + 'px';
            }, 50);
            
            // Nettoyer après l'animation
            setTimeout(() => {
                // Effet de fade out final
                animatedImage.classList.add('fade-out');
                setTimeout(() => {
                    if (animatedImage.parentNode) {
                        animatedImage.parentNode.removeChild(animatedImage);
                    }
                }, 300);
                
                // Restaurer l'opacité de l'image source
                sourceCard.style.opacity = '';
                sourceCard.style.transform = '';
            }, 700);
        }
        
        function createAnimatedImageCopy(sourceImage, sourceRect, imageFilename) {
            const animatedImage = document.createElement('div');
            animatedImage.className = 'image-slide-animation';
            
            // Positionner exactement sur l'image source
            animatedImage.style.left = sourceRect.left + 'px';
            animatedImage.style.top = sourceRect.top + 'px';
            animatedImage.style.width = sourceRect.width + 'px';
            animatedImage.style.height = sourceRect.height + 'px';
            
            // Copier l'image
            const img = document.createElement('img');
            img.src = sourceImage.src;
            img.alt = imageFilename;
            animatedImage.appendChild(img);
            
            // Ajouter au document
            document.body.appendChild(animatedImage);
            
            return animatedImage;
        }
        
        function calculateTargetPosition(targetSectionId) {
            let targetContainer;
            
            if (targetSectionId === 'unassigned') {
                targetContainer = document.getElementById('unassignedGrid');
            } else {
                targetContainer = document.querySelector(`[data-section-id="${targetSectionId}"] .images-grid`);
            }
            
            if (!targetContainer) {
                logError(`Container cible introuvable: ${targetSectionId}`);
                return null;
            }
            
            const targetRect = targetContainer.getBoundingClientRect();
            
            // Calculer la position exacte où l'image va apparaître
            const existingImages = targetContainer.querySelectorAll('.image-card');
            const gridCols = Math.floor(targetContainer.offsetWidth / 232); // 200px + 32px gap/margin
            const nextImageIndex = existingImages.length;
            
            const row = Math.floor(nextImageIndex / gridCols);
            const col = nextImageIndex % gridCols;
            
            // Calculer position exacte dans la grille CSS
            const imageWidth = 200;
            const imageHeight = 220; // Hauteur standard d'une carte image
            const gap = 16; // 1rem = 16px
            const padding = 16; // Padding du container
            
            const x = targetRect.left + padding + col * (imageWidth + gap);
            const y = targetRect.top + padding + row * (imageHeight + gap);
            
            return {
                x: x,
                y: y,
                width: imageWidth,
                height: imageHeight
            };
        }
        
        function finalizeMoveAfterAnimation(imagesToMove, targetSectionId) {
            logInfo(`🎬 Finalisation du déplacement de ${imagesToMove.length} images`);
            
            // Effectuer le déplacement réel dans les données
            if (targetSectionId === 'unassigned') {
                imagesToMove.forEach(filename => {
                    moveImageToSection(filename, targetSectionId);
                });
            } else {
                const targetSection = appState.sections.find(s => s.id === targetSectionId);
                if (targetSection) {
                    moveImagesToSectionAtPosition(imagesToMove, targetSectionId, targetSection.images.length);
                }
            }
            
            // Nettoyer la sélection
            clearSelection();
            
            // Mettre à jour l'interface
            renderSections();
            updateUnassignedImages();
            updateStats();
            
            logInfo(`✅ ${imagesToMove.length} images déplacées avec animation terminée`);
        }
        
        // Fonctions de sélection multiple
        function toggleImageSelection(imageFilename, isSelected) {
            const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
            
            if (isSelected) {
                selectedImages.add(imageFilename);
                imageCard.classList.add('selected');
            } else {
                selectedImages.delete(imageFilename);
                imageCard.classList.remove('selected');
            }
            
            updateSelectionStats();
        }
        
        function toggleImageSelectionByClick(imageFilename) {
            try {
                const isCurrentlySelected = selectedImages.has(imageFilename);
                const imageCard = document.querySelector(`[data-image-filename="${imageFilename}"]`);
                
                logDebug(`Toggle sélection - Image: ${imageFilename}, Actuellement sélectionnée: ${isCurrentlySelected}`);
                
                if (!imageCard) {
                    logError(`Element DOM introuvable pour l'image: ${imageFilename}`);
                    return;
                }
                
                // Vérifier la section parente pour diagnostic
                const parentSection = imageCard.closest('[data-section-id]');
                const sectionId = parentSection ? parentSection.dataset.sectionId : 'inconnue';
                logDebug(`Image ${imageFilename} dans section ID: ${sectionId}`);
                
                if (isCurrentlySelected) {
                    selectedImages.delete(imageFilename);
                    imageCard.classList.remove('selected');
                    logDebug(`✅ Image désélectionnée: ${imageFilename}, Classes après: ${imageCard.className}`);
                } else {
                    selectedImages.add(imageFilename);
                    imageCard.classList.add('selected');
                    logDebug(`✅ Image sélectionnée: ${imageFilename}, Classes après: ${imageCard.className}`);
                    
                    // Vérifier que la classe a bien été ajoutée
                    setTimeout(() => {
                        const hasSelectedClass = imageCard.classList.contains('selected');
                        logDebug(`Vérification retardée - Classe 'selected' présente: ${hasSelectedClass}`);
                        if (!hasSelectedClass) {
                            logError(`❌ La classe 'selected' n'a pas été appliquée à ${imageFilename}`);
                        }
                    }, 100);
                }
                
                updateSelectionStats();
            } catch (error) {
                logError(`Erreur lors de la sélection de l'image ${imageFilename}:`, error);
            }
        }
        
        function updateSelectionStats() {
            document.getElementById('selectedCount').textContent = selectedImages.size;
        }
        
        function clearSelection() {
            const count = selectedImages.size;
            selectedImages.forEach(filename => {
                const imageCard = document.querySelector(`[data-image-filename="${filename}"]`);
                if (imageCard) imageCard.classList.remove('selected');
            });
            selectedImages.clear();
            updateSelectionStats();
            logDebug(`Sélection vidée - ${count} images désélectionnées`);
        }
        
        function getSelectedImagesList() {
            // Retourner les images sélectionnées dans l'ordre d'apparition dans l'interface
            const allImages = document.querySelectorAll('.image-card');
            const orderedSelectedImages = [];
            
            allImages.forEach(card => {
                const filename = card.dataset.imageFilename;
                if (selectedImages.has(filename)) {
                    orderedSelectedImages.push(filename);
                }
            });
            
            return orderedSelectedImages;
        }
        
        function getSelectedImagesInSourceOrder() {
            // Retourner les images sélectionnées dans l'ordre qu'elles avaient dans leurs sections d'origine
            const orderedSelectedImages = [];
            
            // D'abord, chercher dans les images non attribuées
            appState.unassignedImages.forEach(image => {
                if (selectedImages.has(image.filename)) {
                    orderedSelectedImages.push(image.filename);
                }
            });
            
            // Ensuite, parcourir toutes les sections dans l'ordre hiérarchique
            appState.sections.forEach(section => {
                section.images.forEach(image => {
                    if (selectedImages.has(image.filename)) {
                        orderedSelectedImages.push(image.filename);
                    }
                });
            });
            
            return orderedSelectedImages;
        }
        
        function toggleSelectAll() {
            try {
                const allImageCards = document.querySelectorAll('.image-card');
                logDebug(`Toggle select all - ${allImageCards.length} images trouvées, ${selectedImages.size} sélectionnées`);
                
                // Vérifier combien d'images actuellement visibles sont sélectionnées
                let visibleSelectedCount = 0;
                allImageCards.forEach(card => {
                    const filename = card.dataset.imageFilename;
                    if (selectedImages.has(filename)) {
                        visibleSelectedCount++;
                    }
                });
                
                const allVisibleSelected = (allImageCards.length > 0 && visibleSelectedCount === allImageCards.length);
                logDebug(`Images visibles sélectionnées: ${visibleSelectedCount}/${allImageCards.length}, tout sélectionné: ${allVisibleSelected}`);
                
                if (allVisibleSelected) {
                    // Tout désélectionner
                    logDebug('Désélection de toutes les images');
                    clearSelection();
                    document.getElementById('selectAllText').textContent = 'Tout sélectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-check-square';
                } else {
                    // Tout sélectionner
                    logDebug('Sélection de toutes les images visibles');
                    allImageCards.forEach(card => {
                        const filename = card.dataset.imageFilename;
                        if (!selectedImages.has(filename)) {
                            selectedImages.add(filename);
                            card.classList.add('selected');
                        }
                    });
                    updateSelectionStats();
                    document.getElementById('selectAllText').textContent = 'Tout désélectionner';
                    document.querySelector('#selectAllBtn i').className = 'fas fa-square';
                }
            } catch (error) {
                logError('Erreur dans toggleSelectAll:', error);
            }
        }
        
        // Fonctions pour le drag stack
        function createDragStack(imageFilename, mousePosX, mousePosY) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToShow = [];
            
            // Ajouter l'image principale si elle n'est pas sélectionnée
            if (!isImageSelected) {
                imagesToShow.push(imageFilename);
            }
            
            // Ajouter les images sélectionnées (max 4 pour l'affichage)
            const selectedList = getSelectedImagesList();
            imagesToShow.push(...selectedList.slice(0, 4));
            
            if (imagesToShow.length <= 1) return;
            
            // Créer le container
            dragStackContainer = document.createElement('div');
            dragStackContainer.className = 'drag-stack-container';
            dragStackContainer.style.left = (mousePosX - 75) + 'px';
            dragStackContainer.style.top = (mousePosY - 50) + 'px';
            
            // Créer les images empilées (maximum 3 visibles + compteur)
            imagesToShow.slice(0, 3).forEach((filename, index) => {
                const stackImage = document.createElement('div');
                stackImage.className = `drag-stack-image stack-${index + 1}`;
                
                const img = document.createElement('img');
                img.src = `/image/${appState.documentName}/${filename}`;
                img.onerror = () => img.style.display = 'none';
                
                stackImage.appendChild(img);
                dragStackContainer.appendChild(stackImage);
            });
            
            // Ajouter le compteur si plus de 3 images
            if (imagesToShow.length > 1) {
                const counter = document.createElement('div');
                counter.className = 'drag-stack-counter';
                counter.textContent = imagesToShow.length;
                dragStackContainer.appendChild(counter);
            }
            
            document.body.appendChild(dragStackContainer);
            isDraggingMultiple = true;
        }
        
        function updateDragStackPosition(mousePosX, mousePosY) {
            if (dragStackContainer) {
                dragStackContainer.style.left = (mousePosX - 75) + 'px';
                dragStackContainer.style.top = (mousePosY - 50) + 'px';
            }
        }
        
        function removeDragStack() {
            if (dragStackContainer) {
                dragStackContainer.remove();
                dragStackContainer = null;
                isDraggingMultiple = false;
            }
        }
        
        function markImagesAsBeingDragged(imageFilename) {
            const isImageSelected = selectedImages.has(imageFilename);
            const imagesToMark = [];
            
            if (!isImageSelected) {
                imagesToMark.push(imageFilename);
            }
            imagesToMark.push(...getSelectedImagesList());
            
            imagesToMark.forEach(filename => {
                const card = document.querySelector(`[data-image-filename="${filename}"]`);
                if (card) {
                    card.classList.add('being-dragged');
                }
            });
        }
        
        function unmarkImagesAsBeingDragged() {
            document.querySelectorAll('.being-dragged').forEach(card => {
                card.classList.remove('being-dragged');
            });
        }
        
        function setupDragStackMouseTracking() {
            // Utiliser un tracking global de souris pour SortableJS
            let isTrackingMouse = false;
            
            document.addEventListener('mousedown', function(e) {
                if (e.target.closest('.image-card')) {
                    isTrackingMouse = true;
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDraggingMultiple && dragStackContainer && isTrackingMouse) {
                    updateDragStackPosition(e.clientX, e.clientY);
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                isTrackingMouse = false;
            });
        }
        
        function exportImages() {
            // Générer la configuration d'export
            const exportConfig = {
                prefix: appState.prefix,
                documentName: appState.documentName,
                format: appState.format,
                sections: appState.sections.map(section => ({
                    number: section.nomenclatureNumber || section.sectionNumber || section.number,
                    displayNumber: section.sectionNumber || section.number,
                    name: section.name,
                    level: section.level || 1,
                    images: section.images.map((image, index) => ({
                        originalFilename: image.filename,
                        newFilename: generateFilename(section.nomenclatureNumber || section.sectionNumber || section.number, index + 1),
                        page: image.page
                    }))
                }))
            };
            
            // Envoyer la configuration au serveur pour générer le ZIP
            fetch('/export-custom', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportConfig)
            })
            .then(response => response.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `${appState.documentName}_custom.zip`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Erreur lors de l\'export:', error);
                alert('Erreur lors de l\'export. Veuillez réessayer.');
            });
        }

    </script>

    <!-- Include Image Editor Modal -->
    {% include 'partials/image-editor-modal.html' %}

    <!-- Image Editor Scripts -->
    <script src="{{ url_for('static', filename='js/image-editor.js') }}"></script>
</body>
</html> 