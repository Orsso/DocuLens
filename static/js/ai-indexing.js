/**
 * Module d'auto-indexation IA pour DocuLens v3.0
 * 
 * REFONTE COMPL√àTE - ARCHITECTURE IMMUABLE :
 * ‚úÖ Aucun renommage physique de fichiers
 * ‚úÖ Stockage des m√©tadonn√©es IA dans appState uniquement
 * ‚úÖ Utilisation d'ImageDisplayManager pour l'affichage
 * ‚úÖ Mise √† jour de l'interface via renderSections()
 */

class AIIndexingManager {
    constructor() {
        this.isProcessing = false;
        this.results = [];
        this.documentName = null;
        this.version = '3.0.0-IMMUTABLE-METADATA';
        
        console.log(`üöÄ [AIIndexingManager] v${this.version} - Architecture Immuable initialis√©e`);
        this.init();
    }
    
    init() {
        this.checkServiceStatus();
    }
    
    /**
     * V√©rifie le statut du service d'indexation IA
     */
    async checkServiceStatus() {
        try {
            const response = await fetch('/api/ai-indexing/status');
            const data = await response.json();
            
            this.updateServiceStatus(data);
            return data.available && data.connection;
        } catch (error) {
            console.error('Erreur lors de la v√©rification du service:', error);
            this.updateServiceStatus({
                available: false,
                connection: false,
                message: 'Erreur de connexion au service'
            });
            return false;
        }
    }
    
    /**
     * Met √† jour l'affichage du statut du service
     */
    updateServiceStatus(status) {
        const statusElement = document.getElementById('aiServiceStatus');
        const buttonElement = document.getElementById('aiIndexingBtn');
        
        if (!statusElement || !buttonElement) return;
        
        statusElement.innerHTML = '';
        
        if (status.available && status.connection) {
            statusElement.innerHTML = `
                <div class="ai-status-indicator ai-status-available">
                    <i class="fas fa-check-circle"></i>
                    <span>Service IA disponible</span>
                </div>
            `;
            buttonElement.disabled = false;
        } else if (status.available && !status.connection) {
            statusElement.innerHTML = `
                <div class="ai-status-indicator ai-status-warning">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>Connexion API instable</span>
                </div>
            `;
            buttonElement.disabled = false;
        } else {
            statusElement.innerHTML = `
                <div class="ai-status-indicator ai-status-unavailable">
                    <i class="fas fa-times-circle"></i>
                    <span>Service IA indisponible</span>
                </div>
                <small class="ai-status-message">${status.message}</small>
            `;
            buttonElement.disabled = true;
        }
    }
    
    /**
     * D√©marre l'auto-indexation des images s√©lectionn√©es
     */
    async startAutoIndexing() {
        if (this.isProcessing) return;
        
        const selectedImages = this.getSelectedImages();
        
        console.log('üîç Debug s√©lection d\'images:', {
            selectedCount: selectedImages.length,
            selectedImages: selectedImages
        });
        
        if (selectedImages.length === 0) {
            const totalImages = document.querySelectorAll('.image-card').length;
            const message = totalImages > 0 
                ? `Aucune image s√©lectionn√©e. Cliquez sur les images pour les s√©lectionner (${totalImages} image(s) disponible(s)).`
                : 'Aucune image disponible.';
            
            this.showNotification(message, 'warning');
            return;
        }
        
        // V√©rifier le service avant de commencer
        const serviceAvailable = await this.checkServiceStatus();
        if (!serviceAvailable) {
            this.showNotification('Service d\'indexation IA non disponible', 'error');
            return;
        }
        
        this.documentName = appState.documentName;
        
        // Utiliser le syst√®me unifi√©
        if (typeof window.aiIndexingModal !== 'undefined') {
            window.aiIndexingModal.show(selectedImages);
        } else {
            console.error('Modal unifi√© non disponible, fallback vers ancien syst√®me');
            this.showNotification('Erreur d\'interface', 'error');
        }
    }
    
    /**
     * R√©cup√®re les images s√©lectionn√©es
     */
    getSelectedImages() {
        if (typeof window.selectedImages !== 'undefined' && window.selectedImages instanceof Set) {
            return Array.from(window.selectedImages);
        }
        
        // Fallback : chercher les images avec la classe 'selected'
        const selectedImageCards = document.querySelectorAll('.image-card.selected');
        const selectedImageFilenames = [];
        
        selectedImageCards.forEach(card => {
            const filename = card.dataset.imageFilename;
            if (filename) {
                selectedImageFilenames.push(filename);
            }
        });
        
        return selectedImageFilenames;
    }
    
    /**
     * üÜï NOUVELLE M√âTHODE : Application des suggestions IA
     * Stocke les m√©tadonn√©es IA sans renommer les fichiers physiques
     */
    async applyAISuggestions(selectedSuggestions) {
        try {
            console.log('üöÄ [AI-Indexing] Application des suggestions IA (m√©tadonn√©es uniquement)');
            console.log('üìã Suggestions √† appliquer:', selectedSuggestions);
            
            if (!window.appState) {
                throw new Error('appState non disponible');
            }
            
            // üîç DEBUG COMPLET: Afficher toute la structure appState
            console.log('üß™ [DEBUG] Structure compl√®te appState:');
            console.log('üì¶ appState:', JSON.stringify(window.appState, null, 2));
            console.log('üî¢ Nombre de sections:', window.appState.sections?.length || 0);
            console.log('üî¢ Images non-assign√©es:', window.appState.unassignedImages?.length || 0);
            
            // Appliquer les m√©tadonn√©es IA dans appState
            const updatedCount = this.updateAppStateWithAIMetadata(selectedSuggestions);
            
            if (updatedCount > 0) {
                // Vider le cache pour forcer la r√©g√©n√©ration des noms
                if (window.imageDisplayManager) {
                    window.imageDisplayManager.clearNameCache();
                }
                
                // Re-rendre l'interface pour afficher les nouveaux noms IA
                if (typeof renderSections === 'function') {
                    renderSections();
                }

                // Mettre √† jour les statistiques
                if (typeof updateStats === 'function') {
                    updateStats();
                }
                
                this.showNotification(
                    `${updatedCount} image(s) index√©e(s) avec succ√®s`,
                    'success'
                );
                
                console.log(`‚úÖ [AI-Indexing] ${updatedCount} images mises √† jour dans appState`);
                return true;
            } else {
                throw new Error('Aucune image mise √† jour');
            }
            
        } catch (error) {
            console.error('‚ùå [AI-Indexing] Erreur lors de l\'application des suggestions:', error);
            this.showNotification(
                `Erreur lors de l'indexation: ${error.message}`,
                'error'
            );
            return false;
        }
    }
    
    /**
     * üÜï Met √† jour appState avec les m√©tadonn√©es IA (sans renommage physique)
     */
    updateAppStateWithAIMetadata(suggestions) {
        let updatedCount = 0;
        
        // Appliquer la v√©rification des doublons c√¥t√© client
        const uniqueSuggestions = this.ensureUniqueAINames(suggestions);
        
        uniqueSuggestions.forEach(suggestion => {
            const { filename, suggested_name } = suggestion;

            console.log(`üîç [AI-Indexing] Traitement m√©tadonn√©es pour: ${filename} -> "${suggested_name}"`);
            
            // Chercher l'image dans les sections
            let imageFound = false;
            
            // 1. Chercher dans les sections assign√©es
            if (window.appState.sections && Array.isArray(window.appState.sections)) {
                for (const section of window.appState.sections) {
                    const image = section.images.find(img => img.filename === filename);
                    if (image) {
                        image.isAIRenamed = true;
                        image.aiSuggestedName = suggested_name;
                        imageFound = true;
                        updatedCount++;
                        console.log(`  ‚úÖ [AI-Indexing] Image mise √† jour dans section: ${filename}`);
                        break;
                    }
                }
            }
            
            // 2. Chercher dans les images non assign√©es si pas encore trouv√©e
            if (!imageFound && window.appState.unassignedImages && Array.isArray(window.appState.unassignedImages)) {
                const image = window.appState.unassignedImages.find(img => img.filename === filename);
                if (image) {
                    image.isAIRenamed = true;
                    image.aiSuggestedName = suggested_name;
                    imageFound = true;
                    updatedCount++;
                    console.log(`  ‚úÖ [AI-Indexing] Image mise √† jour dans non-assign√©es: ${filename}`);
                }
            }
            
            if (!imageFound) {
                console.warn(`  ‚ö†Ô∏è [AI-Indexing] Image non trouv√©e dans appState: ${filename}`);
                
                // Debug: Lister toutes les images disponibles
                console.log('üîç [DEBUG] Images disponibles dans appState:');
                console.log(`üî¢ [DEBUG] window.appState existe:`, !!window.appState);
                console.log(`üî¢ [DEBUG] sections existe:`, !!window.appState?.sections);
                console.log(`üî¢ [DEBUG] nombre de sections:`, window.appState?.sections?.length || 0);
                console.log(`üî¢ [DEBUG] unassignedImages existe:`, !!window.appState?.unassignedImages);
                console.log(`üî¢ [DEBUG] nombre unassigned:`, window.appState?.unassignedImages?.length || 0);
                
                if (window.appState?.sections) {
                    window.appState.sections.forEach((section, i) => {
                        console.log(`  Section ${i} (${section.name}): ${section.images?.length || 0} images`);
                        if (section.images) {
                            section.images.forEach(img => {
                                console.log(`    - ${img.filename}`);
                            });
                        }
                    });
                } else {
                    console.log('‚ùå [DEBUG] Pas de sections dans appState');
                }
                
                if (window.appState?.unassignedImages) {
                    console.log(`  Images non-assign√©es: ${window.appState.unassignedImages.length}`);
                    window.appState.unassignedImages.forEach(img => {
                        console.log(`    - ${img.filename}`);
                    });
                } else {
                    console.log('‚ùå [DEBUG] Pas d\'images non-assign√©es dans appState');
                }
                
                // Debug suppl√©mentaire: structure compl√®te
                console.log('üèóÔ∏è [DEBUG] Structure appState compl√®te:');
                console.log(JSON.stringify(window.appState, null, 2));
                }
        });
        
        console.log(`üìä [AI-Indexing] Bilan mise √† jour appState: ${updatedCount}/${uniqueSuggestions.length} images mises √† jour`);
        return updatedCount;
    }

    /**
     * üîç Assure l'unicit√© des noms IA c√¥t√© client
     * V√©rifie les doublons dans toutes les images d√©j√† index√©es
     */
    ensureUniqueAINames(suggestions) {
        console.log('üîç [AI-Indexing] V√©rification unicit√© des noms IA c√¥t√© client');
        
        // R√©cup√©rer tous les noms IA existants dans appState
        const existingAINames = this.getExistingAINames();
        console.log('üìã Noms IA existants:', existingAINames);
        
        const titleCounts = {};
        
        // Initialiser les compteurs avec les noms existants
        existingAINames.forEach(existingName => {
            const baseName = existingName;
            let numberSuffix = 1;
            
            // Si le nom se termine par " X" o√π X est un nombre
            const match = existingName.match(/^(.+)\s(\d+)$/);
            if (match) {
                const extractedBaseName = match[1];
                const extractedNumber = parseInt(match[2]);
                
                if (!titleCounts[extractedBaseName] || titleCounts[extractedBaseName] < extractedNumber) {
                    titleCounts[extractedBaseName] = extractedNumber;
                }
            } else {
                // Nom sans num√©ro
                if (!titleCounts[baseName]) {
                    titleCounts[baseName] = 1;
                }
            }
        });
        
        // Traiter les nouvelles suggestions
        const uniqueSuggestions = suggestions.map(suggestion => {
            const originalName = suggestion.suggested_name.trim();
            
            if (titleCounts[originalName]) {
                titleCounts[originalName]++;
                const uniqueName = `${originalName} ${titleCounts[originalName]}`;
                console.log(`üìù Nom IA rendu unique: "${originalName}" -> "${uniqueName}"`);
                
                return {
                    ...suggestion,
                    suggested_name: uniqueName
                };
            } else {
                titleCounts[originalName] = 1;
                return suggestion;
            }
        });
        
        console.log(`‚úÖ ${uniqueSuggestions.length} noms IA v√©rifi√©s pour unicit√©`);
        return uniqueSuggestions;
    }

    /**
     * üîç R√©cup√®re tous les noms IA existants dans appState
     */
    getExistingAINames() {
        const existingNames = [];
        
        try {
            if (window.appState && window.appState.sections) {
                window.appState.sections.forEach(section => {
                    if (section.images) {
                        section.images.forEach(image => {
                            if (image.isAIRenamed && image.aiSuggestedName) {
                                existingNames.push(image.aiSuggestedName);
                            }
                        });
                    }
                });
            }
            
            if (window.appState && window.appState.unassignedImages) {
                window.appState.unassignedImages.forEach(image => {
                    if (image.isAIRenamed && image.aiSuggestedName) {
                        existingNames.push(image.aiSuggestedName);
                    }
                });
            }
        } catch (error) {
            console.error('‚ùå Erreur lors de la r√©cup√©ration des noms IA existants:', error);
        }
        
        return existingNames;
    }
    
    /**
     * üîÑ M√âTHODE DE COMPATIBILIT√â : Applique les renommages (legacy support)
     * Maintenant redirige vers la nouvelle m√©thode de m√©tadonn√©es
     */
    async applyRenames(selectedSuggestions) {
        console.log('üîÑ [AI-Indexing] applyRenames appel√© - redirection vers m√©tadonn√©es uniquement');
        
        // Transformer le format pour la nouvelle m√©thode
        const suggestions = selectedSuggestions.map(rename => ({
            filename: rename.original_filename,
            suggested_name: rename.suggested_ia_name
        }));
        
        return this.applyAISuggestions(suggestions);
                }
                
    /**
     * üîÑ M√âTHODE DE COMPATIBILIT√â : updateInterfaceAfterRename (legacy support)
     * Maintenant utilise renderSections() global
     */
    updateInterfaceAfterRename(updatedResults) {
        console.log('üîÑ [AI-Indexing] updateInterfaceAfterRename appel√© - utilisation de renderSections()');
        
        // Forcer le nettoyage du cache
        if (window.imageDisplayManager) {
            window.imageDisplayManager.clearNameCache();
        }
        
        // Re-rendre compl√®tement l'interface
        if (typeof renderSections === 'function') {
            renderSections();
        }
        
        // Mettre √† jour les statistiques
        if (typeof updateStats === 'function') {
            updateStats();
        }
        
        console.log('‚úÖ [AI-Indexing] Interface mise √† jour via renderSections()');
    }
    
    /**
     * Affiche une notification
     */
    showNotification(message, type = 'info') {
        const alertClass = {
            'success': 'alert-success',
            'error': 'alert-danger',
            'warning': 'alert-warning',
            'info': 'alert-info'
        }[type] || 'alert-info';
        
        const notification = document.createElement('div');
        notification.className = `alert ${alertClass} alert-dismissible fade show position-fixed`;
        notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
        notification.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-supprimer apr√®s 5 secondes
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
}

// Initialiser le gestionnaire d'auto-indexation
let aiIndexingManager;

document.addEventListener('DOMContentLoaded', function() {
    aiIndexingManager = new AIIndexingManager();
    window.aiIndexingManager = aiIndexingManager;
});

// Fonction globale pour d√©marrer l'auto-indexation
function startAIIndexing() {
    if (aiIndexingManager) {
        aiIndexingManager.startAutoIndexing();
    }
} 